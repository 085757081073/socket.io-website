{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/chat-1.png","path":"images/chat-1.png","modified":0,"renderable":0},{"_id":"source/images/chat-2.png","path":"images/chat-2.png","modified":0,"renderable":0},{"_id":"source/images/chat-3.png","path":"images/chat-3.png","modified":0,"renderable":0},{"_id":"source/images/chat-4.png","path":"images/chat-4.png","modified":0,"renderable":0},{"_id":"source/images/chat-5.png","path":"images/chat-5.png","modified":0,"renderable":0},{"_id":"source/images/icons8.png","path":"images/icons8.png","modified":0,"renderable":0},{"_id":"source/images/mixmax.png","path":"images/mixmax.png","modified":0,"renderable":0},{"_id":"themes/socket.io/source/css/home.styl","path":"css/home.styl","modified":0,"renderable":1},{"_id":"themes/socket.io/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/socket.io/source/fonts/untitled-font-2.eot","path":"fonts/untitled-font-2.eot","modified":0,"renderable":1},{"_id":"themes/socket.io/source/fonts/untitled-font-2.svg","path":"fonts/untitled-font-2.svg","modified":0,"renderable":1},{"_id":"themes/socket.io/source/fonts/untitled-font-2.ttf","path":"fonts/untitled-font-2.ttf","modified":0,"renderable":1},{"_id":"themes/socket.io/source/fonts/untitled-font-2.woff","path":"fonts/untitled-font-2.woff","modified":0,"renderable":1},{"_id":"themes/socket.io/source/js/home.js","path":"js/home.js","modified":0,"renderable":1},{"_id":"themes/socket.io/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/socket.io/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/socket.io/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/socket.io/source/css/images/logo.svg","path":"css/images/logo.svg","modified":0,"renderable":1},{"_id":"themes/socket.io/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/socket.io/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/socket.io/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/index.html","hash":"d7c174051a60bd461e17a973096f61f58de3cecc","modified":1532295168288},{"_id":"source/socket-io-with-apache-cordova.md","hash":"0476e40377dd8543fd18a3a05a3e4b3f7f0475a3","modified":1532154985155},{"_id":"themes/socket.io/_config.yml","hash":"2ae38e93e91e09c751b16443242f7caed5718814","modified":1532297302564},{"_id":"source/demos/chat.md","hash":"b633bec8fc03ed6e7f6d455a1031f0d26335f205","modified":1531863933665},{"_id":"source/demos/whiteboard.md","hash":"890f470d2ec145b8dd55491cae841e60560603b9","modified":1531864096793},{"_id":"source/docs/client-api.md","hash":"58679fa1337a9e1caa8a24c3f8c4cc9a96ff430f","modified":1531863775793},{"_id":"source/docs/emit-cheatsheet.md","hash":"c5c1ec7f9c27c6274c07e2913fe2eebe8481dfd3","modified":1532153380784},{"_id":"source/docs/faq.md","hash":"c4f32bcab19a06c2bea0b0886c8a12ed680b1172","modified":1532153621612},{"_id":"source/docs/logging-and-debugging.md","hash":"44d3a20abc534eae92c936e055dedff033b94acb","modified":1532153186908},{"_id":"source/docs/index.md","hash":"a631e217577abaf1c53237e0cf6af8bbba8e390e","modified":1532150376879},{"_id":"source/docs/rooms-and-namespaces.md","hash":"ae0ac84c974598dd3894bb076c57432a16356c6e","modified":1532151497145},{"_id":"source/docs/migrating-from-0-9.md","hash":"80cda5830b6481f2d2c2a27990281a00aacbdc88","modified":1532152230830},{"_id":"source/docs/server-api.md","hash":"206077d6f1d132b482c75621f3edce8c6fa08b3a","modified":1531863105648},{"_id":"source/docs/using-multiple-nodes.md","hash":"ef483e38841a32ff13e994d74ac72b9ffd756aa0","modified":1532152857611},{"_id":"source/get-started/chat.md","hash":"74da282e033efb7d55ff1c8a6f2ee826e7adeb15","modified":1532156064643},{"_id":"source/get-started/index.md","hash":"55716de4f47d9abf6e73a3510bc21bab8fc792d4","modified":1532156333600},{"_id":"source/images/chat-1.png","hash":"9129f20369143c58ddab6b91a0d71fff3fe5a09f","modified":1532154760499},{"_id":"source/images/chat-2.png","hash":"cd0cafe5e25d0f9e204f6fe89e37010092d99f54","modified":1532154760503},{"_id":"source/images/chat-3.png","hash":"210f007ebef228cc46d685b984836f831ad34a11","modified":1532154760507},{"_id":"source/images/chat-4.png","hash":"42140809580212e08a4392bc8694b1649564ae2a","modified":1532154760507},{"_id":"source/images/chat-5.png","hash":"f25ae2f12a8846805cb48fbdd3f94151d2cb73c7","modified":1532154760511},{"_id":"source/images/icons8.png","hash":"20f2007a539fad43c3feb285e8e30063d8384f42","modified":1527701198324},{"_id":"source/images/mixmax.png","hash":"e85773da96f4f6d7aac90b836bcf082af8c4a6c0","modified":1527701357512},{"_id":"themes/socket.io/layout/layout.ejs","hash":"21c826e3a0839c0ef419bb02587412694788c10e","modified":1532239857606},{"_id":"themes/socket.io/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1532294650299},{"_id":"themes/socket.io/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1532243571907},{"_id":"themes/socket.io/layout/_partial/ad.ejs","hash":"4a78b23d2997d390c6f16a64c36238d2578f1556","modified":1527543167672},{"_id":"themes/socket.io/layout/_partial/after-footer.ejs","hash":"ca5b1c719d88de0c984bc70b965b2d623b2b82a3","modified":1532296027768},{"_id":"themes/socket.io/layout/_partial/article.ejs","hash":"1921dd9f6f1e27e84fb7e241ca96b75915c5c92f","modified":1532151134622},{"_id":"themes/socket.io/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1527308649643},{"_id":"themes/socket.io/layout/_partial/head.ejs","hash":"1deee062d0863bc2fa9ca73b0df3413c5c3e0dff","modified":1532294660711},{"_id":"themes/socket.io/layout/_partial/header.ejs","hash":"4852e448e77715dcf1f11fa1020d57dfde1c4786","modified":1532296428268},{"_id":"themes/socket.io/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1527308649643},{"_id":"themes/socket.io/layout/_partial/sidebar.ejs","hash":"1d32cc9cf9d8e342ce8dacc81ded0d7a167afa5e","modified":1532154937623},{"_id":"themes/socket.io/layout/_partial/sponsors.ejs","hash":"659d4b12fee38f01be287b380d7869dd8041939b","modified":1531860634791},{"_id":"themes/socket.io/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1527832998866},{"_id":"themes/socket.io/source/css/_variables.styl","hash":"d39a9e9f0eedb7ab1548de2d4ba8136ae758af08","modified":1527832998870},{"_id":"themes/socket.io/source/css/home.styl","hash":"ef9722f64efa5869396c0147fb510815433b91b6","modified":1532296355708},{"_id":"themes/socket.io/source/css/style.styl","hash":"8353397a22cfb0db6dd3374518aeff59686c8d28","modified":1532240753765},{"_id":"themes/socket.io/source/fonts/untitled-font-2.eot","hash":"745d68dcec4dc452caccc13f4828e7d0028f2769","modified":1532243504623},{"_id":"themes/socket.io/source/fonts/untitled-font-2.svg","hash":"e85b27f6e740d553da8035897c38e510dd38c083","modified":1532243504627},{"_id":"themes/socket.io/source/fonts/untitled-font-2.ttf","hash":"49a22ffab0f7fe040c2b6087a24487256ba94ad9","modified":1532243504627},{"_id":"themes/socket.io/source/fonts/untitled-font-2.woff","hash":"1648f82b55f78dea0e171f0466aaeb6f5bc577df","modified":1532243504627},{"_id":"themes/socket.io/source/js/home.js","hash":"0c3963506e0ddec1fb9943023c43bd2573b61cbd","modified":1532295299573},{"_id":"themes/socket.io/source/css/_partial/ad.styl","hash":"83ef25a5e7c66aee6ac4512783eacaf56078dd66","modified":1527708150484},{"_id":"themes/socket.io/source/css/_partial/article.styl","hash":"522b79129a661b9d3a3cd27fc14d31206fde5d3a","modified":1531862621424},{"_id":"themes/socket.io/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1527308649651},{"_id":"themes/socket.io/source/css/_partial/header.styl","hash":"a9427ee7acd7f7b3ef4bbb710b5f41d7562e89fc","modified":1531862377342},{"_id":"themes/socket.io/source/css/_partial/highlight.styl","hash":"fe98104512b5862f22d4ed0ddf8253a9b9e92998","modified":1527400261824},{"_id":"themes/socket.io/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1527832998866},{"_id":"themes/socket.io/source/css/_partial/normalize.styl","hash":"c51f9beeb00290a6f7e41fd945ff2ebb3f4f3473","modified":1527311165172},{"_id":"themes/socket.io/source/css/_partial/sidebar.styl","hash":"8ec460ecda0bca5ff0af3432a8ab7e13a1dbd291","modified":1531862512652},{"_id":"themes/socket.io/source/css/_partial/sponsors.styl","hash":"20d7024e0f01091bbed2fe752043bdec37bd2349","modified":1531860642023},{"_id":"themes/socket.io/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1527308649655},{"_id":"themes/socket.io/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1527308649655},{"_id":"themes/socket.io/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1532294735748},{"_id":"themes/socket.io/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1532294735748},{"_id":"themes/socket.io/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1532294735776},{"_id":"themes/socket.io/source/css/images/logo.svg","hash":"87a44a0442be8e7812adcc04069a1d66e5494f6a","modified":1527310834876},{"_id":"themes/socket.io/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1532294735772},{"_id":"themes/socket.io/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1532294735764},{"_id":"public/index.html","hash":"949b2113d443ac68301f0277929a1c9c98a22ebc","modified":1532587204476},{"_id":"public/demos/chat/index.html","hash":"66b38b588f69503cef29019a088f150f3e282df0","modified":1532587204477},{"_id":"public/demos/whiteboard/index.html","hash":"653e7919c83bd3a40ad9af8ca5e0bd33f7ed2b45","modified":1532587204477},{"_id":"public/docs/emit-cheatsheet/index.html","hash":"ef5eaa6ed3fc6b3fd3d1c2c9336bff62d3bff1f9","modified":1532587204477},{"_id":"public/docs/faq/index.html","hash":"18dd387edc488045b29373ae6e392407d06dd163","modified":1532587204477},{"_id":"public/docs/logging-and-debugging/index.html","hash":"3008632598ec518e7faf09e9614fdf7bdee927c6","modified":1532587204477},{"_id":"public/docs/using-multiple-nodes/index.html","hash":"424f202df746fc716577b836b18966714a9eeab9","modified":1532587204477},{"_id":"public/get-started/index.html","hash":"da9f77fff24eee132ea91b02ddd894e830c5a127","modified":1532587204477},{"_id":"public/socket-io-with-apache-cordova/index.html","hash":"94ca080635f3492fe474cf68614c056104217b46","modified":1532587204477},{"_id":"public/docs/client-api/index.html","hash":"d90ce8970e24aa81b5ca5715737dbb124381c0ed","modified":1532587204477},{"_id":"public/docs/index.html","hash":"c4b7c700827e2604c64ddb82d7d860772e110563","modified":1532587204477},{"_id":"public/docs/rooms-and-namespaces/index.html","hash":"2d6e3079e8b5260e6c201ac018e1feac88508c62","modified":1532587204478},{"_id":"public/docs/migrating-from-0-9/index.html","hash":"d251cc63f4905df88879bad4aa29d954986044a1","modified":1532587204478},{"_id":"public/docs/server-api/index.html","hash":"1ef074d318d56bccdc35bf9913e3ae4d61dac26d","modified":1532587204478},{"_id":"public/get-started/chat/index.html","hash":"a03e49282b70a3b1e1902612a56446009ef20fb9","modified":1532587204478},{"_id":"public/images/chat-1.png","hash":"9129f20369143c58ddab6b91a0d71fff3fe5a09f","modified":1532587204481},{"_id":"public/images/chat-2.png","hash":"cd0cafe5e25d0f9e204f6fe89e37010092d99f54","modified":1532587204481},{"_id":"public/images/chat-3.png","hash":"210f007ebef228cc46d685b984836f831ad34a11","modified":1532587204481},{"_id":"public/images/chat-4.png","hash":"42140809580212e08a4392bc8694b1649564ae2a","modified":1532587204481},{"_id":"public/images/chat-5.png","hash":"f25ae2f12a8846805cb48fbdd3f94151d2cb73c7","modified":1532587204481},{"_id":"public/images/mixmax.png","hash":"e85773da96f4f6d7aac90b836bcf082af8c4a6c0","modified":1532587204481},{"_id":"public/images/icons8.png","hash":"20f2007a539fad43c3feb285e8e30063d8384f42","modified":1532587204481},{"_id":"public/fonts/untitled-font-2.eot","hash":"745d68dcec4dc452caccc13f4828e7d0028f2769","modified":1532587204481},{"_id":"public/fonts/untitled-font-2.svg","hash":"e85b27f6e740d553da8035897c38e510dd38c083","modified":1532587204481},{"_id":"public/fonts/untitled-font-2.ttf","hash":"49a22ffab0f7fe040c2b6087a24487256ba94ad9","modified":1532587204481},{"_id":"public/fonts/untitled-font-2.woff","hash":"1648f82b55f78dea0e171f0466aaeb6f5bc577df","modified":1532587204481},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1532587204482},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1532587204482},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1532587204482},{"_id":"public/css/images/logo.svg","hash":"87a44a0442be8e7812adcc04069a1d66e5494f6a","modified":1532587204482},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1532587204701},{"_id":"public/css/style.css","hash":"73ab9b4bc73f6861defd7fe2c70a71994d50cd57","modified":1532587204731},{"_id":"public/js/home.js","hash":"0c3963506e0ddec1fb9943023c43bd2573b61cbd","modified":1532587204731},{"_id":"public/css/home.css","hash":"b0c78feb37b58c6499e98f9873f1d785ee15213f","modified":1532587204731},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1532587204736},{"_id":"themes/socket.io/source/images/favicon.png","hash":"109c0031e5886a6256eb5e9b839838948516df20","modified":1532297266176},{"_id":"public/images/favicon.png","hash":"109c0031e5886a6256eb5e9b839838948516df20","modified":1532587204482}],"Category":[],"Data":[],"Page":[{"_content":"\n<main class=\"site-main home\" role=\"main\">\n  <header class=\"entry-header fading\">\n    <h1 class=\"entry-title\">SOCKET.IO 2.0 IS HERE</h1>\n    <h2 class=\"entry-subtitle\"><span class=\"row\">FEATURING THE FASTEST AND MOST RELIABLE</span> <span class=\"row\">REAL-TIME ENGINE</span></h2>\n  </header><!-- .entry-header -->\n  <div id=\"screen-fill\">\n\n    <div class=\"window editor fading\">\n      <div class=\"header\">\n        <span class=\"bullet bullet-red\"></span><span class=\"bullet bullet-yellow\"></span><span class=\"bullet bullet-green\"></span><span class=\"title\">~/Projects/tweets/index.js</span>\n      </div>\n      <div class=\"body\">\n        <ol class=\"code\">\n          <li><span class=\"code\"><span class=\"v\">var</span> io = <span class=\"io\">require('socket.io')(80)</span>;</span></li>\n          <li><span class=\"code\"><span class=\"v\">var</span> cfg = require('./config.json');</span></li>\n          <li><span class=\"code\"><span class=\"v\">var</span> tw = require('node-tweet-stream')(cfg);</span></li>\n          <li><span class=\"code\">tw.track('socket.io');</span></li>\n          <li><span class=\"code\">tw.track('javascript');</span></li>\n          <li><span class=\"code\">tw.on('tweet', <span class=\"fn\">function</span>(tweet){</span></li>\n          <li><span class=\"code\">&nbsp;&nbsp;<span class=\"io\">io.emit('tweet', tweet)</span>;</span></li>\n          <li><span class=\"code\">});</span></li>\n        </ol>\n      </div>\n    </div>\n\n    <div class=\"window browser fading\">\n      <div class=\"header\">\n        <span class=\"bullet bullet-red\"></span><span class=\"bullet bullet-yellow\"></span><span class=\"bullet bullet-green\"></span><span class=\"title\"><span class=\"scheme\">https://</span>your-node-app.com</span>\n      </div>\n      <div class=\"body\">\n        <p>Tweets about <b>socket.io</b> and <b>javascript</b></p>\n        <ul id=\"tweets\" class=\"tweets\"></ul>\n      </div>\n    </div>\n\n    <span class=\"arrow fading\"><a href=\"#examples\">B</a></span>\n  </div>\n\n  <div class=\"entry-content\">\n    <p class=\"centered\">\n      <i class=\"larger\">Socket.IO enables real-time bidirectional event-based communication.</i><br />\n      <i>It works on every platform, browser or device, focusing equally on reliability and speed.</i>\n    </p>\n\n    <div id=\"entries\">\n      <div id=\"examples\">\n        <div class=\"example-column left\">\n          <div class=\"example-entry icon analytics\">\n            <h2>Real-time analytics</h2>\n            <p>Push data to clients that gets represented as real-time counters, charts or logs.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"example-entry icon binary\">\n            <h2>Binary streaming</h2>\n            <p>Starting in 1.0, it's possible to send any blob back and forth: image, audio, video.</p>\n          </div>\n        </div>\n\n        <div class=\"example-column right\">\n          <div class=\"example-entry icon chat\">\n            <h2>Instant messaging and chat</h2>\n            <p>Socket.IO's \"Hello world\" is a chat app in just a few lines of code.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"example-entry icon collab\">\n            <h2>Document collaboration</h2>\n            <p>Allow users to concurrently edit a document and see each other's changes.</p>\n          </div>\n        </div>\n      </div><!-- #examples -->\n\n      <div id=\"information\">\n        <div class=\"information-column left\">\n          <div class=\"information-entry\">\n            <h3>USED BY EVERYONE</h3>\n            <p>From Microsoft Office, Yammer, Zendesk, Trello... to hackathon winners and little startups.</p>\n            <p>One of the most powerful JavaScript frameworks on GitHub, and most depended-upon npm module.</p>\n          </div>\n        </div>\n\n        <div class=\"information-column right\">\n          <div class=\"information-entry\">\n            <h3>IMMENSELY POWERFUL, YET EASY TO USE</h3>\n            <p>Our getting started guide will show you how to create lots of amazing applications in fewer than 200 lines of code.</p>\n            <p>We're not making that up. Get started <a href=\"/get-started/chat\">now</a>.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"information-entry\">\n            <h3>JOIN THE COMMUNITY</h3>\n            <ul style=\"margin-left: 0px; list-style-type: none; padding-left: 0\">\n              <li style=\"margin-bottom: 5px;\">Real-time help? Find us on <a href=\"https://slackin-socketio.now.sh/\">Slack</a></li>\n              <li style=\"margin-bottom: 5px;\">Contribute code or report issues on <a href=\"https://github.com/socketio/socket.io\">GitHub</a></li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</main>\n","source":"index.html","raw":"\n<main class=\"site-main home\" role=\"main\">\n  <header class=\"entry-header fading\">\n    <h1 class=\"entry-title\">SOCKET.IO 2.0 IS HERE</h1>\n    <h2 class=\"entry-subtitle\"><span class=\"row\">FEATURING THE FASTEST AND MOST RELIABLE</span> <span class=\"row\">REAL-TIME ENGINE</span></h2>\n  </header><!-- .entry-header -->\n  <div id=\"screen-fill\">\n\n    <div class=\"window editor fading\">\n      <div class=\"header\">\n        <span class=\"bullet bullet-red\"></span><span class=\"bullet bullet-yellow\"></span><span class=\"bullet bullet-green\"></span><span class=\"title\">~/Projects/tweets/index.js</span>\n      </div>\n      <div class=\"body\">\n        <ol class=\"code\">\n          <li><span class=\"code\"><span class=\"v\">var</span> io = <span class=\"io\">require('socket.io')(80)</span>;</span></li>\n          <li><span class=\"code\"><span class=\"v\">var</span> cfg = require('./config.json');</span></li>\n          <li><span class=\"code\"><span class=\"v\">var</span> tw = require('node-tweet-stream')(cfg);</span></li>\n          <li><span class=\"code\">tw.track('socket.io');</span></li>\n          <li><span class=\"code\">tw.track('javascript');</span></li>\n          <li><span class=\"code\">tw.on('tweet', <span class=\"fn\">function</span>(tweet){</span></li>\n          <li><span class=\"code\">&nbsp;&nbsp;<span class=\"io\">io.emit('tweet', tweet)</span>;</span></li>\n          <li><span class=\"code\">});</span></li>\n        </ol>\n      </div>\n    </div>\n\n    <div class=\"window browser fading\">\n      <div class=\"header\">\n        <span class=\"bullet bullet-red\"></span><span class=\"bullet bullet-yellow\"></span><span class=\"bullet bullet-green\"></span><span class=\"title\"><span class=\"scheme\">https://</span>your-node-app.com</span>\n      </div>\n      <div class=\"body\">\n        <p>Tweets about <b>socket.io</b> and <b>javascript</b></p>\n        <ul id=\"tweets\" class=\"tweets\"></ul>\n      </div>\n    </div>\n\n    <span class=\"arrow fading\"><a href=\"#examples\">B</a></span>\n  </div>\n\n  <div class=\"entry-content\">\n    <p class=\"centered\">\n      <i class=\"larger\">Socket.IO enables real-time bidirectional event-based communication.</i><br />\n      <i>It works on every platform, browser or device, focusing equally on reliability and speed.</i>\n    </p>\n\n    <div id=\"entries\">\n      <div id=\"examples\">\n        <div class=\"example-column left\">\n          <div class=\"example-entry icon analytics\">\n            <h2>Real-time analytics</h2>\n            <p>Push data to clients that gets represented as real-time counters, charts or logs.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"example-entry icon binary\">\n            <h2>Binary streaming</h2>\n            <p>Starting in 1.0, it's possible to send any blob back and forth: image, audio, video.</p>\n          </div>\n        </div>\n\n        <div class=\"example-column right\">\n          <div class=\"example-entry icon chat\">\n            <h2>Instant messaging and chat</h2>\n            <p>Socket.IO's \"Hello world\" is a chat app in just a few lines of code.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"example-entry icon collab\">\n            <h2>Document collaboration</h2>\n            <p>Allow users to concurrently edit a document and see each other's changes.</p>\n          </div>\n        </div>\n      </div><!-- #examples -->\n\n      <div id=\"information\">\n        <div class=\"information-column left\">\n          <div class=\"information-entry\">\n            <h3>USED BY EVERYONE</h3>\n            <p>From Microsoft Office, Yammer, Zendesk, Trello... to hackathon winners and little startups.</p>\n            <p>One of the most powerful JavaScript frameworks on GitHub, and most depended-upon npm module.</p>\n          </div>\n        </div>\n\n        <div class=\"information-column right\">\n          <div class=\"information-entry\">\n            <h3>IMMENSELY POWERFUL, YET EASY TO USE</h3>\n            <p>Our getting started guide will show you how to create lots of amazing applications in fewer than 200 lines of code.</p>\n            <p>We're not making that up. Get started <a href=\"/get-started/chat\">now</a>.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"information-entry\">\n            <h3>JOIN THE COMMUNITY</h3>\n            <ul style=\"margin-left: 0px; list-style-type: none; padding-left: 0\">\n              <li style=\"margin-bottom: 5px;\">Real-time help? Find us on <a href=\"https://slackin-socketio.now.sh/\">Slack</a></li>\n              <li style=\"margin-bottom: 5px;\">Contribute code or report issues on <a href=\"https://github.com/socketio/socket.io\">GitHub</a></li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</main>\n","date":"2018-07-22T21:32:48.288Z","updated":"2018-07-22T21:32:48.288Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"cjjxdyeas0000jgcxj3q0xlxg","content":"\n<main class=\"site-main home\" role=\"main\">\n  <header class=\"entry-header fading\">\n    <h1 class=\"entry-title\">SOCKET.IO 2.0 IS HERE</h1>\n    <h2 class=\"entry-subtitle\"><span class=\"row\">FEATURING THE FASTEST AND MOST RELIABLE</span> <span class=\"row\">REAL-TIME ENGINE</span></h2>\n  </header><!-- .entry-header -->\n  <div id=\"screen-fill\">\n\n    <div class=\"window editor fading\">\n      <div class=\"header\">\n        <span class=\"bullet bullet-red\"></span><span class=\"bullet bullet-yellow\"></span><span class=\"bullet bullet-green\"></span><span class=\"title\">~/Projects/tweets/index.js</span>\n      </div>\n      <div class=\"body\">\n        <ol class=\"code\">\n          <li><span class=\"code\"><span class=\"v\">var</span> io = <span class=\"io\">require('socket.io')(80)</span>;</span></li>\n          <li><span class=\"code\"><span class=\"v\">var</span> cfg = require('./config.json');</span></li>\n          <li><span class=\"code\"><span class=\"v\">var</span> tw = require('node-tweet-stream')(cfg);</span></li>\n          <li><span class=\"code\">tw.track('socket.io');</span></li>\n          <li><span class=\"code\">tw.track('javascript');</span></li>\n          <li><span class=\"code\">tw.on('tweet', <span class=\"fn\">function</span>(tweet){</span></li>\n          <li><span class=\"code\">&nbsp;&nbsp;<span class=\"io\">io.emit('tweet', tweet)</span>;</span></li>\n          <li><span class=\"code\">});</span></li>\n        </ol>\n      </div>\n    </div>\n\n    <div class=\"window browser fading\">\n      <div class=\"header\">\n        <span class=\"bullet bullet-red\"></span><span class=\"bullet bullet-yellow\"></span><span class=\"bullet bullet-green\"></span><span class=\"title\"><span class=\"scheme\">https://</span>your-node-app.com</span>\n      </div>\n      <div class=\"body\">\n        <p>Tweets about <b>socket.io</b> and <b>javascript</b></p>\n        <ul id=\"tweets\" class=\"tweets\"></ul>\n      </div>\n    </div>\n\n    <span class=\"arrow fading\"><a href=\"#examples\">B</a></span>\n  </div>\n\n  <div class=\"entry-content\">\n    <p class=\"centered\">\n      <i class=\"larger\">Socket.IO enables real-time bidirectional event-based communication.</i><br>\n      <i>It works on every platform, browser or device, focusing equally on reliability and speed.</i>\n    </p>\n\n    <div id=\"entries\">\n      <div id=\"examples\">\n        <div class=\"example-column left\">\n          <div class=\"example-entry icon analytics\">\n            <h2>Real-time analytics</h2>\n            <p>Push data to clients that gets represented as real-time counters, charts or logs.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"example-entry icon binary\">\n            <h2>Binary streaming</h2>\n            <p>Starting in 1.0, it's possible to send any blob back and forth: image, audio, video.</p>\n          </div>\n        </div>\n\n        <div class=\"example-column right\">\n          <div class=\"example-entry icon chat\">\n            <h2>Instant messaging and chat</h2>\n            <p>Socket.IO's \"Hello world\" is a chat app in just a few lines of code.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"example-entry icon collab\">\n            <h2>Document collaboration</h2>\n            <p>Allow users to concurrently edit a document and see each other's changes.</p>\n          </div>\n        </div>\n      </div><!-- #examples -->\n\n      <div id=\"information\">\n        <div class=\"information-column left\">\n          <div class=\"information-entry\">\n            <h3>USED BY EVERYONE</h3>\n            <p>From Microsoft Office, Yammer, Zendesk, Trello... to hackathon winners and little startups.</p>\n            <p>One of the most powerful JavaScript frameworks on GitHub, and most depended-upon npm module.</p>\n          </div>\n        </div>\n\n        <div class=\"information-column right\">\n          <div class=\"information-entry\">\n            <h3>IMMENSELY POWERFUL, YET EASY TO USE</h3>\n            <p>Our getting started guide will show you how to create lots of amazing applications in fewer than 200 lines of code.</p>\n            <p>We're not making that up. Get started <a href=\"/get-started/chat\">now</a>.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"information-entry\">\n            <h3>JOIN THE COMMUNITY</h3>\n            <ul style=\"margin-left: 0px; list-style-type: none; padding-left: 0\">\n              <li style=\"margin-bottom: 5px;\">Real-time help? Find us on <a href=\"https://slackin-socketio.now.sh/\" target=\"_blank\" rel=\"noopener\">Slack</a></li>\n              <li style=\"margin-bottom: 5px;\">Contribute code or report issues on <a href=\"https://github.com/socketio/socket.io\" target=\"_blank\" rel=\"noopener\">GitHub</a></li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</main>\n","site":{"data":{}},"excerpt":"","more":"\n<main class=\"site-main home\" role=\"main\">\n  <header class=\"entry-header fading\">\n    <h1 class=\"entry-title\">SOCKET.IO 2.0 IS HERE</h1>\n    <h2 class=\"entry-subtitle\"><span class=\"row\">FEATURING THE FASTEST AND MOST RELIABLE</span> <span class=\"row\">REAL-TIME ENGINE</span></h2>\n  </header><!-- .entry-header -->\n  <div id=\"screen-fill\">\n\n    <div class=\"window editor fading\">\n      <div class=\"header\">\n        <span class=\"bullet bullet-red\"></span><span class=\"bullet bullet-yellow\"></span><span class=\"bullet bullet-green\"></span><span class=\"title\">~/Projects/tweets/index.js</span>\n      </div>\n      <div class=\"body\">\n        <ol class=\"code\">\n          <li><span class=\"code\"><span class=\"v\">var</span> io = <span class=\"io\">require('socket.io')(80)</span>;</span></li>\n          <li><span class=\"code\"><span class=\"v\">var</span> cfg = require('./config.json');</span></li>\n          <li><span class=\"code\"><span class=\"v\">var</span> tw = require('node-tweet-stream')(cfg);</span></li>\n          <li><span class=\"code\">tw.track('socket.io');</span></li>\n          <li><span class=\"code\">tw.track('javascript');</span></li>\n          <li><span class=\"code\">tw.on('tweet', <span class=\"fn\">function</span>(tweet){</span></li>\n          <li><span class=\"code\">&nbsp;&nbsp;<span class=\"io\">io.emit('tweet', tweet)</span>;</span></li>\n          <li><span class=\"code\">});</span></li>\n        </ol>\n      </div>\n    </div>\n\n    <div class=\"window browser fading\">\n      <div class=\"header\">\n        <span class=\"bullet bullet-red\"></span><span class=\"bullet bullet-yellow\"></span><span class=\"bullet bullet-green\"></span><span class=\"title\"><span class=\"scheme\">https://</span>your-node-app.com</span>\n      </div>\n      <div class=\"body\">\n        <p>Tweets about <b>socket.io</b> and <b>javascript</b></p>\n        <ul id=\"tweets\" class=\"tweets\"></ul>\n      </div>\n    </div>\n\n    <span class=\"arrow fading\"><a href=\"#examples\">B</a></span>\n  </div>\n\n  <div class=\"entry-content\">\n    <p class=\"centered\">\n      <i class=\"larger\">Socket.IO enables real-time bidirectional event-based communication.</i><br>\n      <i>It works on every platform, browser or device, focusing equally on reliability and speed.</i>\n    </p>\n\n    <div id=\"entries\">\n      <div id=\"examples\">\n        <div class=\"example-column left\">\n          <div class=\"example-entry icon analytics\">\n            <h2>Real-time analytics</h2>\n            <p>Push data to clients that gets represented as real-time counters, charts or logs.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"example-entry icon binary\">\n            <h2>Binary streaming</h2>\n            <p>Starting in 1.0, it's possible to send any blob back and forth: image, audio, video.</p>\n          </div>\n        </div>\n\n        <div class=\"example-column right\">\n          <div class=\"example-entry icon chat\">\n            <h2>Instant messaging and chat</h2>\n            <p>Socket.IO's \"Hello world\" is a chat app in just a few lines of code.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"example-entry icon collab\">\n            <h2>Document collaboration</h2>\n            <p>Allow users to concurrently edit a document and see each other's changes.</p>\n          </div>\n        </div>\n      </div><!-- #examples -->\n\n      <div id=\"information\">\n        <div class=\"information-column left\">\n          <div class=\"information-entry\">\n            <h3>USED BY EVERYONE</h3>\n            <p>From Microsoft Office, Yammer, Zendesk, Trello... to hackathon winners and little startups.</p>\n            <p>One of the most powerful JavaScript frameworks on GitHub, and most depended-upon npm module.</p>\n          </div>\n        </div>\n\n        <div class=\"information-column right\">\n          <div class=\"information-entry\">\n            <h3>IMMENSELY POWERFUL, YET EASY TO USE</h3>\n            <p>Our getting started guide will show you how to create lots of amazing applications in fewer than 200 lines of code.</p>\n            <p>We're not making that up. Get started <a href=\"/get-started/chat\">now</a>.</p>\n          </div>\n          <div class=\"repel\"></div>\n          <div class=\"information-entry\">\n            <h3>JOIN THE COMMUNITY</h3>\n            <ul style=\"margin-left: 0px; list-style-type: none; padding-left: 0\">\n              <li style=\"margin-bottom: 5px;\">Real-time help? Find us on <a href=\"https://slackin-socketio.now.sh/\" target=\"_blank\" rel=\"noopener\">Slack</a></li>\n              <li style=\"margin-bottom: 5px;\">Contribute code or report issues on <a href=\"https://github.com/socketio/socket.io\" target=\"_blank\" rel=\"noopener\">GitHub</a></li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</main>\n"},{"title":"Socket.IO  —  Apache Cordova","_content":"\nSince Apache Cordova apps are written mostly in JS, it is actually really easy to use Socket.IO! Let&#8217;s walk through a small example.\n\nFirst we prepare a simple server:\n\n```js\nvar server = require('http').createServer();\nvar io = require('socket.io')(server);\n\nio.sockets.on('connection', function (socket) {\n    console.log('socket connected');\n\n    socket.on('disconnect', function () {\n        console.log('socket disconnected');\n    });\n\n    socket.emit('text', 'wow. such event. very real time.');\n});\n\nserver.listen(3000);\n```\n\nThis server will simply listen to Socket.IO client connections, and will emit some text to them via a `text` event.\n\nNow let&#8217;s get get down to the point. We want to start off by creating a new Cordova project to start modifying. Let&#8217;s start from scratch.\n\nRunning\n\n```\nnpm install -g cordova\n```\n\nwill install the actual Cordova cli tool we use to create projects, install/remove dependencies, and launch our emulator among other things.\n\n```\ncordova create socket.io-example socket.io.example socket.io-example\n```\n\nwill make a new project template for us to start modifying. Feel free to poke around the newly created folder, called `socket.io-example` and take a look at some of the created files.\n\nYou should now be in the project folder. If you didn&#8217;t navigate there yet in command line, do it now with `cd socket.io-example`.\n\nSince I&#8217;m developing this example on OS X, I&#8217;m going to build for iOS. You could do it similarly for Android. To add the build target, run the following:\n\n```\ncordova platform add ios\n```\n\nNext we want to build all the native components. We can do this by running\n\n```\ncordova build ios\n```\n\nNow let&#8217;s actually run the template application to see that everything is working. If you are on OS X, you can install the iOS emulator like so\n\n```\nbrew install ios-sim\n```\n\nYou should see the emulator open up with something like this when running `cordova emulate ios`:\n\n<img src=\"https://cloudup.com/cKoYEzCeKKY+\" alt=\"null\" />\n\nNow that you see everything working with the actual setup, let&#8217;s start write some code. Open up `www/index.html` in your project directory. It should look something like this:\n\n```html\n<!DOCTYPE html>\n<!--\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n-->\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"format-detection\" content=\"telephone=no\" />\n        <!-- WARNING: for iOS 7, remove the width=device-width and height=device-height attributes. See https://issues.apache.org/jira/browse/CB-4323 -->\n        <meta name=\"viewport\" content=\"user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi\" />\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"css/index.css\" />\n        <meta name=\"msapplication-tap-highlight\" content=\"no\" />\n        <title>Hello World</title>\n    </head>\n    <body>\n        <div class=\"app\">\n            <h1>Apache Cordova</h1>\n            <div id=\"deviceready\" class=\"blink\">\n                <p class=\"event listening\">Connecting to Device</p>\n                <p class=\"event received\">Device is Ready</p>\n            </div>\n        </div>\n        <script type=\"text/javascript\" src=\"cordova.js\"></script>\n        <script type=\"text/javascript\" src=\"js/index.js\"></script>\n        <script type=\"text/javascript\">\n            app.initialize();\n        </script>\n    </body>\n</html>\n```\n\nTo begin, we need to get the Socket.IO-client script. We can take it from the CDN like so:\n\n```html\n<script type=\"text/javascript\" src=\"cordova.js\"></script>\n<script type=\"text/javascript\" src=\"http://cdn.socket.io/socket.io-1.0.3.js\"></script>\n<script type=\"text/javascript\" src=\"js/index.js\"></script>\n```\n\nNow to add actual logic, let&#8217;s write things below the `app.initialize` call. We might want to make sure that the device has loaded the application before running any of our code. We can do this like so:\n\n```html\n<script type=\"text/javascript\">\n  app.initialize();\n\n  document.addEventListener('deviceready', function() {\n    // code goes here\n  });\n</script>\n```\n\nThis event will fire when the application has fully loaded. To add some actual logic, we just need to fill in that function. Let&#8217;s make something that receives the data emitted by our server on socket connection, and bring a notification box to show that text. Here&#8217;s what you could do:\n\n```html\n<script type=\"text/javascript\">\n  app.initialize();\n\n  document.addEventListener('deviceready', function() {\n    socket.on('connect', function() {\n      socket.on('text', function(text) {\n        alert(text);\n       });\n     });\n  });\n</script>\n```\n\nLet&#8217;s run the emulator again with `cordova emulate ios`, and here&#8217;s what you should see:\n\n<img src=\"https://cloudup.com/cuIaVMrmcyP+\" alt=\"null\" />\n\nThat&#8217;s it! I hope this will help to get you started! Have fun hacking!\n","source":"socket-io-with-apache-cordova.md","raw":"title: Socket.IO  —  Apache Cordova\npermalink: /socket-io-with-apache-cordova/\n---\n\nSince Apache Cordova apps are written mostly in JS, it is actually really easy to use Socket.IO! Let&#8217;s walk through a small example.\n\nFirst we prepare a simple server:\n\n```js\nvar server = require('http').createServer();\nvar io = require('socket.io')(server);\n\nio.sockets.on('connection', function (socket) {\n    console.log('socket connected');\n\n    socket.on('disconnect', function () {\n        console.log('socket disconnected');\n    });\n\n    socket.emit('text', 'wow. such event. very real time.');\n});\n\nserver.listen(3000);\n```\n\nThis server will simply listen to Socket.IO client connections, and will emit some text to them via a `text` event.\n\nNow let&#8217;s get get down to the point. We want to start off by creating a new Cordova project to start modifying. Let&#8217;s start from scratch.\n\nRunning\n\n```\nnpm install -g cordova\n```\n\nwill install the actual Cordova cli tool we use to create projects, install/remove dependencies, and launch our emulator among other things.\n\n```\ncordova create socket.io-example socket.io.example socket.io-example\n```\n\nwill make a new project template for us to start modifying. Feel free to poke around the newly created folder, called `socket.io-example` and take a look at some of the created files.\n\nYou should now be in the project folder. If you didn&#8217;t navigate there yet in command line, do it now with `cd socket.io-example`.\n\nSince I&#8217;m developing this example on OS X, I&#8217;m going to build for iOS. You could do it similarly for Android. To add the build target, run the following:\n\n```\ncordova platform add ios\n```\n\nNext we want to build all the native components. We can do this by running\n\n```\ncordova build ios\n```\n\nNow let&#8217;s actually run the template application to see that everything is working. If you are on OS X, you can install the iOS emulator like so\n\n```\nbrew install ios-sim\n```\n\nYou should see the emulator open up with something like this when running `cordova emulate ios`:\n\n<img src=\"https://cloudup.com/cKoYEzCeKKY+\" alt=\"null\" />\n\nNow that you see everything working with the actual setup, let&#8217;s start write some code. Open up `www/index.html` in your project directory. It should look something like this:\n\n```html\n<!DOCTYPE html>\n<!--\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n-->\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"format-detection\" content=\"telephone=no\" />\n        <!-- WARNING: for iOS 7, remove the width=device-width and height=device-height attributes. See https://issues.apache.org/jira/browse/CB-4323 -->\n        <meta name=\"viewport\" content=\"user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi\" />\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"css/index.css\" />\n        <meta name=\"msapplication-tap-highlight\" content=\"no\" />\n        <title>Hello World</title>\n    </head>\n    <body>\n        <div class=\"app\">\n            <h1>Apache Cordova</h1>\n            <div id=\"deviceready\" class=\"blink\">\n                <p class=\"event listening\">Connecting to Device</p>\n                <p class=\"event received\">Device is Ready</p>\n            </div>\n        </div>\n        <script type=\"text/javascript\" src=\"cordova.js\"></script>\n        <script type=\"text/javascript\" src=\"js/index.js\"></script>\n        <script type=\"text/javascript\">\n            app.initialize();\n        </script>\n    </body>\n</html>\n```\n\nTo begin, we need to get the Socket.IO-client script. We can take it from the CDN like so:\n\n```html\n<script type=\"text/javascript\" src=\"cordova.js\"></script>\n<script type=\"text/javascript\" src=\"http://cdn.socket.io/socket.io-1.0.3.js\"></script>\n<script type=\"text/javascript\" src=\"js/index.js\"></script>\n```\n\nNow to add actual logic, let&#8217;s write things below the `app.initialize` call. We might want to make sure that the device has loaded the application before running any of our code. We can do this like so:\n\n```html\n<script type=\"text/javascript\">\n  app.initialize();\n\n  document.addEventListener('deviceready', function() {\n    // code goes here\n  });\n</script>\n```\n\nThis event will fire when the application has fully loaded. To add some actual logic, we just need to fill in that function. Let&#8217;s make something that receives the data emitted by our server on socket connection, and bring a notification box to show that text. Here&#8217;s what you could do:\n\n```html\n<script type=\"text/javascript\">\n  app.initialize();\n\n  document.addEventListener('deviceready', function() {\n    socket.on('connect', function() {\n      socket.on('text', function(text) {\n        alert(text);\n       });\n     });\n  });\n</script>\n```\n\nLet&#8217;s run the emulator again with `cordova emulate ios`, and here&#8217;s what you should see:\n\n<img src=\"https://cloudup.com/cuIaVMrmcyP+\" alt=\"null\" />\n\nThat&#8217;s it! I hope this will help to get you started! Have fun hacking!\n","date":"2018-07-21T06:36:25.155Z","updated":"2018-07-21T06:36:25.155Z","path":"/socket-io-with-apache-cordova/index.html","comments":1,"layout":"page","_id":"cjjxdyeav0001jgcx4o7do97z","content":"<p>Since Apache Cordova apps are written mostly in JS, it is actually really easy to use Socket.IO! Let&#8217;s walk through a small example.</p>\n<p>First we prepare a simple server:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(server);</span><br><span class=\"line\"></span><br><span class=\"line\">io.sockets.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'socket connected'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'socket disconnected'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    socket.emit(<span class=\"string\">'text'</span>, <span class=\"string\">'wow. such event. very real time.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>This server will simply listen to Socket.IO client connections, and will emit some text to them via a <code>text</code> event.</p>\n<p>Now let&#8217;s get get down to the point. We want to start off by creating a new Cordova project to start modifying. Let&#8217;s start from scratch.</p>\n<p>Running</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g cordova</span><br></pre></td></tr></table></figure>\n<p>will install the actual Cordova cli tool we use to create projects, install/remove dependencies, and launch our emulator among other things.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cordova create socket.io-example socket.io.example socket.io-example</span><br></pre></td></tr></table></figure>\n<p>will make a new project template for us to start modifying. Feel free to poke around the newly created folder, called <code>socket.io-example</code> and take a look at some of the created files.</p>\n<p>You should now be in the project folder. If you didn&#8217;t navigate there yet in command line, do it now with <code>cd socket.io-example</code>.</p>\n<p>Since I&#8217;m developing this example on OS X, I&#8217;m going to build for iOS. You could do it similarly for Android. To add the build target, run the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cordova platform add ios</span><br></pre></td></tr></table></figure>\n<p>Next we want to build all the native components. We can do this by running</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cordova build ios</span><br></pre></td></tr></table></figure>\n<p>Now let&#8217;s actually run the template application to see that everything is working. If you are on OS X, you can install the iOS emulator like so</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install ios-sim</span><br></pre></td></tr></table></figure>\n<p>You should see the emulator open up with something like this when running <code>cordova emulate ios</code>:</p>\n<p><img src=\"https://cloudup.com/cKoYEzCeKKY+\" alt=\"null\"></p>\n<p>Now that you see everything working with the actual setup, let&#8217;s start write some code. Open up <code>www/index.html</code> in your project directory. It should look something like this:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    Licensed to the Apache Software Foundation (ASF) under one</span></span><br><span class=\"line\"><span class=\"comment\">    or more contributor license agreements.  See the NOTICE file</span></span><br><span class=\"line\"><span class=\"comment\">    distributed with this work for additional information</span></span><br><span class=\"line\"><span class=\"comment\">    regarding copyright ownership.  The ASF licenses this file</span></span><br><span class=\"line\"><span class=\"comment\">    to you under the Apache License, Version 2.0 (the</span></span><br><span class=\"line\"><span class=\"comment\">    \"License\"); you may not use this file except in compliance</span></span><br><span class=\"line\"><span class=\"comment\">    with the License.  You may obtain a copy of the License at</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    Unless required by applicable law or agreed to in writing,</span></span><br><span class=\"line\"><span class=\"comment\">    software distributed under the License is distributed on an</span></span><br><span class=\"line\"><span class=\"comment\">    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class=\"line\"><span class=\"comment\">     KIND, either express or implied.  See the License for the</span></span><br><span class=\"line\"><span class=\"comment\">    specific language governing permissions and limitations</span></span><br><span class=\"line\"><span class=\"comment\">    under the License.</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"telephone=no\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- WARNING: for iOS 7, remove the width=device-width and height=device-height attributes. See https://issues.apache.org/jira/browse/CB-4323 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"css/index.css\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"msapplication-tap-highlight\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"no\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Apache Cordova<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"deviceready\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blink\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"event listening\"</span>&gt;</span>Connecting to Device<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"event received\"</span>&gt;</span>Device is Ready<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cordova.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">            app.initialize();</span></span><br><span class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>To begin, we need to get the Socket.IO-client script. We can take it from the CDN like so:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cordova.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://cdn.socket.io/socket.io-1.0.3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Now to add actual logic, let&#8217;s write things below the <code>app.initialize</code> call. We might want to make sure that the device has loaded the application before running any of our code. We can do this like so:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  app.initialize();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'deviceready'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// code goes here</span></span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>This event will fire when the application has fully loaded. To add some actual logic, we just need to fill in that function. Let&#8217;s make something that receives the data emitted by our server on socket connection, and bring a notification box to show that text. Here&#8217;s what you could do:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  app.initialize();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'deviceready'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      socket.on(<span class=\"string\">'text'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        alert(text);</span></span><br><span class=\"line\"><span class=\"undefined\">       &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Let&#8217;s run the emulator again with <code>cordova emulate ios</code>, and here&#8217;s what you should see:</p>\n<p><img src=\"https://cloudup.com/cuIaVMrmcyP+\" alt=\"null\"></p>\n<p>That&#8217;s it! I hope this will help to get you started! Have fun hacking!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Since Apache Cordova apps are written mostly in JS, it is actually really easy to use Socket.IO! Let&#8217;s walk through a small example.</p>\n<p>First we prepare a simple server:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(server);</span><br><span class=\"line\"></span><br><span class=\"line\">io.sockets.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'socket connected'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'socket disconnected'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    socket.emit(<span class=\"string\">'text'</span>, <span class=\"string\">'wow. such event. very real time.'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>This server will simply listen to Socket.IO client connections, and will emit some text to them via a <code>text</code> event.</p>\n<p>Now let&#8217;s get get down to the point. We want to start off by creating a new Cordova project to start modifying. Let&#8217;s start from scratch.</p>\n<p>Running</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g cordova</span><br></pre></td></tr></table></figure>\n<p>will install the actual Cordova cli tool we use to create projects, install/remove dependencies, and launch our emulator among other things.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cordova create socket.io-example socket.io.example socket.io-example</span><br></pre></td></tr></table></figure>\n<p>will make a new project template for us to start modifying. Feel free to poke around the newly created folder, called <code>socket.io-example</code> and take a look at some of the created files.</p>\n<p>You should now be in the project folder. If you didn&#8217;t navigate there yet in command line, do it now with <code>cd socket.io-example</code>.</p>\n<p>Since I&#8217;m developing this example on OS X, I&#8217;m going to build for iOS. You could do it similarly for Android. To add the build target, run the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cordova platform add ios</span><br></pre></td></tr></table></figure>\n<p>Next we want to build all the native components. We can do this by running</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cordova build ios</span><br></pre></td></tr></table></figure>\n<p>Now let&#8217;s actually run the template application to see that everything is working. If you are on OS X, you can install the iOS emulator like so</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install ios-sim</span><br></pre></td></tr></table></figure>\n<p>You should see the emulator open up with something like this when running <code>cordova emulate ios</code>:</p>\n<p><img src=\"https://cloudup.com/cKoYEzCeKKY+\" alt=\"null\"></p>\n<p>Now that you see everything working with the actual setup, let&#8217;s start write some code. Open up <code>www/index.html</code> in your project directory. It should look something like this:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    Licensed to the Apache Software Foundation (ASF) under one</span></span><br><span class=\"line\"><span class=\"comment\">    or more contributor license agreements.  See the NOTICE file</span></span><br><span class=\"line\"><span class=\"comment\">    distributed with this work for additional information</span></span><br><span class=\"line\"><span class=\"comment\">    regarding copyright ownership.  The ASF licenses this file</span></span><br><span class=\"line\"><span class=\"comment\">    to you under the Apache License, Version 2.0 (the</span></span><br><span class=\"line\"><span class=\"comment\">    \"License\"); you may not use this file except in compliance</span></span><br><span class=\"line\"><span class=\"comment\">    with the License.  You may obtain a copy of the License at</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    Unless required by applicable law or agreed to in writing,</span></span><br><span class=\"line\"><span class=\"comment\">    software distributed under the License is distributed on an</span></span><br><span class=\"line\"><span class=\"comment\">    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class=\"line\"><span class=\"comment\">     KIND, either express or implied.  See the License for the</span></span><br><span class=\"line\"><span class=\"comment\">    specific language governing permissions and limitations</span></span><br><span class=\"line\"><span class=\"comment\">    under the License.</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"telephone=no\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- WARNING: for iOS 7, remove the width=device-width and height=device-height attributes. See https://issues.apache.org/jira/browse/CB-4323 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"css/index.css\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"msapplication-tap-highlight\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"no\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Apache Cordova<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"deviceready\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blink\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"event listening\"</span>&gt;</span>Connecting to Device<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"event received\"</span>&gt;</span>Device is Ready<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cordova.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">            app.initialize();</span></span><br><span class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>To begin, we need to get the Socket.IO-client script. We can take it from the CDN like so:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cordova.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://cdn.socket.io/socket.io-1.0.3.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Now to add actual logic, let&#8217;s write things below the <code>app.initialize</code> call. We might want to make sure that the device has loaded the application before running any of our code. We can do this like so:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  app.initialize();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'deviceready'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// code goes here</span></span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>This event will fire when the application has fully loaded. To add some actual logic, we just need to fill in that function. Let&#8217;s make something that receives the data emitted by our server on socket connection, and bring a notification box to show that text. Here&#8217;s what you could do:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  app.initialize();</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'deviceready'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      socket.on(<span class=\"string\">'text'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">text</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        alert(text);</span></span><br><span class=\"line\"><span class=\"undefined\">       &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">     &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Let&#8217;s run the emulator again with <code>cordova emulate ios</code>, and here&#8217;s what you should see:</p>\n<p><img src=\"https://cloudup.com/cuIaVMrmcyP+\" alt=\"null\"></p>\n<p>That&#8217;s it! I hope this will help to get you started! Have fun hacking!</p>\n"},{"title":"Socket.IO  —  Chat","type":"demos","_content":"\n<p><a href=\"https://socket-io-chat.now.sh/\" style=\"text-decoration: none; display: inline-block; background: #000; color: #fff; font-size: 12px; font-weight: bold; color: #fff; padding: 3px 10px; \">https://socket-io-chat.now.sh/</a><a href=\"https://github.com/socketio/socket.io/tree/master/examples/chat\" style=\" float: right; font-size: 12px; \">View source code</a></p>\n\n<iframe src=\"https://socket-io-chat.now.sh/\" width=\"100%\" height=\"480\" scrolling=\"no\" class=\"iframe-class\" frameborder=\"0\"></iframe>\n","source":"demos/chat.md","raw":"title: Socket.IO  —  Chat\npermalink: /demos/chat/\ntype: demos\n---\n\n<p><a href=\"https://socket-io-chat.now.sh/\" style=\"text-decoration: none; display: inline-block; background: #000; color: #fff; font-size: 12px; font-weight: bold; color: #fff; padding: 3px 10px; \">https://socket-io-chat.now.sh/</a><a href=\"https://github.com/socketio/socket.io/tree/master/examples/chat\" style=\" float: right; font-size: 12px; \">View source code</a></p>\n\n<iframe src=\"https://socket-io-chat.now.sh/\" width=\"100%\" height=\"480\" scrolling=\"no\" class=\"iframe-class\" frameborder=\"0\"></iframe>\n","date":"2018-07-17T21:45:33.665Z","updated":"2018-07-17T21:45:33.665Z","path":"/demos/chat/index.html","comments":1,"layout":"page","_id":"cjjxdyeb80002jgcxpfapmjj5","content":"<p><a href=\"https://socket-io-chat.now.sh/\" style=\"text-decoration: none; display: inline-block; background: #000; color: #fff; font-size: 12px; font-weight: bold; color: #fff; padding: 3px 10px; \" target=\"_blank\" rel=\"noopener\">https://socket-io-chat.now.sh/</a><a href=\"https://github.com/socketio/socket.io/tree/master/examples/chat\" style=\" float: right; font-size: 12px; \" target=\"_blank\" rel=\"noopener\">View source code</a></p>\n\n<iframe src=\"https://socket-io-chat.now.sh/\" width=\"100%\" height=\"480\" scrolling=\"no\" class=\"iframe-class\" frameborder=\"0\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://socket-io-chat.now.sh/\" style=\"text-decoration: none; display: inline-block; background: #000; color: #fff; font-size: 12px; font-weight: bold; color: #fff; padding: 3px 10px; \" target=\"_blank\" rel=\"noopener\">https://socket-io-chat.now.sh/</a><a href=\"https://github.com/socketio/socket.io/tree/master/examples/chat\" style=\" float: right; font-size: 12px; \" target=\"_blank\" rel=\"noopener\">View source code</a></p>\n\n<iframe src=\"https://socket-io-chat.now.sh/\" width=\"100%\" height=\"480\" scrolling=\"no\" class=\"iframe-class\" frameborder=\"0\"></iframe>\n"},{"title":"Socket.IO  —  Whiteboard","type":"demos","_content":"\n<p><a href=\"https://socket-io-whiteboard.now.sh/\" style=\"text-decoration: none; display: inline-block; background: #000; color: #fff; font-size: 12px; font-weight: bold; color: #fff; padding: 3px 10px; \">https://socket-io-whiteboard.now.sh/</a><a href=\"https://github.com/socketio/socket.io/tree/master/examples/whiteboard\" style=\" float: right; font-size: 12px; \">View source code</a></p>\n\n<!-- iframe plugin v.2.8 wordpress.org/plugins/iframe/ -->\n<iframe src=\"https://socket-io-whiteboard.now.sh/\" width=\"100%\" height=\"480\" scrolling=\"no\" class=\"iframe-class\" frameborder=\"0\"></iframe>","source":"demos/whiteboard.md","raw":"title: Socket.IO  —  Whiteboard\npermalink: /demos/whiteboard/\ntype: demos\n---\n\n<p><a href=\"https://socket-io-whiteboard.now.sh/\" style=\"text-decoration: none; display: inline-block; background: #000; color: #fff; font-size: 12px; font-weight: bold; color: #fff; padding: 3px 10px; \">https://socket-io-whiteboard.now.sh/</a><a href=\"https://github.com/socketio/socket.io/tree/master/examples/whiteboard\" style=\" float: right; font-size: 12px; \">View source code</a></p>\n\n<!-- iframe plugin v.2.8 wordpress.org/plugins/iframe/ -->\n<iframe src=\"https://socket-io-whiteboard.now.sh/\" width=\"100%\" height=\"480\" scrolling=\"no\" class=\"iframe-class\" frameborder=\"0\"></iframe>","date":"2018-07-17T21:48:16.793Z","updated":"2018-07-17T21:48:16.793Z","path":"/demos/whiteboard/index.html","comments":1,"layout":"page","_id":"cjjxdyeb90003jgcxqvy0epqf","content":"<p><a href=\"https://socket-io-whiteboard.now.sh/\" style=\"text-decoration: none; display: inline-block; background: #000; color: #fff; font-size: 12px; font-weight: bold; color: #fff; padding: 3px 10px; \" target=\"_blank\" rel=\"noopener\">https://socket-io-whiteboard.now.sh/</a><a href=\"https://github.com/socketio/socket.io/tree/master/examples/whiteboard\" style=\" float: right; font-size: 12px; \" target=\"_blank\" rel=\"noopener\">View source code</a></p>\n\n<!-- iframe plugin v.2.8 wordpress.org/plugins/iframe/ -->\n<iframe src=\"https://socket-io-whiteboard.now.sh/\" width=\"100%\" height=\"480\" scrolling=\"no\" class=\"iframe-class\" frameborder=\"0\"></iframe>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://socket-io-whiteboard.now.sh/\" style=\"text-decoration: none; display: inline-block; background: #000; color: #fff; font-size: 12px; font-weight: bold; color: #fff; padding: 3px 10px; \" target=\"_blank\" rel=\"noopener\">https://socket-io-whiteboard.now.sh/</a><a href=\"https://github.com/socketio/socket.io/tree/master/examples/whiteboard\" style=\" float: right; font-size: 12px; \" target=\"_blank\" rel=\"noopener\">View source code</a></p>\n\n<!-- iframe plugin v.2.8 wordpress.org/plugins/iframe/ -->\n<iframe src=\"https://socket-io-whiteboard.now.sh/\" width=\"100%\" height=\"480\" scrolling=\"no\" class=\"iframe-class\" frameborder=\"0\"></iframe>"},{"title":"Socket.IO  —  Client API","type":"api","_content":"\n# IO\n\nExposed as the `io` namespace in the standalone build, or the result of calling `require('socket.io-client')`.\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  const socket = io('http://localhost');\n</script>\n```\n\n```js\nconst io = require('socket.io-client');\n// or with import syntax\nimport io from 'socket.io-client';\n```\n\n## io.protocol\n\n  * _(Number)_\n\nThe protocol revision number.\n\n## io([url][, options])\n\n  - `url` _(String)_ (defaults to `window.location`)\n  - `options` _(Object)_\n    - `forceNew` _(Boolean)_ whether to reuse an existing connection\n  - **Returns** `Socket`\n\nCreates a new `Manager` for the given URL, and attempts to reuse an existing `Manager` for subsequent calls, unless the `multiplex` option is passed with `false`. Passing this option is the equivalent of passing `'force new connection': true` or `forceNew: true`.\n\nA new `Socket` instance is returned for the namespace specified by the pathname in the URL, defaulting to `/`. For example, if the `url` is `http://localhost/users`, a transport connection will be established to `http://localhost` and a Socket.IO connection will be established to `/users`.\n\nQuery parameters can also be provided, either with the `query` option or directly in the url (example: `http://localhost/users?token=abc`).\n\nSee [new Manager(url[, options])](#new-managerurl-options) for available `options`.\n\n## Initialization examples\n\n### With multiplexing\n\nBy default, a single connection is used when connecting to different namespaces (to minimize resources):\n\n```js\nconst socket = io();\nconst adminSocket = io('/admin');\n// a single connection will be established\n```\n\nThat behaviour can be disabled with the `forceNew` option:\n\n```js\nconst socket = io();\nconst adminSocket = io('/admin', { forceNew: true });\n// will create two distinct connections\n```\n\nNote: reusing the same namespace will also create two connections\n\n```js\nconst socket = io();\nconst socket2 = io();\n// will also create two distinct connections\n```\n\n### With custom `path`\n\n```js\nconst socket = io('http://localhost', {\n  path: '/myownpath'\n});\n\n// server-side\nconst io = require('socket.io')({\n  path: '/myownpath'\n});\n```\n\nThe request URLs will look like: `localhost/myownpath/?EIO=3&transport=polling&sid=<id>`\n\n```js\nconst socket = io('http://localhost/admin', {\n  path: '/mypath'\n});\n```\n\nHere, the socket connects to the `admin` namespace, with the custom path `mypath`.\n\nThe request URLs will look like: `localhost/mypath/?EIO=3&transport=polling&sid=<id>` (the namespace is sent as part of the payload).\n\n### With query parameters\n\n```js\nconst socket = io('http://localhost?token=abc');\n\n// server-side\nconst io = require('socket.io')();\n\n// middleware\nio.use((socket, next) => {\n  let token = socket.handshake.query.token;\n  if (isValid(token)) {\n    return next();\n  }\n  return next(new Error('authentication error'));\n});\n\n// then\nio.on('connection', (socket) => {\n  let token = socket.handshake.query.token;\n  // ...\n});\n```\n\n### With query option\n\n```js\nconst socket = io({\n  query: {\n    token: 'cde'\n  }\n});\n```\n\nThe query content can also be updated on reconnection:\n\n```js\nsocket.on('reconnect_attempt', () => {\n  socket.io.opts.query = {\n    token: 'fgh'\n  }\n});\n```\n\n### With `extraHeaders`\n\nThis only works if `polling` transport is enabled (which is the default). Custom headers will not be appended when using `websocket` as the transport. This happens because the WebSocket handshake does not honor custom headers. (For background see the [WebSocket protocol RFC](https://tools.ietf.org/html/rfc6455#section-4))\n\n```js\nconst socket = io({\n  transportOptions: {\n    polling: {\n      extraHeaders: {\n        'x-clientid': 'abc'\n      }\n    }\n  }\n});\n\n// server-side\nconst io = require('socket.io')();\n\n// middleware\nio.use((socket, next) => {\n  let clientId = socket.handshake.headers['x-clientid'];\n  if (isValid(clientId)) {\n    return next();\n  }\n  return next(new Error('authentication error'));\n});\n```\n\n### With `websocket` transport only\n\nBy default, a long-polling connection is established first, then upgraded to \"better\" transports (like WebSocket). If you like to live dangerously, this part can be skipped:\n\n```js\nconst socket = io({\n  transports: ['websocket']\n});\n\n// on reconnection, reset the transports option, as the Websocket\n// connection may have failed (caused by proxy, firewall, browser, ...)\nsocket.on('reconnect_attempt', () => {\n  socket.io.opts.transports = ['polling', 'websocket'];\n});\n```\n\n### With a custom parser\n\nThe default [parser](https://github.com/socketio/socket.io-parser) promotes compatibility (support for `Blob`, `File`, binary check) at the expense of performance. A custom parser can be provided to match the needs of your application. Please see the example [here](https://github.com/socketio/socket.io/tree/master/examples/custom-parsers).\n\n```js\nconst parser = require('socket.io-msgpack-parser'); // or require('socket.io-json-parser')\nconst socket = io({\n  parser: parser\n});\n\n// the server-side must have the same parser, to be able to communicate\nconst io = require('socket.io')({\n  parser: parser\n});\n```\n\n# Manager\n\n## new Manager(url[, options])\n\n  - `url` _(String)_\n  - `options` _(Object)_\n    - `path` _(String)_ name of the path that is captured on the server side (`/socket.io`)\n    - `reconnection` _(Boolean)_ whether to reconnect automatically (`true`)\n    - `reconnectionAttempts` _(Number)_ number of reconnection attempts before giving up (`Infinity`)\n    - `reconnectionDelay` _(Number)_ how long to initially wait before attempting a new\n      reconnection (`1000`). Affected by +/- `randomizationFactor`,\n      for example the default initial delay will be between 500 to 1500ms.\n    - `reconnectionDelayMax` _(Number)_ maximum amount of time to wait between\n      reconnections (`5000`). Each attempt increases the reconnection delay by 2x\n      along with a randomization as above\n    - `randomizationFactor` _(Number)_ (`0.5`), 0 <= randomizationFactor <= 1\n    - `timeout` _(Number)_ connection timeout before a `connect_error`\n      and `connect_timeout` events are emitted (`20000`)\n    - `autoConnect` _(Boolean)_ by setting this false, you have to call `manager.open`\n      whenever you decide it's appropriate\n    - `query` _(Object)_: additional query parameters that are sent when connecting a namespace (then found in `socket.handshake.query` object on the server-side)\n    - `parser` _(Parser)_: the parser to use. Defaults to an instance of the `Parser` that ships with socket.io. See [socket.io-parser](https://github.com/socketio/socket.io-parser).\n  - **Returns** `Manager`\n\nThe `options` are also passed to `engine.io-client` upon initialization of the underlying `Socket`. See the available `options` [here](https://github.com/socketio/engine.io-client#methods).\n\n## manager.reconnection([value])\n\n  - `value` _(Boolean)_\n  - **Returns** `Manager|Boolean`\n\nSets the `reconnection` option, or returns it if no parameters are passed.\n\n## manager.reconnectionAttempts([value])\n\n  - `value` _(Number)_\n  - **Returns** `Manager|Number`\n\nSets the `reconnectionAttempts` option, or returns it if no parameters are passed.\n\n## manager.reconnectionDelay([value])\n\n  - `value` _(Number)_\n  - **Returns** `Manager|Number`\n\nSets the `reconnectionDelay` option, or returns it if no parameters are passed.\n\n## manager.reconnectionDelayMax([value])\n\n  - `value` _(Number)_\n  - **Returns** `Manager|Number`\n\nSets the `reconnectionDelayMax` option, or returns it if no parameters are passed.\n\n## manager.timeout([value])\n\n  - `value` _(Number)_\n  - **Returns** `Manager|Number`\n\nSets the `timeout` option, or returns it if no parameters are passed.\n\n## manager.open([callback])\n\n  - `callback` _(Function)_\n  - **Returns** `Manager`\n\nIf the manager was initiated with `autoConnect` to `false`, launch a new connection attempt.\n\nThe `callback` argument is optional and will be called once the attempt fails/succeeds.\n\n## manager.connect([callback])\n\nSynonym of [manager.open([callback])](#manageropencallback).\n\n## manager.socket(nsp, options)\n\n  - `nsp` _(String)_\n  - `options` _(Object)_\n  - **Returns** `Socket`\n\nCreates a new `Socket` for the given namespace.\n\n## Event: 'connect_error'\n\n  - `error` _(Object)_ error object\n\nFired upon a connection error.\n\n## Event: 'connect_timeout'\n\nFired upon a connection timeout.\n\n## Event: 'reconnect'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon a successful reconnection.\n\n## Event: 'reconnect_attempt'\n\nFired upon an attempt to reconnect.\n\n## Event: 'reconnecting'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon a successful reconnection.\n\n## Event: 'reconnect_error'\n\n  - `error` _(Object)_ error object\n\nFired upon a reconnection attempt error.\n\n## Event: 'reconnect_failed'\n\nFired when couldn't reconnect within `reconnectionAttempts`.\n\n## Event: 'ping'\n\nFired when a ping packet is written out to the server.\n\n## Event: 'pong'\n\n  - `ms` _(Number)_ number of ms elapsed since `ping` packet (i.e.: latency).\n\nFired when a pong is received from the server.\n\n# Socket\n\n## socket.id\n\n  - _(String)_\n\nAn unique identifier for the socket session. Set after the `connect` event is triggered, and updated after the `reconnect` event.\n\n```js\nconst socket = io('http://localhost');\n\nconsole.log(socket.id); // undefined\n\nsocket.on('connect', () => {\n  console.log(socket.id); // 'G5p5...'\n});\n```\n\n## socket.connected\n\n  - _(Boolean)_\n\nWhether or not the socket is connected to the server.\n\n```js\nconst socket = io('http://localhost');\n\nsocket.on('connect', () => {\n  console.log(socket.connected); // true\n});\n```\n\n## socket.disconnected\n\n  - _(Boolean)_\n\nWhether or not the socket is disconnected from the server.\n\n```js\nconst socket = io('http://localhost');\n\nsocket.on('connect', () => {\n  console.log(socket.disconnected); // false\n});\n```\n\n## socket.open()\n\n  - **Returns** `Socket`\n\nManually opens the socket.\n\n```js\nconst socket = io({\n  autoConnect: false\n});\n\n// ...\nsocket.open();\n```\n\nIt can also be used to manually reconnect:\n\n```js\nsocket.on('disconnect', () => {\n  socket.open();\n});\n```\n\n## socket.connect()\n\nSynonym of [socket.open()](#socketopen).\n\n## socket.send([...args][, ack])\n\n  - `args`\n  - `ack` _(Function)_\n  - **Returns** `Socket`\n\nSends a `message` event. See [socket.emit(eventName[, ...args][, ack])](#socketemiteventname-args-ack).\n\n## socket.emit(eventName[, ...args][, ack])\n\n  - `eventName` _(String)_\n  - `args`\n  - `ack` _(Function)_\n  - **Returns** `Socket`\n\nEmits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including `Buffer`.\n\n```js\nsocket.emit('hello', 'world');\nsocket.emit('with-binary', 1, '2', { 3: '4', 5: new Buffer(6) });\n```\n\nThe `ack` argument is optional and will be called with the server answer.\n\n```js\nsocket.emit('ferret', 'tobi', (data) => {\n  console.log(data); // data will be 'woot'\n});\n\n// server:\n//  io.on('connection', (socket) => {\n//    socket.on('ferret', (name, fn) => {\n//      fn('woot');\n//    });\n//  });\n```\n\n## socket.on(eventName, callback)\n\n  - `eventName` _(String)_\n  - `callback` _(Function)_\n  - **Returns** `Socket`\n\nRegister a new handler for the given event.\n\n```js\nsocket.on('news', (data) => {\n  console.log(data);\n});\n\n// with multiple arguments\nsocket.on('news', (arg1, arg2, arg3, arg4) => {\n  // ...\n});\n// with callback\nsocket.on('news', (cb) => {\n  cb(0);\n});\n```\n\nThe socket actually inherits every method of the [Emitter](https://github.com/component/emitter) class, like `hasListeners`, `once` or `off` (to remove an event listener).\n\n## socket.compress(value)\n\n  - `value` _(Boolean)_\n  - **Returns** `Socket`\n\nSets a modifier for a subsequent event emission that the event data will only be _compressed_ if the value is `true`. Defaults to `true` when you don't call the method.\n\n```js\nsocket.compress(false).emit('an event', { some: 'data' });\n```\n\n## socket.binary(value)\n\nSpecifies whether the emitted data contains binary. Increases performance when specified. Can be `true` or `false`.\n\n```js\nsocket.binary(false).emit('an event', { some: 'data' });\n```\n\n## socket.close()\n\n  - **Returns** `Socket`\n\nDisconnects the socket manually.\n\n## socket.disconnect()\n\nSynonym of [socket.close()](#socketclose).\n\n## Event: 'connect'\n\nFired upon a connection including a successful reconnection.\n\n```js\nsocket.on('connect', () => {\n  // ...\n});\n\n// note: you should register event handlers outside of connect,\n// so they are not registered again on reconnection\nsocket.on('myevent', () => {\n  // ...\n});\n```\n\n## Event: 'connect_error'\n\n  - `error` _(Object)_ error object\n\nFired upon a connection error.\n\n```js\nsocket.on('connect_error', (error) => {\n  // ...\n});\n```\n\n## Event: 'connect_timeout'\n\nFired upon a connection timeout.\n\n```js\nsocket.on('connect_timeout', (timeout) => {\n  // ...\n});\n```\n\n## Event: 'error'\n\n  - `error` _(Object)_ error object\n\nFired when an error occurs.\n\n```js\nsocket.on('error', (error) => {\n  // ...\n});\n```\n\n## Event: 'disconnect'\n\n  - `reason` _(String)_ either 'io server disconnect' or 'io client disconnect'\n\nFired upon a disconnection.\n\n```js\nsocket.on('disconnect', (reason) => {\n  if (reason === 'io server disconnect') {\n    // the disconnection was initiated by the server, you need to reconnect manually\n    socket.connect();\n  }\n  // else the socket will automatically try to reconnect\n});\n```\n\n## Event: 'reconnect'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon a successful reconnection.\n\n```js\nsocket.on('reconnect', (attemptNumber) => {\n  // ...\n});\n```\n\n## Event: 'reconnect_attempt'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon an attempt to reconnect.\n\n```js\nsocket.on('reconnect_attempt', (attemptNumber) => {\n  // ...\n});\n```\n\n## Event: 'reconnecting'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon an attempt to reconnect.\n\n```js\nsocket.on('reconnecting', (attemptNumber) => {\n  // ...\n});\n```\n\n## Event: 'reconnect_error'\n\n  - `error` _(Object)_ error object\n\nFired upon a reconnection attempt error.\n\n```js\nsocket.on('reconnect_error', (error) => {\n  // ...\n});\n```\n\n## Event: 'reconnect_failed'\n\nFired when couldn't reconnect within `reconnectionAttempts`.\n\n```js\nsocket.on('reconnect_failed', () => {\n  // ...\n});\n```\n\n## Event: 'ping'\n\nFired when a ping packet is written out to the server.\n\n```js\nsocket.on('ping', () => {\n  // ...\n});\n```\n\n## Event: 'pong'\n\n  - `ms` _(Number)_ number of ms elapsed since `ping` packet (i.e.: latency).\n\nFired when a pong is received from the server.\n\n```js\nsocket.on('pong', (latency) => {\n  // ...\n});\n```\n","source":"docs/client-api.md","raw":"title: Socket.IO  —  Client API\npermalink: /docs/client-api/\ntype: api\n---\n\n# IO\n\nExposed as the `io` namespace in the standalone build, or the result of calling `require('socket.io-client')`.\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  const socket = io('http://localhost');\n</script>\n```\n\n```js\nconst io = require('socket.io-client');\n// or with import syntax\nimport io from 'socket.io-client';\n```\n\n## io.protocol\n\n  * _(Number)_\n\nThe protocol revision number.\n\n## io([url][, options])\n\n  - `url` _(String)_ (defaults to `window.location`)\n  - `options` _(Object)_\n    - `forceNew` _(Boolean)_ whether to reuse an existing connection\n  - **Returns** `Socket`\n\nCreates a new `Manager` for the given URL, and attempts to reuse an existing `Manager` for subsequent calls, unless the `multiplex` option is passed with `false`. Passing this option is the equivalent of passing `'force new connection': true` or `forceNew: true`.\n\nA new `Socket` instance is returned for the namespace specified by the pathname in the URL, defaulting to `/`. For example, if the `url` is `http://localhost/users`, a transport connection will be established to `http://localhost` and a Socket.IO connection will be established to `/users`.\n\nQuery parameters can also be provided, either with the `query` option or directly in the url (example: `http://localhost/users?token=abc`).\n\nSee [new Manager(url[, options])](#new-managerurl-options) for available `options`.\n\n## Initialization examples\n\n### With multiplexing\n\nBy default, a single connection is used when connecting to different namespaces (to minimize resources):\n\n```js\nconst socket = io();\nconst adminSocket = io('/admin');\n// a single connection will be established\n```\n\nThat behaviour can be disabled with the `forceNew` option:\n\n```js\nconst socket = io();\nconst adminSocket = io('/admin', { forceNew: true });\n// will create two distinct connections\n```\n\nNote: reusing the same namespace will also create two connections\n\n```js\nconst socket = io();\nconst socket2 = io();\n// will also create two distinct connections\n```\n\n### With custom `path`\n\n```js\nconst socket = io('http://localhost', {\n  path: '/myownpath'\n});\n\n// server-side\nconst io = require('socket.io')({\n  path: '/myownpath'\n});\n```\n\nThe request URLs will look like: `localhost/myownpath/?EIO=3&transport=polling&sid=<id>`\n\n```js\nconst socket = io('http://localhost/admin', {\n  path: '/mypath'\n});\n```\n\nHere, the socket connects to the `admin` namespace, with the custom path `mypath`.\n\nThe request URLs will look like: `localhost/mypath/?EIO=3&transport=polling&sid=<id>` (the namespace is sent as part of the payload).\n\n### With query parameters\n\n```js\nconst socket = io('http://localhost?token=abc');\n\n// server-side\nconst io = require('socket.io')();\n\n// middleware\nio.use((socket, next) => {\n  let token = socket.handshake.query.token;\n  if (isValid(token)) {\n    return next();\n  }\n  return next(new Error('authentication error'));\n});\n\n// then\nio.on('connection', (socket) => {\n  let token = socket.handshake.query.token;\n  // ...\n});\n```\n\n### With query option\n\n```js\nconst socket = io({\n  query: {\n    token: 'cde'\n  }\n});\n```\n\nThe query content can also be updated on reconnection:\n\n```js\nsocket.on('reconnect_attempt', () => {\n  socket.io.opts.query = {\n    token: 'fgh'\n  }\n});\n```\n\n### With `extraHeaders`\n\nThis only works if `polling` transport is enabled (which is the default). Custom headers will not be appended when using `websocket` as the transport. This happens because the WebSocket handshake does not honor custom headers. (For background see the [WebSocket protocol RFC](https://tools.ietf.org/html/rfc6455#section-4))\n\n```js\nconst socket = io({\n  transportOptions: {\n    polling: {\n      extraHeaders: {\n        'x-clientid': 'abc'\n      }\n    }\n  }\n});\n\n// server-side\nconst io = require('socket.io')();\n\n// middleware\nio.use((socket, next) => {\n  let clientId = socket.handshake.headers['x-clientid'];\n  if (isValid(clientId)) {\n    return next();\n  }\n  return next(new Error('authentication error'));\n});\n```\n\n### With `websocket` transport only\n\nBy default, a long-polling connection is established first, then upgraded to \"better\" transports (like WebSocket). If you like to live dangerously, this part can be skipped:\n\n```js\nconst socket = io({\n  transports: ['websocket']\n});\n\n// on reconnection, reset the transports option, as the Websocket\n// connection may have failed (caused by proxy, firewall, browser, ...)\nsocket.on('reconnect_attempt', () => {\n  socket.io.opts.transports = ['polling', 'websocket'];\n});\n```\n\n### With a custom parser\n\nThe default [parser](https://github.com/socketio/socket.io-parser) promotes compatibility (support for `Blob`, `File`, binary check) at the expense of performance. A custom parser can be provided to match the needs of your application. Please see the example [here](https://github.com/socketio/socket.io/tree/master/examples/custom-parsers).\n\n```js\nconst parser = require('socket.io-msgpack-parser'); // or require('socket.io-json-parser')\nconst socket = io({\n  parser: parser\n});\n\n// the server-side must have the same parser, to be able to communicate\nconst io = require('socket.io')({\n  parser: parser\n});\n```\n\n# Manager\n\n## new Manager(url[, options])\n\n  - `url` _(String)_\n  - `options` _(Object)_\n    - `path` _(String)_ name of the path that is captured on the server side (`/socket.io`)\n    - `reconnection` _(Boolean)_ whether to reconnect automatically (`true`)\n    - `reconnectionAttempts` _(Number)_ number of reconnection attempts before giving up (`Infinity`)\n    - `reconnectionDelay` _(Number)_ how long to initially wait before attempting a new\n      reconnection (`1000`). Affected by +/- `randomizationFactor`,\n      for example the default initial delay will be between 500 to 1500ms.\n    - `reconnectionDelayMax` _(Number)_ maximum amount of time to wait between\n      reconnections (`5000`). Each attempt increases the reconnection delay by 2x\n      along with a randomization as above\n    - `randomizationFactor` _(Number)_ (`0.5`), 0 <= randomizationFactor <= 1\n    - `timeout` _(Number)_ connection timeout before a `connect_error`\n      and `connect_timeout` events are emitted (`20000`)\n    - `autoConnect` _(Boolean)_ by setting this false, you have to call `manager.open`\n      whenever you decide it's appropriate\n    - `query` _(Object)_: additional query parameters that are sent when connecting a namespace (then found in `socket.handshake.query` object on the server-side)\n    - `parser` _(Parser)_: the parser to use. Defaults to an instance of the `Parser` that ships with socket.io. See [socket.io-parser](https://github.com/socketio/socket.io-parser).\n  - **Returns** `Manager`\n\nThe `options` are also passed to `engine.io-client` upon initialization of the underlying `Socket`. See the available `options` [here](https://github.com/socketio/engine.io-client#methods).\n\n## manager.reconnection([value])\n\n  - `value` _(Boolean)_\n  - **Returns** `Manager|Boolean`\n\nSets the `reconnection` option, or returns it if no parameters are passed.\n\n## manager.reconnectionAttempts([value])\n\n  - `value` _(Number)_\n  - **Returns** `Manager|Number`\n\nSets the `reconnectionAttempts` option, or returns it if no parameters are passed.\n\n## manager.reconnectionDelay([value])\n\n  - `value` _(Number)_\n  - **Returns** `Manager|Number`\n\nSets the `reconnectionDelay` option, or returns it if no parameters are passed.\n\n## manager.reconnectionDelayMax([value])\n\n  - `value` _(Number)_\n  - **Returns** `Manager|Number`\n\nSets the `reconnectionDelayMax` option, or returns it if no parameters are passed.\n\n## manager.timeout([value])\n\n  - `value` _(Number)_\n  - **Returns** `Manager|Number`\n\nSets the `timeout` option, or returns it if no parameters are passed.\n\n## manager.open([callback])\n\n  - `callback` _(Function)_\n  - **Returns** `Manager`\n\nIf the manager was initiated with `autoConnect` to `false`, launch a new connection attempt.\n\nThe `callback` argument is optional and will be called once the attempt fails/succeeds.\n\n## manager.connect([callback])\n\nSynonym of [manager.open([callback])](#manageropencallback).\n\n## manager.socket(nsp, options)\n\n  - `nsp` _(String)_\n  - `options` _(Object)_\n  - **Returns** `Socket`\n\nCreates a new `Socket` for the given namespace.\n\n## Event: 'connect_error'\n\n  - `error` _(Object)_ error object\n\nFired upon a connection error.\n\n## Event: 'connect_timeout'\n\nFired upon a connection timeout.\n\n## Event: 'reconnect'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon a successful reconnection.\n\n## Event: 'reconnect_attempt'\n\nFired upon an attempt to reconnect.\n\n## Event: 'reconnecting'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon a successful reconnection.\n\n## Event: 'reconnect_error'\n\n  - `error` _(Object)_ error object\n\nFired upon a reconnection attempt error.\n\n## Event: 'reconnect_failed'\n\nFired when couldn't reconnect within `reconnectionAttempts`.\n\n## Event: 'ping'\n\nFired when a ping packet is written out to the server.\n\n## Event: 'pong'\n\n  - `ms` _(Number)_ number of ms elapsed since `ping` packet (i.e.: latency).\n\nFired when a pong is received from the server.\n\n# Socket\n\n## socket.id\n\n  - _(String)_\n\nAn unique identifier for the socket session. Set after the `connect` event is triggered, and updated after the `reconnect` event.\n\n```js\nconst socket = io('http://localhost');\n\nconsole.log(socket.id); // undefined\n\nsocket.on('connect', () => {\n  console.log(socket.id); // 'G5p5...'\n});\n```\n\n## socket.connected\n\n  - _(Boolean)_\n\nWhether or not the socket is connected to the server.\n\n```js\nconst socket = io('http://localhost');\n\nsocket.on('connect', () => {\n  console.log(socket.connected); // true\n});\n```\n\n## socket.disconnected\n\n  - _(Boolean)_\n\nWhether or not the socket is disconnected from the server.\n\n```js\nconst socket = io('http://localhost');\n\nsocket.on('connect', () => {\n  console.log(socket.disconnected); // false\n});\n```\n\n## socket.open()\n\n  - **Returns** `Socket`\n\nManually opens the socket.\n\n```js\nconst socket = io({\n  autoConnect: false\n});\n\n// ...\nsocket.open();\n```\n\nIt can also be used to manually reconnect:\n\n```js\nsocket.on('disconnect', () => {\n  socket.open();\n});\n```\n\n## socket.connect()\n\nSynonym of [socket.open()](#socketopen).\n\n## socket.send([...args][, ack])\n\n  - `args`\n  - `ack` _(Function)_\n  - **Returns** `Socket`\n\nSends a `message` event. See [socket.emit(eventName[, ...args][, ack])](#socketemiteventname-args-ack).\n\n## socket.emit(eventName[, ...args][, ack])\n\n  - `eventName` _(String)_\n  - `args`\n  - `ack` _(Function)_\n  - **Returns** `Socket`\n\nEmits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including `Buffer`.\n\n```js\nsocket.emit('hello', 'world');\nsocket.emit('with-binary', 1, '2', { 3: '4', 5: new Buffer(6) });\n```\n\nThe `ack` argument is optional and will be called with the server answer.\n\n```js\nsocket.emit('ferret', 'tobi', (data) => {\n  console.log(data); // data will be 'woot'\n});\n\n// server:\n//  io.on('connection', (socket) => {\n//    socket.on('ferret', (name, fn) => {\n//      fn('woot');\n//    });\n//  });\n```\n\n## socket.on(eventName, callback)\n\n  - `eventName` _(String)_\n  - `callback` _(Function)_\n  - **Returns** `Socket`\n\nRegister a new handler for the given event.\n\n```js\nsocket.on('news', (data) => {\n  console.log(data);\n});\n\n// with multiple arguments\nsocket.on('news', (arg1, arg2, arg3, arg4) => {\n  // ...\n});\n// with callback\nsocket.on('news', (cb) => {\n  cb(0);\n});\n```\n\nThe socket actually inherits every method of the [Emitter](https://github.com/component/emitter) class, like `hasListeners`, `once` or `off` (to remove an event listener).\n\n## socket.compress(value)\n\n  - `value` _(Boolean)_\n  - **Returns** `Socket`\n\nSets a modifier for a subsequent event emission that the event data will only be _compressed_ if the value is `true`. Defaults to `true` when you don't call the method.\n\n```js\nsocket.compress(false).emit('an event', { some: 'data' });\n```\n\n## socket.binary(value)\n\nSpecifies whether the emitted data contains binary. Increases performance when specified. Can be `true` or `false`.\n\n```js\nsocket.binary(false).emit('an event', { some: 'data' });\n```\n\n## socket.close()\n\n  - **Returns** `Socket`\n\nDisconnects the socket manually.\n\n## socket.disconnect()\n\nSynonym of [socket.close()](#socketclose).\n\n## Event: 'connect'\n\nFired upon a connection including a successful reconnection.\n\n```js\nsocket.on('connect', () => {\n  // ...\n});\n\n// note: you should register event handlers outside of connect,\n// so they are not registered again on reconnection\nsocket.on('myevent', () => {\n  // ...\n});\n```\n\n## Event: 'connect_error'\n\n  - `error` _(Object)_ error object\n\nFired upon a connection error.\n\n```js\nsocket.on('connect_error', (error) => {\n  // ...\n});\n```\n\n## Event: 'connect_timeout'\n\nFired upon a connection timeout.\n\n```js\nsocket.on('connect_timeout', (timeout) => {\n  // ...\n});\n```\n\n## Event: 'error'\n\n  - `error` _(Object)_ error object\n\nFired when an error occurs.\n\n```js\nsocket.on('error', (error) => {\n  // ...\n});\n```\n\n## Event: 'disconnect'\n\n  - `reason` _(String)_ either 'io server disconnect' or 'io client disconnect'\n\nFired upon a disconnection.\n\n```js\nsocket.on('disconnect', (reason) => {\n  if (reason === 'io server disconnect') {\n    // the disconnection was initiated by the server, you need to reconnect manually\n    socket.connect();\n  }\n  // else the socket will automatically try to reconnect\n});\n```\n\n## Event: 'reconnect'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon a successful reconnection.\n\n```js\nsocket.on('reconnect', (attemptNumber) => {\n  // ...\n});\n```\n\n## Event: 'reconnect_attempt'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon an attempt to reconnect.\n\n```js\nsocket.on('reconnect_attempt', (attemptNumber) => {\n  // ...\n});\n```\n\n## Event: 'reconnecting'\n\n  - `attempt` _(Number)_ reconnection attempt number\n\nFired upon an attempt to reconnect.\n\n```js\nsocket.on('reconnecting', (attemptNumber) => {\n  // ...\n});\n```\n\n## Event: 'reconnect_error'\n\n  - `error` _(Object)_ error object\n\nFired upon a reconnection attempt error.\n\n```js\nsocket.on('reconnect_error', (error) => {\n  // ...\n});\n```\n\n## Event: 'reconnect_failed'\n\nFired when couldn't reconnect within `reconnectionAttempts`.\n\n```js\nsocket.on('reconnect_failed', () => {\n  // ...\n});\n```\n\n## Event: 'ping'\n\nFired when a ping packet is written out to the server.\n\n```js\nsocket.on('ping', () => {\n  // ...\n});\n```\n\n## Event: 'pong'\n\n  - `ms` _(Number)_ number of ms elapsed since `ping` packet (i.e.: latency).\n\nFired when a pong is received from the server.\n\n```js\nsocket.on('pong', (latency) => {\n  // ...\n});\n```\n","date":"2018-07-17T21:42:55.793Z","updated":"2018-07-17T21:42:55.793Z","path":"/docs/client-api/index.html","comments":1,"layout":"page","_id":"cjjxdyeba0004jgcxqaa2zido","content":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><p>Exposed as the <code>io</code> namespace in the standalone build, or the result of calling <code>require(&#39;socket.io-client&#39;)</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-client'</span>);</span><br><span class=\"line\"><span class=\"comment\">// or with import syntax</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> io <span class=\"keyword\">from</span> <span class=\"string\">'socket.io-client'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"io-protocol\"><a href=\"#io-protocol\" class=\"headerlink\" title=\"io.protocol\"></a>io.protocol</h2><ul>\n<li><em>(Number)</em></li>\n</ul>\n<p>The protocol revision number.</p>\n<h2 id=\"io-url-options\"><a href=\"#io-url-options\" class=\"headerlink\" title=\"io([url][, options])\"></a>io([url][, options])</h2><ul>\n<li><code>url</code> <em>(String)</em> (defaults to <code>window.location</code>)</li>\n<li><code>options</code> <em>(Object)</em><ul>\n<li><code>forceNew</code> <em>(Boolean)</em> whether to reuse an existing connection</li>\n</ul>\n</li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Creates a new <code>Manager</code> for the given URL, and attempts to reuse an existing <code>Manager</code> for subsequent calls, unless the <code>multiplex</code> option is passed with <code>false</code>. Passing this option is the equivalent of passing <code>&#39;force new connection&#39;: true</code> or <code>forceNew: true</code>.</p>\n<p>A new <code>Socket</code> instance is returned for the namespace specified by the pathname in the URL, defaulting to <code>/</code>. For example, if the <code>url</code> is <code>http://localhost/users</code>, a transport connection will be established to <code>http://localhost</code> and a Socket.IO connection will be established to <code>/users</code>.</p>\n<p>Query parameters can also be provided, either with the <code>query</code> option or directly in the url (example: <code>http://localhost/users?token=abc</code>).</p>\n<p>See <a href=\"#new-managerurl-options\">new Manager(url[, options])</a> for available <code>options</code>.</p>\n<h2 id=\"Initialization-examples\"><a href=\"#Initialization-examples\" class=\"headerlink\" title=\"Initialization examples\"></a>Initialization examples</h2><h3 id=\"With-multiplexing\"><a href=\"#With-multiplexing\" class=\"headerlink\" title=\"With multiplexing\"></a>With multiplexing</h3><p>By default, a single connection is used when connecting to different namespaces (to minimize resources):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io();</span><br><span class=\"line\"><span class=\"keyword\">const</span> adminSocket = io(<span class=\"string\">'/admin'</span>);</span><br><span class=\"line\"><span class=\"comment\">// a single connection will be established</span></span><br></pre></td></tr></table></figure>\n<p>That behaviour can be disabled with the <code>forceNew</code> option:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io();</span><br><span class=\"line\"><span class=\"keyword\">const</span> adminSocket = io(<span class=\"string\">'/admin'</span>, &#123; <span class=\"attr\">forceNew</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// will create two distinct connections</span></span><br></pre></td></tr></table></figure>\n<p>Note: reusing the same namespace will also create two connections</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io();</span><br><span class=\"line\"><span class=\"keyword\">const</span> socket2 = io();</span><br><span class=\"line\"><span class=\"comment\">// will also create two distinct connections</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"With-custom-path\"><a href=\"#With-custom-path\" class=\"headerlink\" title=\"With custom path\"></a>With custom <code>path</code></h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>, &#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/myownpath'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/myownpath'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The request URLs will look like: <code>localhost/myownpath/?EIO=3&amp;transport=polling&amp;sid=&lt;id&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost/admin'</span>, &#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/mypath'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Here, the socket connects to the <code>admin</code> namespace, with the custom path <code>mypath</code>.</p>\n<p>The request URLs will look like: <code>localhost/mypath/?EIO=3&amp;transport=polling&amp;sid=&lt;id&gt;</code> (the namespace is sent as part of the payload).</p>\n<h3 id=\"With-query-parameters\"><a href=\"#With-query-parameters\" class=\"headerlink\" title=\"With query parameters\"></a>With query parameters</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost?token=abc'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\">io.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> token = socket.handshake.query.token;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isValid(token)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'authentication error'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then</span></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> token = socket.handshake.query.token;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"With-query-option\"><a href=\"#With-query-option\" class=\"headerlink\" title=\"With query option\"></a>With query option</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    token: <span class=\"string\">'cde'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The query content can also be updated on reconnection:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect_attempt'</span>, () =&gt; &#123;</span><br><span class=\"line\">  socket.io.opts.query = &#123;</span><br><span class=\"line\">    token: <span class=\"string\">'fgh'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"With-extraHeaders\"><a href=\"#With-extraHeaders\" class=\"headerlink\" title=\"With extraHeaders\"></a>With <code>extraHeaders</code></h3><p>This only works if <code>polling</code> transport is enabled (which is the default). Custom headers will not be appended when using <code>websocket</code> as the transport. This happens because the WebSocket handshake does not honor custom headers. (For background see the <a href=\"https://tools.ietf.org/html/rfc6455#section-4\" target=\"_blank\" rel=\"noopener\">WebSocket protocol RFC</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  transportOptions: &#123;</span><br><span class=\"line\">    polling: &#123;</span><br><span class=\"line\">      extraHeaders: &#123;</span><br><span class=\"line\">        <span class=\"string\">'x-clientid'</span>: <span class=\"string\">'abc'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\">io.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> clientId = socket.handshake.headers[<span class=\"string\">'x-clientid'</span>];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isValid(clientId)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'authentication error'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"With-websocket-transport-only\"><a href=\"#With-websocket-transport-only\" class=\"headerlink\" title=\"With websocket transport only\"></a>With <code>websocket</code> transport only</h3><p>By default, a long-polling connection is established first, then upgraded to “better” transports (like WebSocket). If you like to live dangerously, this part can be skipped:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  transports: [<span class=\"string\">'websocket'</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// on reconnection, reset the transports option, as the Websocket</span></span><br><span class=\"line\"><span class=\"comment\">// connection may have failed (caused by proxy, firewall, browser, ...)</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'reconnect_attempt'</span>, () =&gt; &#123;</span><br><span class=\"line\">  socket.io.opts.transports = [<span class=\"string\">'polling'</span>, <span class=\"string\">'websocket'</span>];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"With-a-custom-parser\"><a href=\"#With-a-custom-parser\" class=\"headerlink\" title=\"With a custom parser\"></a>With a custom parser</h3><p>The default <a href=\"https://github.com/socketio/socket.io-parser\" target=\"_blank\" rel=\"noopener\">parser</a> promotes compatibility (support for <code>Blob</code>, <code>File</code>, binary check) at the expense of performance. A custom parser can be provided to match the needs of your application. Please see the example <a href=\"https://github.com/socketio/socket.io/tree/master/examples/custom-parsers\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parser = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-msgpack-parser'</span>); <span class=\"comment\">// or require('socket.io-json-parser')</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  parser: parser</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the server-side must have the same parser, to be able to communicate</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(&#123;</span><br><span class=\"line\">  parser: parser</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"Manager\"><a href=\"#Manager\" class=\"headerlink\" title=\"Manager\"></a>Manager</h1><h2 id=\"new-Manager-url-options\"><a href=\"#new-Manager-url-options\" class=\"headerlink\" title=\"new Manager(url[, options])\"></a>new Manager(url[, options])</h2><ul>\n<li><code>url</code> <em>(String)</em></li>\n<li><code>options</code> <em>(Object)</em><ul>\n<li><code>path</code> <em>(String)</em> name of the path that is captured on the server side (<code>/socket.io</code>)</li>\n<li><code>reconnection</code> <em>(Boolean)</em> whether to reconnect automatically (<code>true</code>)</li>\n<li><code>reconnectionAttempts</code> <em>(Number)</em> number of reconnection attempts before giving up (<code>Infinity</code>)</li>\n<li><code>reconnectionDelay</code> <em>(Number)</em> how long to initially wait before attempting a new<br>reconnection (<code>1000</code>). Affected by +/- <code>randomizationFactor</code>,<br>for example the default initial delay will be between 500 to 1500ms.</li>\n<li><code>reconnectionDelayMax</code> <em>(Number)</em> maximum amount of time to wait between<br>reconnections (<code>5000</code>). Each attempt increases the reconnection delay by 2x<br>along with a randomization as above</li>\n<li><code>randomizationFactor</code> <em>(Number)</em> (<code>0.5</code>), 0 &lt;= randomizationFactor &lt;= 1</li>\n<li><code>timeout</code> <em>(Number)</em> connection timeout before a <code>connect_error</code><br>and <code>connect_timeout</code> events are emitted (<code>20000</code>)</li>\n<li><code>autoConnect</code> <em>(Boolean)</em> by setting this false, you have to call <code>manager.open</code><br>whenever you decide it’s appropriate</li>\n<li><code>query</code> <em>(Object)</em>: additional query parameters that are sent when connecting a namespace (then found in <code>socket.handshake.query</code> object on the server-side)</li>\n<li><code>parser</code> <em>(Parser)</em>: the parser to use. Defaults to an instance of the <code>Parser</code> that ships with socket.io. See <a href=\"https://github.com/socketio/socket.io-parser\" target=\"_blank\" rel=\"noopener\">socket.io-parser</a>.</li>\n</ul>\n</li>\n<li><strong>Returns</strong> <code>Manager</code></li>\n</ul>\n<p>The <code>options</code> are also passed to <code>engine.io-client</code> upon initialization of the underlying <code>Socket</code>. See the available <code>options</code> <a href=\"https://github.com/socketio/engine.io-client#methods\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<h2 id=\"manager-reconnection-value\"><a href=\"#manager-reconnection-value\" class=\"headerlink\" title=\"manager.reconnection([value])\"></a>manager.reconnection([value])</h2><ul>\n<li><code>value</code> <em>(Boolean)</em></li>\n<li><strong>Returns</strong> <code>Manager|Boolean</code></li>\n</ul>\n<p>Sets the <code>reconnection</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-reconnectionAttempts-value\"><a href=\"#manager-reconnectionAttempts-value\" class=\"headerlink\" title=\"manager.reconnectionAttempts([value])\"></a>manager.reconnectionAttempts([value])</h2><ul>\n<li><code>value</code> <em>(Number)</em></li>\n<li><strong>Returns</strong> <code>Manager|Number</code></li>\n</ul>\n<p>Sets the <code>reconnectionAttempts</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-reconnectionDelay-value\"><a href=\"#manager-reconnectionDelay-value\" class=\"headerlink\" title=\"manager.reconnectionDelay([value])\"></a>manager.reconnectionDelay([value])</h2><ul>\n<li><code>value</code> <em>(Number)</em></li>\n<li><strong>Returns</strong> <code>Manager|Number</code></li>\n</ul>\n<p>Sets the <code>reconnectionDelay</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-reconnectionDelayMax-value\"><a href=\"#manager-reconnectionDelayMax-value\" class=\"headerlink\" title=\"manager.reconnectionDelayMax([value])\"></a>manager.reconnectionDelayMax([value])</h2><ul>\n<li><code>value</code> <em>(Number)</em></li>\n<li><strong>Returns</strong> <code>Manager|Number</code></li>\n</ul>\n<p>Sets the <code>reconnectionDelayMax</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-timeout-value\"><a href=\"#manager-timeout-value\" class=\"headerlink\" title=\"manager.timeout([value])\"></a>manager.timeout([value])</h2><ul>\n<li><code>value</code> <em>(Number)</em></li>\n<li><strong>Returns</strong> <code>Manager|Number</code></li>\n</ul>\n<p>Sets the <code>timeout</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-open-callback\"><a href=\"#manager-open-callback\" class=\"headerlink\" title=\"manager.open([callback])\"></a>manager.open([callback])</h2><ul>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Manager</code></li>\n</ul>\n<p>If the manager was initiated with <code>autoConnect</code> to <code>false</code>, launch a new connection attempt.</p>\n<p>The <code>callback</code> argument is optional and will be called once the attempt fails/succeeds.</p>\n<h2 id=\"manager-connect-callback\"><a href=\"#manager-connect-callback\" class=\"headerlink\" title=\"manager.connect([callback])\"></a>manager.connect([callback])</h2><p>Synonym of <a href=\"#manageropencallback\">manager.open([callback])</a>.</p>\n<h2 id=\"manager-socket-nsp-options\"><a href=\"#manager-socket-nsp-options\" class=\"headerlink\" title=\"manager.socket(nsp, options)\"></a>manager.socket(nsp, options)</h2><ul>\n<li><code>nsp</code> <em>(String)</em></li>\n<li><code>options</code> <em>(Object)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Creates a new <code>Socket</code> for the given namespace.</p>\n<h2 id=\"Event-‘connect-error’\"><a href=\"#Event-‘connect-error’\" class=\"headerlink\" title=\"Event: ‘connect_error’\"></a>Event: ‘connect_error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired upon a connection error.</p>\n<h2 id=\"Event-‘connect-timeout’\"><a href=\"#Event-‘connect-timeout’\" class=\"headerlink\" title=\"Event: ‘connect_timeout’\"></a>Event: ‘connect_timeout’</h2><p>Fired upon a connection timeout.</p>\n<h2 id=\"Event-‘reconnect’\"><a href=\"#Event-‘reconnect’\" class=\"headerlink\" title=\"Event: ‘reconnect’\"></a>Event: ‘reconnect’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon a successful reconnection.</p>\n<h2 id=\"Event-‘reconnect-attempt’\"><a href=\"#Event-‘reconnect-attempt’\" class=\"headerlink\" title=\"Event: ‘reconnect_attempt’\"></a>Event: ‘reconnect_attempt’</h2><p>Fired upon an attempt to reconnect.</p>\n<h2 id=\"Event-‘reconnecting’\"><a href=\"#Event-‘reconnecting’\" class=\"headerlink\" title=\"Event: ‘reconnecting’\"></a>Event: ‘reconnecting’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon a successful reconnection.</p>\n<h2 id=\"Event-‘reconnect-error’\"><a href=\"#Event-‘reconnect-error’\" class=\"headerlink\" title=\"Event: ‘reconnect_error’\"></a>Event: ‘reconnect_error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired upon a reconnection attempt error.</p>\n<h2 id=\"Event-‘reconnect-failed’\"><a href=\"#Event-‘reconnect-failed’\" class=\"headerlink\" title=\"Event: ‘reconnect_failed’\"></a>Event: ‘reconnect_failed’</h2><p>Fired when couldn’t reconnect within <code>reconnectionAttempts</code>.</p>\n<h2 id=\"Event-‘ping’\"><a href=\"#Event-‘ping’\" class=\"headerlink\" title=\"Event: ‘ping’\"></a>Event: ‘ping’</h2><p>Fired when a ping packet is written out to the server.</p>\n<h2 id=\"Event-‘pong’\"><a href=\"#Event-‘pong’\" class=\"headerlink\" title=\"Event: ‘pong’\"></a>Event: ‘pong’</h2><ul>\n<li><code>ms</code> <em>(Number)</em> number of ms elapsed since <code>ping</code> packet (i.e.: latency).</li>\n</ul>\n<p>Fired when a pong is received from the server.</p>\n<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1><h2 id=\"socket-id\"><a href=\"#socket-id\" class=\"headerlink\" title=\"socket.id\"></a>socket.id</h2><ul>\n<li><em>(String)</em></li>\n</ul>\n<p>An unique identifier for the socket session. Set after the <code>connect</code> event is triggered, and updated after the <code>reconnect</code> event.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(socket.id); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(socket.id); <span class=\"comment\">// 'G5p5...'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-connected\"><a href=\"#socket-connected\" class=\"headerlink\" title=\"socket.connected\"></a>socket.connected</h2><ul>\n<li><em>(Boolean)</em></li>\n</ul>\n<p>Whether or not the socket is connected to the server.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(socket.connected); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-disconnected\"><a href=\"#socket-disconnected\" class=\"headerlink\" title=\"socket.disconnected\"></a>socket.disconnected</h2><ul>\n<li><em>(Boolean)</em></li>\n</ul>\n<p>Whether or not the socket is disconnected from the server.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(socket.disconnected); <span class=\"comment\">// false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-open\"><a href=\"#socket-open\" class=\"headerlink\" title=\"socket.open()\"></a>socket.open()</h2><ul>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Manually opens the socket.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  autoConnect: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">socket.open();</span><br></pre></td></tr></table></figure>\n<p>It can also be used to manually reconnect:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'disconnect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  socket.open();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-connect\"><a href=\"#socket-connect\" class=\"headerlink\" title=\"socket.connect()\"></a>socket.connect()</h2><p>Synonym of <a href=\"#socketopen\">socket.open()</a>.</p>\n<h2 id=\"socket-send-…args-ack\"><a href=\"#socket-send-…args-ack\" class=\"headerlink\" title=\"socket.send([…args][, ack])\"></a>socket.send([…args][, ack])</h2><ul>\n<li><code>args</code></li>\n<li><code>ack</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Sends a <code>message</code> event. See <a href=\"#socketemiteventname-args-ack\">socket.emit(eventName[, …args][, ack])</a>.</p>\n<h2 id=\"socket-emit-eventName-…args-ack\"><a href=\"#socket-emit-eventName-…args-ack\" class=\"headerlink\" title=\"socket.emit(eventName[, …args][, ack])\"></a>socket.emit(eventName[, …args][, ack])</h2><ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>args</code></li>\n<li><code>ack</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including <code>Buffer</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.emit(<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>);</span><br><span class=\"line\">socket.emit(<span class=\"string\">'with-binary'</span>, <span class=\"number\">1</span>, <span class=\"string\">'2'</span>, &#123; <span class=\"number\">3</span>: <span class=\"string\">'4'</span>, <span class=\"number\">5</span>: <span class=\"keyword\">new</span> Buffer(<span class=\"number\">6</span>) &#125;);</span><br></pre></td></tr></table></figure>\n<p>The <code>ack</code> argument is optional and will be called with the server answer.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.emit(<span class=\"string\">'ferret'</span>, <span class=\"string\">'tobi'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// data will be 'woot'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server:</span></span><br><span class=\"line\"><span class=\"comment\">//  io.on('connection', (socket) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    socket.on('ferret', (name, fn) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      fn('woot');</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;);</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-on-eventName-callback\"><a href=\"#socket-on-eventName-callback\" class=\"headerlink\" title=\"socket.on(eventName, callback)\"></a>socket.on(eventName, callback)</h2><ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Register a new handler for the given event.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// with multiple arguments</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (arg1, arg2, arg3, arg4) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// with callback</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (cb) =&gt; &#123;</span><br><span class=\"line\">  cb(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The socket actually inherits every method of the <a href=\"https://github.com/component/emitter\" target=\"_blank\" rel=\"noopener\">Emitter</a> class, like <code>hasListeners</code>, <code>once</code> or <code>off</code> (to remove an event listener).</p>\n<h2 id=\"socket-compress-value\"><a href=\"#socket-compress-value\" class=\"headerlink\" title=\"socket.compress(value)\"></a>socket.compress(value)</h2><ul>\n<li><code>value</code> <em>(Boolean)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Sets a modifier for a subsequent event emission that the event data will only be <em>compressed</em> if the value is <code>true</code>. Defaults to <code>true</code> when you don’t call the method.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.compress(<span class=\"literal\">false</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-binary-value\"><a href=\"#socket-binary-value\" class=\"headerlink\" title=\"socket.binary(value)\"></a>socket.binary(value)</h2><p>Specifies whether the emitted data contains binary. Increases performance when specified. Can be <code>true</code> or <code>false</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.binary(<span class=\"literal\">false</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-close\"><a href=\"#socket-close\" class=\"headerlink\" title=\"socket.close()\"></a>socket.close()</h2><ul>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Disconnects the socket manually.</p>\n<h2 id=\"socket-disconnect\"><a href=\"#socket-disconnect\" class=\"headerlink\" title=\"socket.disconnect()\"></a>socket.disconnect()</h2><p>Synonym of <a href=\"#socketclose\">socket.close()</a>.</p>\n<h2 id=\"Event-‘connect’\"><a href=\"#Event-‘connect’\" class=\"headerlink\" title=\"Event: ‘connect’\"></a>Event: ‘connect’</h2><p>Fired upon a connection including a successful reconnection.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// note: you should register event handlers outside of connect,</span></span><br><span class=\"line\"><span class=\"comment\">// so they are not registered again on reconnection</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'myevent'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘connect-error’-1\"><a href=\"#Event-‘connect-error’-1\" class=\"headerlink\" title=\"Event: ‘connect_error’\"></a>Event: ‘connect_error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired upon a connection error.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'connect_error'</span>, (error) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘connect-timeout’-1\"><a href=\"#Event-‘connect-timeout’-1\" class=\"headerlink\" title=\"Event: ‘connect_timeout’\"></a>Event: ‘connect_timeout’</h2><p>Fired upon a connection timeout.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'connect_timeout'</span>, (timeout) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘error’\"><a href=\"#Event-‘error’\" class=\"headerlink\" title=\"Event: ‘error’\"></a>Event: ‘error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired when an error occurs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'error'</span>, (error) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘disconnect’\"><a href=\"#Event-‘disconnect’\" class=\"headerlink\" title=\"Event: ‘disconnect’\"></a>Event: ‘disconnect’</h2><ul>\n<li><code>reason</code> <em>(String)</em> either ‘io server disconnect’ or ‘io client disconnect’</li>\n</ul>\n<p>Fired upon a disconnection.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'disconnect'</span>, (reason) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reason === <span class=\"string\">'io server disconnect'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the disconnection was initiated by the server, you need to reconnect manually</span></span><br><span class=\"line\">    socket.connect();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// else the socket will automatically try to reconnect</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnect’-1\"><a href=\"#Event-‘reconnect’-1\" class=\"headerlink\" title=\"Event: ‘reconnect’\"></a>Event: ‘reconnect’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon a successful reconnection.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect'</span>, (attemptNumber) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnect-attempt’-1\"><a href=\"#Event-‘reconnect-attempt’-1\" class=\"headerlink\" title=\"Event: ‘reconnect_attempt’\"></a>Event: ‘reconnect_attempt’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon an attempt to reconnect.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect_attempt'</span>, (attemptNumber) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnecting’-1\"><a href=\"#Event-‘reconnecting’-1\" class=\"headerlink\" title=\"Event: ‘reconnecting’\"></a>Event: ‘reconnecting’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon an attempt to reconnect.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnecting'</span>, (attemptNumber) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnect-error’-1\"><a href=\"#Event-‘reconnect-error’-1\" class=\"headerlink\" title=\"Event: ‘reconnect_error’\"></a>Event: ‘reconnect_error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired upon a reconnection attempt error.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect_error'</span>, (error) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnect-failed’-1\"><a href=\"#Event-‘reconnect-failed’-1\" class=\"headerlink\" title=\"Event: ‘reconnect_failed’\"></a>Event: ‘reconnect_failed’</h2><p>Fired when couldn’t reconnect within <code>reconnectionAttempts</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect_failed'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘ping’-1\"><a href=\"#Event-‘ping’-1\" class=\"headerlink\" title=\"Event: ‘ping’\"></a>Event: ‘ping’</h2><p>Fired when a ping packet is written out to the server.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'ping'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘pong’-1\"><a href=\"#Event-‘pong’-1\" class=\"headerlink\" title=\"Event: ‘pong’\"></a>Event: ‘pong’</h2><ul>\n<li><code>ms</code> <em>(Number)</em> number of ms elapsed since <code>ping</code> packet (i.e.: latency).</li>\n</ul>\n<p>Fired when a pong is received from the server.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'pong'</span>, (latency) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><p>Exposed as the <code>io</code> namespace in the standalone build, or the result of calling <code>require(&#39;socket.io-client&#39;)</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-client'</span>);</span><br><span class=\"line\"><span class=\"comment\">// or with import syntax</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> io <span class=\"keyword\">from</span> <span class=\"string\">'socket.io-client'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"io-protocol\"><a href=\"#io-protocol\" class=\"headerlink\" title=\"io.protocol\"></a>io.protocol</h2><ul>\n<li><em>(Number)</em></li>\n</ul>\n<p>The protocol revision number.</p>\n<h2 id=\"io-url-options\"><a href=\"#io-url-options\" class=\"headerlink\" title=\"io([url][, options])\"></a>io([url][, options])</h2><ul>\n<li><code>url</code> <em>(String)</em> (defaults to <code>window.location</code>)</li>\n<li><code>options</code> <em>(Object)</em><ul>\n<li><code>forceNew</code> <em>(Boolean)</em> whether to reuse an existing connection</li>\n</ul>\n</li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Creates a new <code>Manager</code> for the given URL, and attempts to reuse an existing <code>Manager</code> for subsequent calls, unless the <code>multiplex</code> option is passed with <code>false</code>. Passing this option is the equivalent of passing <code>&#39;force new connection&#39;: true</code> or <code>forceNew: true</code>.</p>\n<p>A new <code>Socket</code> instance is returned for the namespace specified by the pathname in the URL, defaulting to <code>/</code>. For example, if the <code>url</code> is <code>http://localhost/users</code>, a transport connection will be established to <code>http://localhost</code> and a Socket.IO connection will be established to <code>/users</code>.</p>\n<p>Query parameters can also be provided, either with the <code>query</code> option or directly in the url (example: <code>http://localhost/users?token=abc</code>).</p>\n<p>See <a href=\"#new-managerurl-options\">new Manager(url[, options])</a> for available <code>options</code>.</p>\n<h2 id=\"Initialization-examples\"><a href=\"#Initialization-examples\" class=\"headerlink\" title=\"Initialization examples\"></a>Initialization examples</h2><h3 id=\"With-multiplexing\"><a href=\"#With-multiplexing\" class=\"headerlink\" title=\"With multiplexing\"></a>With multiplexing</h3><p>By default, a single connection is used when connecting to different namespaces (to minimize resources):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io();</span><br><span class=\"line\"><span class=\"keyword\">const</span> adminSocket = io(<span class=\"string\">'/admin'</span>);</span><br><span class=\"line\"><span class=\"comment\">// a single connection will be established</span></span><br></pre></td></tr></table></figure>\n<p>That behaviour can be disabled with the <code>forceNew</code> option:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io();</span><br><span class=\"line\"><span class=\"keyword\">const</span> adminSocket = io(<span class=\"string\">'/admin'</span>, &#123; <span class=\"attr\">forceNew</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// will create two distinct connections</span></span><br></pre></td></tr></table></figure>\n<p>Note: reusing the same namespace will also create two connections</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io();</span><br><span class=\"line\"><span class=\"keyword\">const</span> socket2 = io();</span><br><span class=\"line\"><span class=\"comment\">// will also create two distinct connections</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"With-custom-path\"><a href=\"#With-custom-path\" class=\"headerlink\" title=\"With custom path\"></a>With custom <code>path</code></h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>, &#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/myownpath'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/myownpath'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The request URLs will look like: <code>localhost/myownpath/?EIO=3&amp;transport=polling&amp;sid=&lt;id&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost/admin'</span>, &#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/mypath'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Here, the socket connects to the <code>admin</code> namespace, with the custom path <code>mypath</code>.</p>\n<p>The request URLs will look like: <code>localhost/mypath/?EIO=3&amp;transport=polling&amp;sid=&lt;id&gt;</code> (the namespace is sent as part of the payload).</p>\n<h3 id=\"With-query-parameters\"><a href=\"#With-query-parameters\" class=\"headerlink\" title=\"With query parameters\"></a>With query parameters</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost?token=abc'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\">io.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> token = socket.handshake.query.token;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isValid(token)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'authentication error'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then</span></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> token = socket.handshake.query.token;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"With-query-option\"><a href=\"#With-query-option\" class=\"headerlink\" title=\"With query option\"></a>With query option</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  query: &#123;</span><br><span class=\"line\">    token: <span class=\"string\">'cde'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The query content can also be updated on reconnection:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect_attempt'</span>, () =&gt; &#123;</span><br><span class=\"line\">  socket.io.opts.query = &#123;</span><br><span class=\"line\">    token: <span class=\"string\">'fgh'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"With-extraHeaders\"><a href=\"#With-extraHeaders\" class=\"headerlink\" title=\"With extraHeaders\"></a>With <code>extraHeaders</code></h3><p>This only works if <code>polling</code> transport is enabled (which is the default). Custom headers will not be appended when using <code>websocket</code> as the transport. This happens because the WebSocket handshake does not honor custom headers. (For background see the <a href=\"https://tools.ietf.org/html/rfc6455#section-4\" target=\"_blank\" rel=\"noopener\">WebSocket protocol RFC</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  transportOptions: &#123;</span><br><span class=\"line\">    polling: &#123;</span><br><span class=\"line\">      extraHeaders: &#123;</span><br><span class=\"line\">        <span class=\"string\">'x-clientid'</span>: <span class=\"string\">'abc'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// middleware</span></span><br><span class=\"line\">io.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> clientId = socket.handshake.headers[<span class=\"string\">'x-clientid'</span>];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isValid(clientId)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'authentication error'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"With-websocket-transport-only\"><a href=\"#With-websocket-transport-only\" class=\"headerlink\" title=\"With websocket transport only\"></a>With <code>websocket</code> transport only</h3><p>By default, a long-polling connection is established first, then upgraded to “better” transports (like WebSocket). If you like to live dangerously, this part can be skipped:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  transports: [<span class=\"string\">'websocket'</span>]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// on reconnection, reset the transports option, as the Websocket</span></span><br><span class=\"line\"><span class=\"comment\">// connection may have failed (caused by proxy, firewall, browser, ...)</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'reconnect_attempt'</span>, () =&gt; &#123;</span><br><span class=\"line\">  socket.io.opts.transports = [<span class=\"string\">'polling'</span>, <span class=\"string\">'websocket'</span>];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"With-a-custom-parser\"><a href=\"#With-a-custom-parser\" class=\"headerlink\" title=\"With a custom parser\"></a>With a custom parser</h3><p>The default <a href=\"https://github.com/socketio/socket.io-parser\" target=\"_blank\" rel=\"noopener\">parser</a> promotes compatibility (support for <code>Blob</code>, <code>File</code>, binary check) at the expense of performance. A custom parser can be provided to match the needs of your application. Please see the example <a href=\"https://github.com/socketio/socket.io/tree/master/examples/custom-parsers\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parser = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-msgpack-parser'</span>); <span class=\"comment\">// or require('socket.io-json-parser')</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  parser: parser</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the server-side must have the same parser, to be able to communicate</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(&#123;</span><br><span class=\"line\">  parser: parser</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"Manager\"><a href=\"#Manager\" class=\"headerlink\" title=\"Manager\"></a>Manager</h1><h2 id=\"new-Manager-url-options\"><a href=\"#new-Manager-url-options\" class=\"headerlink\" title=\"new Manager(url[, options])\"></a>new Manager(url[, options])</h2><ul>\n<li><code>url</code> <em>(String)</em></li>\n<li><code>options</code> <em>(Object)</em><ul>\n<li><code>path</code> <em>(String)</em> name of the path that is captured on the server side (<code>/socket.io</code>)</li>\n<li><code>reconnection</code> <em>(Boolean)</em> whether to reconnect automatically (<code>true</code>)</li>\n<li><code>reconnectionAttempts</code> <em>(Number)</em> number of reconnection attempts before giving up (<code>Infinity</code>)</li>\n<li><code>reconnectionDelay</code> <em>(Number)</em> how long to initially wait before attempting a new<br>reconnection (<code>1000</code>). Affected by +/- <code>randomizationFactor</code>,<br>for example the default initial delay will be between 500 to 1500ms.</li>\n<li><code>reconnectionDelayMax</code> <em>(Number)</em> maximum amount of time to wait between<br>reconnections (<code>5000</code>). Each attempt increases the reconnection delay by 2x<br>along with a randomization as above</li>\n<li><code>randomizationFactor</code> <em>(Number)</em> (<code>0.5</code>), 0 &lt;= randomizationFactor &lt;= 1</li>\n<li><code>timeout</code> <em>(Number)</em> connection timeout before a <code>connect_error</code><br>and <code>connect_timeout</code> events are emitted (<code>20000</code>)</li>\n<li><code>autoConnect</code> <em>(Boolean)</em> by setting this false, you have to call <code>manager.open</code><br>whenever you decide it’s appropriate</li>\n<li><code>query</code> <em>(Object)</em>: additional query parameters that are sent when connecting a namespace (then found in <code>socket.handshake.query</code> object on the server-side)</li>\n<li><code>parser</code> <em>(Parser)</em>: the parser to use. Defaults to an instance of the <code>Parser</code> that ships with socket.io. See <a href=\"https://github.com/socketio/socket.io-parser\" target=\"_blank\" rel=\"noopener\">socket.io-parser</a>.</li>\n</ul>\n</li>\n<li><strong>Returns</strong> <code>Manager</code></li>\n</ul>\n<p>The <code>options</code> are also passed to <code>engine.io-client</code> upon initialization of the underlying <code>Socket</code>. See the available <code>options</code> <a href=\"https://github.com/socketio/engine.io-client#methods\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<h2 id=\"manager-reconnection-value\"><a href=\"#manager-reconnection-value\" class=\"headerlink\" title=\"manager.reconnection([value])\"></a>manager.reconnection([value])</h2><ul>\n<li><code>value</code> <em>(Boolean)</em></li>\n<li><strong>Returns</strong> <code>Manager|Boolean</code></li>\n</ul>\n<p>Sets the <code>reconnection</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-reconnectionAttempts-value\"><a href=\"#manager-reconnectionAttempts-value\" class=\"headerlink\" title=\"manager.reconnectionAttempts([value])\"></a>manager.reconnectionAttempts([value])</h2><ul>\n<li><code>value</code> <em>(Number)</em></li>\n<li><strong>Returns</strong> <code>Manager|Number</code></li>\n</ul>\n<p>Sets the <code>reconnectionAttempts</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-reconnectionDelay-value\"><a href=\"#manager-reconnectionDelay-value\" class=\"headerlink\" title=\"manager.reconnectionDelay([value])\"></a>manager.reconnectionDelay([value])</h2><ul>\n<li><code>value</code> <em>(Number)</em></li>\n<li><strong>Returns</strong> <code>Manager|Number</code></li>\n</ul>\n<p>Sets the <code>reconnectionDelay</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-reconnectionDelayMax-value\"><a href=\"#manager-reconnectionDelayMax-value\" class=\"headerlink\" title=\"manager.reconnectionDelayMax([value])\"></a>manager.reconnectionDelayMax([value])</h2><ul>\n<li><code>value</code> <em>(Number)</em></li>\n<li><strong>Returns</strong> <code>Manager|Number</code></li>\n</ul>\n<p>Sets the <code>reconnectionDelayMax</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-timeout-value\"><a href=\"#manager-timeout-value\" class=\"headerlink\" title=\"manager.timeout([value])\"></a>manager.timeout([value])</h2><ul>\n<li><code>value</code> <em>(Number)</em></li>\n<li><strong>Returns</strong> <code>Manager|Number</code></li>\n</ul>\n<p>Sets the <code>timeout</code> option, or returns it if no parameters are passed.</p>\n<h2 id=\"manager-open-callback\"><a href=\"#manager-open-callback\" class=\"headerlink\" title=\"manager.open([callback])\"></a>manager.open([callback])</h2><ul>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Manager</code></li>\n</ul>\n<p>If the manager was initiated with <code>autoConnect</code> to <code>false</code>, launch a new connection attempt.</p>\n<p>The <code>callback</code> argument is optional and will be called once the attempt fails/succeeds.</p>\n<h2 id=\"manager-connect-callback\"><a href=\"#manager-connect-callback\" class=\"headerlink\" title=\"manager.connect([callback])\"></a>manager.connect([callback])</h2><p>Synonym of <a href=\"#manageropencallback\">manager.open([callback])</a>.</p>\n<h2 id=\"manager-socket-nsp-options\"><a href=\"#manager-socket-nsp-options\" class=\"headerlink\" title=\"manager.socket(nsp, options)\"></a>manager.socket(nsp, options)</h2><ul>\n<li><code>nsp</code> <em>(String)</em></li>\n<li><code>options</code> <em>(Object)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Creates a new <code>Socket</code> for the given namespace.</p>\n<h2 id=\"Event-‘connect-error’\"><a href=\"#Event-‘connect-error’\" class=\"headerlink\" title=\"Event: ‘connect_error’\"></a>Event: ‘connect_error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired upon a connection error.</p>\n<h2 id=\"Event-‘connect-timeout’\"><a href=\"#Event-‘connect-timeout’\" class=\"headerlink\" title=\"Event: ‘connect_timeout’\"></a>Event: ‘connect_timeout’</h2><p>Fired upon a connection timeout.</p>\n<h2 id=\"Event-‘reconnect’\"><a href=\"#Event-‘reconnect’\" class=\"headerlink\" title=\"Event: ‘reconnect’\"></a>Event: ‘reconnect’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon a successful reconnection.</p>\n<h2 id=\"Event-‘reconnect-attempt’\"><a href=\"#Event-‘reconnect-attempt’\" class=\"headerlink\" title=\"Event: ‘reconnect_attempt’\"></a>Event: ‘reconnect_attempt’</h2><p>Fired upon an attempt to reconnect.</p>\n<h2 id=\"Event-‘reconnecting’\"><a href=\"#Event-‘reconnecting’\" class=\"headerlink\" title=\"Event: ‘reconnecting’\"></a>Event: ‘reconnecting’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon a successful reconnection.</p>\n<h2 id=\"Event-‘reconnect-error’\"><a href=\"#Event-‘reconnect-error’\" class=\"headerlink\" title=\"Event: ‘reconnect_error’\"></a>Event: ‘reconnect_error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired upon a reconnection attempt error.</p>\n<h2 id=\"Event-‘reconnect-failed’\"><a href=\"#Event-‘reconnect-failed’\" class=\"headerlink\" title=\"Event: ‘reconnect_failed’\"></a>Event: ‘reconnect_failed’</h2><p>Fired when couldn’t reconnect within <code>reconnectionAttempts</code>.</p>\n<h2 id=\"Event-‘ping’\"><a href=\"#Event-‘ping’\" class=\"headerlink\" title=\"Event: ‘ping’\"></a>Event: ‘ping’</h2><p>Fired when a ping packet is written out to the server.</p>\n<h2 id=\"Event-‘pong’\"><a href=\"#Event-‘pong’\" class=\"headerlink\" title=\"Event: ‘pong’\"></a>Event: ‘pong’</h2><ul>\n<li><code>ms</code> <em>(Number)</em> number of ms elapsed since <code>ping</code> packet (i.e.: latency).</li>\n</ul>\n<p>Fired when a pong is received from the server.</p>\n<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1><h2 id=\"socket-id\"><a href=\"#socket-id\" class=\"headerlink\" title=\"socket.id\"></a>socket.id</h2><ul>\n<li><em>(String)</em></li>\n</ul>\n<p>An unique identifier for the socket session. Set after the <code>connect</code> event is triggered, and updated after the <code>reconnect</code> event.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(socket.id); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(socket.id); <span class=\"comment\">// 'G5p5...'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-connected\"><a href=\"#socket-connected\" class=\"headerlink\" title=\"socket.connected\"></a>socket.connected</h2><ul>\n<li><em>(Boolean)</em></li>\n</ul>\n<p>Whether or not the socket is connected to the server.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(socket.connected); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-disconnected\"><a href=\"#socket-disconnected\" class=\"headerlink\" title=\"socket.disconnected\"></a>socket.disconnected</h2><ul>\n<li><em>(Boolean)</em></li>\n</ul>\n<p>Whether or not the socket is disconnected from the server.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(socket.disconnected); <span class=\"comment\">// false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-open\"><a href=\"#socket-open\" class=\"headerlink\" title=\"socket.open()\"></a>socket.open()</h2><ul>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Manually opens the socket.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  autoConnect: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">socket.open();</span><br></pre></td></tr></table></figure>\n<p>It can also be used to manually reconnect:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'disconnect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  socket.open();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-connect\"><a href=\"#socket-connect\" class=\"headerlink\" title=\"socket.connect()\"></a>socket.connect()</h2><p>Synonym of <a href=\"#socketopen\">socket.open()</a>.</p>\n<h2 id=\"socket-send-…args-ack\"><a href=\"#socket-send-…args-ack\" class=\"headerlink\" title=\"socket.send([…args][, ack])\"></a>socket.send([…args][, ack])</h2><ul>\n<li><code>args</code></li>\n<li><code>ack</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Sends a <code>message</code> event. See <a href=\"#socketemiteventname-args-ack\">socket.emit(eventName[, …args][, ack])</a>.</p>\n<h2 id=\"socket-emit-eventName-…args-ack\"><a href=\"#socket-emit-eventName-…args-ack\" class=\"headerlink\" title=\"socket.emit(eventName[, …args][, ack])\"></a>socket.emit(eventName[, …args][, ack])</h2><ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>args</code></li>\n<li><code>ack</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including <code>Buffer</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.emit(<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>);</span><br><span class=\"line\">socket.emit(<span class=\"string\">'with-binary'</span>, <span class=\"number\">1</span>, <span class=\"string\">'2'</span>, &#123; <span class=\"number\">3</span>: <span class=\"string\">'4'</span>, <span class=\"number\">5</span>: <span class=\"keyword\">new</span> Buffer(<span class=\"number\">6</span>) &#125;);</span><br></pre></td></tr></table></figure>\n<p>The <code>ack</code> argument is optional and will be called with the server answer.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.emit(<span class=\"string\">'ferret'</span>, <span class=\"string\">'tobi'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// data will be 'woot'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server:</span></span><br><span class=\"line\"><span class=\"comment\">//  io.on('connection', (socket) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    socket.on('ferret', (name, fn) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      fn('woot');</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;);</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-on-eventName-callback\"><a href=\"#socket-on-eventName-callback\" class=\"headerlink\" title=\"socket.on(eventName, callback)\"></a>socket.on(eventName, callback)</h2><ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Register a new handler for the given event.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// with multiple arguments</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (arg1, arg2, arg3, arg4) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// with callback</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (cb) =&gt; &#123;</span><br><span class=\"line\">  cb(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The socket actually inherits every method of the <a href=\"https://github.com/component/emitter\" target=\"_blank\" rel=\"noopener\">Emitter</a> class, like <code>hasListeners</code>, <code>once</code> or <code>off</code> (to remove an event listener).</p>\n<h2 id=\"socket-compress-value\"><a href=\"#socket-compress-value\" class=\"headerlink\" title=\"socket.compress(value)\"></a>socket.compress(value)</h2><ul>\n<li><code>value</code> <em>(Boolean)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Sets a modifier for a subsequent event emission that the event data will only be <em>compressed</em> if the value is <code>true</code>. Defaults to <code>true</code> when you don’t call the method.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.compress(<span class=\"literal\">false</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-binary-value\"><a href=\"#socket-binary-value\" class=\"headerlink\" title=\"socket.binary(value)\"></a>socket.binary(value)</h2><p>Specifies whether the emitted data contains binary. Increases performance when specified. Can be <code>true</code> or <code>false</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.binary(<span class=\"literal\">false</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-close\"><a href=\"#socket-close\" class=\"headerlink\" title=\"socket.close()\"></a>socket.close()</h2><ul>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Disconnects the socket manually.</p>\n<h2 id=\"socket-disconnect\"><a href=\"#socket-disconnect\" class=\"headerlink\" title=\"socket.disconnect()\"></a>socket.disconnect()</h2><p>Synonym of <a href=\"#socketclose\">socket.close()</a>.</p>\n<h2 id=\"Event-‘connect’\"><a href=\"#Event-‘connect’\" class=\"headerlink\" title=\"Event: ‘connect’\"></a>Event: ‘connect’</h2><p>Fired upon a connection including a successful reconnection.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// note: you should register event handlers outside of connect,</span></span><br><span class=\"line\"><span class=\"comment\">// so they are not registered again on reconnection</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'myevent'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘connect-error’-1\"><a href=\"#Event-‘connect-error’-1\" class=\"headerlink\" title=\"Event: ‘connect_error’\"></a>Event: ‘connect_error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired upon a connection error.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'connect_error'</span>, (error) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘connect-timeout’-1\"><a href=\"#Event-‘connect-timeout’-1\" class=\"headerlink\" title=\"Event: ‘connect_timeout’\"></a>Event: ‘connect_timeout’</h2><p>Fired upon a connection timeout.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'connect_timeout'</span>, (timeout) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘error’\"><a href=\"#Event-‘error’\" class=\"headerlink\" title=\"Event: ‘error’\"></a>Event: ‘error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired when an error occurs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'error'</span>, (error) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘disconnect’\"><a href=\"#Event-‘disconnect’\" class=\"headerlink\" title=\"Event: ‘disconnect’\"></a>Event: ‘disconnect’</h2><ul>\n<li><code>reason</code> <em>(String)</em> either ‘io server disconnect’ or ‘io client disconnect’</li>\n</ul>\n<p>Fired upon a disconnection.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'disconnect'</span>, (reason) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reason === <span class=\"string\">'io server disconnect'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the disconnection was initiated by the server, you need to reconnect manually</span></span><br><span class=\"line\">    socket.connect();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// else the socket will automatically try to reconnect</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnect’-1\"><a href=\"#Event-‘reconnect’-1\" class=\"headerlink\" title=\"Event: ‘reconnect’\"></a>Event: ‘reconnect’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon a successful reconnection.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect'</span>, (attemptNumber) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnect-attempt’-1\"><a href=\"#Event-‘reconnect-attempt’-1\" class=\"headerlink\" title=\"Event: ‘reconnect_attempt’\"></a>Event: ‘reconnect_attempt’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon an attempt to reconnect.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect_attempt'</span>, (attemptNumber) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnecting’-1\"><a href=\"#Event-‘reconnecting’-1\" class=\"headerlink\" title=\"Event: ‘reconnecting’\"></a>Event: ‘reconnecting’</h2><ul>\n<li><code>attempt</code> <em>(Number)</em> reconnection attempt number</li>\n</ul>\n<p>Fired upon an attempt to reconnect.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnecting'</span>, (attemptNumber) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnect-error’-1\"><a href=\"#Event-‘reconnect-error’-1\" class=\"headerlink\" title=\"Event: ‘reconnect_error’\"></a>Event: ‘reconnect_error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired upon a reconnection attempt error.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect_error'</span>, (error) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘reconnect-failed’-1\"><a href=\"#Event-‘reconnect-failed’-1\" class=\"headerlink\" title=\"Event: ‘reconnect_failed’\"></a>Event: ‘reconnect_failed’</h2><p>Fired when couldn’t reconnect within <code>reconnectionAttempts</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'reconnect_failed'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘ping’-1\"><a href=\"#Event-‘ping’-1\" class=\"headerlink\" title=\"Event: ‘ping’\"></a>Event: ‘ping’</h2><p>Fired when a ping packet is written out to the server.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'ping'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘pong’-1\"><a href=\"#Event-‘pong’-1\" class=\"headerlink\" title=\"Event: ‘pong’\"></a>Event: ‘pong’</h2><ul>\n<li><code>ms</code> <em>(Number)</em> number of ms elapsed since <code>ping</code> packet (i.e.: latency).</li>\n</ul>\n<p>Fired when a pong is received from the server.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'pong'</span>, (latency) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"Socket.IO  —  Emit cheatsheet","type":"docs","_content":"\n```js\n\nio.on('connect', onConnect);\n\nfunction onConnect(socket){\n\n  // sending to the client\n  socket.emit('hello', 'can you hear me?', 1, 2, 'abc');\n\n  // sending to all clients except sender\n  socket.broadcast.emit('broadcast', 'hello friends!');\n\n  // sending to all clients in 'game' room except sender\n  socket.to('game').emit('nice game', \"let's play a game\");\n\n  // sending to all clients in 'game1' and/or in 'game2' room, except sender\n  socket.to('game1').to('game2').emit('nice game', \"let's play a game (too)\");\n\n  // sending to all clients in 'game' room, including sender\n  io.in('game').emit('big-announcement', 'the game will start soon');\n\n  // sending to all clients in namespace 'myNamespace', including sender\n  io.of('myNamespace').emit('bigger-announcement', 'the tournament will start soon');\n\n  // sending to a specific room in a specific namespace, including sender\n  io.of('myNamespace').to('room').emit('event', 'message');\n\n  // sending to individual socketid (private message)\n  io.to(<socketid>).emit('hey', 'I just met you');\n\n  // sending with acknowledgement\n  socket.emit('question', 'do you think so?', function (answer) {});\n\n  // sending without compression\n  socket.compress(false).emit('uncompressed', \"that's rough\");\n\n  // sending a message that might be dropped if the client is not ready to receive messages\n  socket.volatile.emit('maybe', 'do you really need it?');\n\n  // specifying whether the data to send has binary data\n  socket.binary(false).emit('what', 'I have no binaries!');\n\n  // sending to all clients on this node (when using multiple nodes)\n  io.local.emit('hi', 'my lovely babies');\n\n  // sending to all connected clients\n  io.emit('an event sent to all connected clients');\n\n};\n\n```\n\n**Note:** The following events are reserved and should not be used as event names by your application:\n- `error`\n- `connect`\n- `disconnect`\n- `disconnecting`\n- `newListener`\n- `removeListener`\n- `ping`\n- `pong`\n","source":"docs/emit-cheatsheet.md","raw":"title: Socket.IO  —  Emit cheatsheet\npermalink: /docs/emit-cheatsheet/\ntype: docs\n---\n\n```js\n\nio.on('connect', onConnect);\n\nfunction onConnect(socket){\n\n  // sending to the client\n  socket.emit('hello', 'can you hear me?', 1, 2, 'abc');\n\n  // sending to all clients except sender\n  socket.broadcast.emit('broadcast', 'hello friends!');\n\n  // sending to all clients in 'game' room except sender\n  socket.to('game').emit('nice game', \"let's play a game\");\n\n  // sending to all clients in 'game1' and/or in 'game2' room, except sender\n  socket.to('game1').to('game2').emit('nice game', \"let's play a game (too)\");\n\n  // sending to all clients in 'game' room, including sender\n  io.in('game').emit('big-announcement', 'the game will start soon');\n\n  // sending to all clients in namespace 'myNamespace', including sender\n  io.of('myNamespace').emit('bigger-announcement', 'the tournament will start soon');\n\n  // sending to a specific room in a specific namespace, including sender\n  io.of('myNamespace').to('room').emit('event', 'message');\n\n  // sending to individual socketid (private message)\n  io.to(<socketid>).emit('hey', 'I just met you');\n\n  // sending with acknowledgement\n  socket.emit('question', 'do you think so?', function (answer) {});\n\n  // sending without compression\n  socket.compress(false).emit('uncompressed', \"that's rough\");\n\n  // sending a message that might be dropped if the client is not ready to receive messages\n  socket.volatile.emit('maybe', 'do you really need it?');\n\n  // specifying whether the data to send has binary data\n  socket.binary(false).emit('what', 'I have no binaries!');\n\n  // sending to all clients on this node (when using multiple nodes)\n  io.local.emit('hi', 'my lovely babies');\n\n  // sending to all connected clients\n  io.emit('an event sent to all connected clients');\n\n};\n\n```\n\n**Note:** The following events are reserved and should not be used as event names by your application:\n- `error`\n- `connect`\n- `disconnect`\n- `disconnecting`\n- `newListener`\n- `removeListener`\n- `ping`\n- `pong`\n","date":"2018-07-21T06:09:40.784Z","updated":"2018-07-21T06:09:40.784Z","path":"/docs/emit-cheatsheet/index.html","comments":1,"layout":"page","_id":"cjjxdyebd0005jgcx60pgyocd","content":"<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connect'</span>, onConnect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onConnect</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to the client</span></span><br><span class=\"line\">  socket.emit(<span class=\"string\">'hello'</span>, <span class=\"string\">'can you hear me?'</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'abc'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients except sender</span></span><br><span class=\"line\">  socket.broadcast.emit(<span class=\"string\">'broadcast'</span>, <span class=\"string\">'hello friends!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients in 'game' room except sender</span></span><br><span class=\"line\">  socket.to(<span class=\"string\">'game'</span>).emit(<span class=\"string\">'nice game'</span>, <span class=\"string\">\"let's play a game\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients in 'game1' and/or in 'game2' room, except sender</span></span><br><span class=\"line\">  socket.to(<span class=\"string\">'game1'</span>).to(<span class=\"string\">'game2'</span>).emit(<span class=\"string\">'nice game'</span>, <span class=\"string\">\"let's play a game (too)\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients in 'game' room, including sender</span></span><br><span class=\"line\">  io.in(<span class=\"string\">'game'</span>).emit(<span class=\"string\">'big-announcement'</span>, <span class=\"string\">'the game will start soon'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients in namespace 'myNamespace', including sender</span></span><br><span class=\"line\">  io.of(<span class=\"string\">'myNamespace'</span>).emit(<span class=\"string\">'bigger-announcement'</span>, <span class=\"string\">'the tournament will start soon'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to a specific room in a specific namespace, including sender</span></span><br><span class=\"line\">  io.of(<span class=\"string\">'myNamespace'</span>).to(<span class=\"string\">'room'</span>).emit(<span class=\"string\">'event'</span>, <span class=\"string\">'message'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to individual socketid (private message)</span></span><br><span class=\"line\">  io.to(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">socketid</span>&gt;</span>).emit('hey', 'I just met you');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending with acknowledgement</span></span><br><span class=\"line\"><span class=\"xml\">  socket.emit('question', 'do you think so?', function (answer) &#123;&#125;);</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending without compression</span></span><br><span class=\"line\"><span class=\"xml\">  socket.compress(false).emit('uncompressed', \"that's rough\");</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending a message that might be dropped if the client is not ready to receive messages</span></span><br><span class=\"line\"><span class=\"xml\">  socket.volatile.emit('maybe', 'do you really need it?');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // specifying whether the data to send has binary data</span></span><br><span class=\"line\"><span class=\"xml\">  socket.binary(false).emit('what', 'I have no binaries!');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending to all clients on this node (when using multiple nodes)</span></span><br><span class=\"line\"><span class=\"xml\">  io.local.emit('hi', 'my lovely babies');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending to all connected clients</span></span><br><span class=\"line\"><span class=\"xml\">  io.emit('an event sent to all connected clients');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> The following events are reserved and should not be used as event names by your application:</p>\n<ul>\n<li><code>error</code></li>\n<li><code>connect</code></li>\n<li><code>disconnect</code></li>\n<li><code>disconnecting</code></li>\n<li><code>newListener</code></li>\n<li><code>removeListener</code></li>\n<li><code>ping</code></li>\n<li><code>pong</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connect'</span>, onConnect);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onConnect</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to the client</span></span><br><span class=\"line\">  socket.emit(<span class=\"string\">'hello'</span>, <span class=\"string\">'can you hear me?'</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'abc'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients except sender</span></span><br><span class=\"line\">  socket.broadcast.emit(<span class=\"string\">'broadcast'</span>, <span class=\"string\">'hello friends!'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients in 'game' room except sender</span></span><br><span class=\"line\">  socket.to(<span class=\"string\">'game'</span>).emit(<span class=\"string\">'nice game'</span>, <span class=\"string\">\"let's play a game\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients in 'game1' and/or in 'game2' room, except sender</span></span><br><span class=\"line\">  socket.to(<span class=\"string\">'game1'</span>).to(<span class=\"string\">'game2'</span>).emit(<span class=\"string\">'nice game'</span>, <span class=\"string\">\"let's play a game (too)\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients in 'game' room, including sender</span></span><br><span class=\"line\">  io.in(<span class=\"string\">'game'</span>).emit(<span class=\"string\">'big-announcement'</span>, <span class=\"string\">'the game will start soon'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to all clients in namespace 'myNamespace', including sender</span></span><br><span class=\"line\">  io.of(<span class=\"string\">'myNamespace'</span>).emit(<span class=\"string\">'bigger-announcement'</span>, <span class=\"string\">'the tournament will start soon'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to a specific room in a specific namespace, including sender</span></span><br><span class=\"line\">  io.of(<span class=\"string\">'myNamespace'</span>).to(<span class=\"string\">'room'</span>).emit(<span class=\"string\">'event'</span>, <span class=\"string\">'message'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// sending to individual socketid (private message)</span></span><br><span class=\"line\">  io.to(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">socketid</span>&gt;</span>).emit('hey', 'I just met you');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending with acknowledgement</span></span><br><span class=\"line\"><span class=\"xml\">  socket.emit('question', 'do you think so?', function (answer) &#123;&#125;);</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending without compression</span></span><br><span class=\"line\"><span class=\"xml\">  socket.compress(false).emit('uncompressed', \"that's rough\");</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending a message that might be dropped if the client is not ready to receive messages</span></span><br><span class=\"line\"><span class=\"xml\">  socket.volatile.emit('maybe', 'do you really need it?');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // specifying whether the data to send has binary data</span></span><br><span class=\"line\"><span class=\"xml\">  socket.binary(false).emit('what', 'I have no binaries!');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending to all clients on this node (when using multiple nodes)</span></span><br><span class=\"line\"><span class=\"xml\">  io.local.emit('hi', 'my lovely babies');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  // sending to all connected clients</span></span><br><span class=\"line\"><span class=\"xml\">  io.emit('an event sent to all connected clients');</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> The following events are reserved and should not be used as event names by your application:</p>\n<ul>\n<li><code>error</code></li>\n<li><code>connect</code></li>\n<li><code>disconnect</code></li>\n<li><code>disconnecting</code></li>\n<li><code>newListener</code></li>\n<li><code>removeListener</code></li>\n<li><code>ping</code></li>\n<li><code>pong</code></li>\n</ul>\n"},{"title":"Socket.IO  —  FAQ","type":"docs","_content":"\n## Can I use wildcards in events?\n\nNot in Socket.IO directly, but check out [this plugin](https://github.com/hden/socketio-wildcard) by Hao-kang Den. It provides a Socket.IO middleware to deal with wildcards.\n\n## Socket.IO with Apache Cordova?\n\nTake a look at [this tutorial](/socket-io-with-apache-cordova/).\n\n## Socket.IO on iOS?\n\nTake a look at [SIOSocket](https://github.com/MegaBits/SIOSocket).\n\n## Socket.IO on Android?\n\nTake a look at [socket.io-client.java](https://github.com/nkzawa/socket.io-client.java).\n","source":"docs/faq.md","raw":"title: Socket.IO  —  FAQ\npermalink: /docs/faq/\ntype: docs\n---\n\n## Can I use wildcards in events?\n\nNot in Socket.IO directly, but check out [this plugin](https://github.com/hden/socketio-wildcard) by Hao-kang Den. It provides a Socket.IO middleware to deal with wildcards.\n\n## Socket.IO with Apache Cordova?\n\nTake a look at [this tutorial](/socket-io-with-apache-cordova/).\n\n## Socket.IO on iOS?\n\nTake a look at [SIOSocket](https://github.com/MegaBits/SIOSocket).\n\n## Socket.IO on Android?\n\nTake a look at [socket.io-client.java](https://github.com/nkzawa/socket.io-client.java).\n","date":"2018-07-21T06:13:41.612Z","updated":"2018-07-21T06:13:41.612Z","path":"/docs/faq/index.html","comments":1,"layout":"page","_id":"cjjxdyebe0006jgcxkjt1zjfm","content":"<h2 id=\"Can-I-use-wildcards-in-events\"><a href=\"#Can-I-use-wildcards-in-events\" class=\"headerlink\" title=\"Can I use wildcards in events?\"></a>Can I use wildcards in events?</h2><p>Not in Socket.IO directly, but check out <a href=\"https://github.com/hden/socketio-wildcard\" target=\"_blank\" rel=\"noopener\">this plugin</a> by Hao-kang Den. It provides a Socket.IO middleware to deal with wildcards.</p>\n<h2 id=\"Socket-IO-with-Apache-Cordova\"><a href=\"#Socket-IO-with-Apache-Cordova\" class=\"headerlink\" title=\"Socket.IO with Apache Cordova?\"></a>Socket.IO with Apache Cordova?</h2><p>Take a look at <a href=\"/socket-io-with-apache-cordova/\">this tutorial</a>.</p>\n<h2 id=\"Socket-IO-on-iOS\"><a href=\"#Socket-IO-on-iOS\" class=\"headerlink\" title=\"Socket.IO on iOS?\"></a>Socket.IO on iOS?</h2><p>Take a look at <a href=\"https://github.com/MegaBits/SIOSocket\" target=\"_blank\" rel=\"noopener\">SIOSocket</a>.</p>\n<h2 id=\"Socket-IO-on-Android\"><a href=\"#Socket-IO-on-Android\" class=\"headerlink\" title=\"Socket.IO on Android?\"></a>Socket.IO on Android?</h2><p>Take a look at <a href=\"https://github.com/nkzawa/socket.io-client.java\" target=\"_blank\" rel=\"noopener\">socket.io-client.java</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Can-I-use-wildcards-in-events\"><a href=\"#Can-I-use-wildcards-in-events\" class=\"headerlink\" title=\"Can I use wildcards in events?\"></a>Can I use wildcards in events?</h2><p>Not in Socket.IO directly, but check out <a href=\"https://github.com/hden/socketio-wildcard\" target=\"_blank\" rel=\"noopener\">this plugin</a> by Hao-kang Den. It provides a Socket.IO middleware to deal with wildcards.</p>\n<h2 id=\"Socket-IO-with-Apache-Cordova\"><a href=\"#Socket-IO-with-Apache-Cordova\" class=\"headerlink\" title=\"Socket.IO with Apache Cordova?\"></a>Socket.IO with Apache Cordova?</h2><p>Take a look at <a href=\"/socket-io-with-apache-cordova/\">this tutorial</a>.</p>\n<h2 id=\"Socket-IO-on-iOS\"><a href=\"#Socket-IO-on-iOS\" class=\"headerlink\" title=\"Socket.IO on iOS?\"></a>Socket.IO on iOS?</h2><p>Take a look at <a href=\"https://github.com/MegaBits/SIOSocket\" target=\"_blank\" rel=\"noopener\">SIOSocket</a>.</p>\n<h2 id=\"Socket-IO-on-Android\"><a href=\"#Socket-IO-on-Android\" class=\"headerlink\" title=\"Socket.IO on Android?\"></a>Socket.IO on Android?</h2><p>Take a look at <a href=\"https://github.com/nkzawa/socket.io-client.java\" target=\"_blank\" rel=\"noopener\">socket.io-client.java</a>.</p>\n"},{"title":"Socket.IO  —  Logging and debugging","type":"docs","_content":"\nSocket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called [debug](https://github.com/visionmedia/debug) by TJ Holowaychuk.\n\nBefore 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.\n\nThe basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the `DEBUG` env variable (Node.JS) or the `localStorage.debug` property (Browsers).\n\nYou can see it in action for example on our homepage:\n\n<video id=\"debugging-vid\" data-setup='{\"autoplay\":true,\"loop\":true, \"techOrder\": [\"html5\", \"flash\"], \"height\": 300}' class=\"video-js vjs-default-skin\" autoplay loop width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/IL9alTr0eO.mp4\" type=\"video/mp4\"></video>\n\n## Available debugging scopes\n\nThe best way to see what information is available is to use the `*`:\n\n```\nDEBUG=* node yourfile.js`\n```\n\nor in the browser:\n\n```\nlocalStorage.debug = '*';\n```\n\nAnd then filter by the scopes you&#8217;re interested in. You can use `,` to separate them.\n","source":"docs/logging-and-debugging.md","raw":"title: Socket.IO  —  Logging and debugging\npermalink: /docs/logging-and-debugging/\ntype: docs\n---\n\nSocket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called [debug](https://github.com/visionmedia/debug) by TJ Holowaychuk.\n\nBefore 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.\n\nThe basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the `DEBUG` env variable (Node.JS) or the `localStorage.debug` property (Browsers).\n\nYou can see it in action for example on our homepage:\n\n<video id=\"debugging-vid\" data-setup='{\"autoplay\":true,\"loop\":true, \"techOrder\": [\"html5\", \"flash\"], \"height\": 300}' class=\"video-js vjs-default-skin\" autoplay loop width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/IL9alTr0eO.mp4\" type=\"video/mp4\"></video>\n\n## Available debugging scopes\n\nThe best way to see what information is available is to use the `*`:\n\n```\nDEBUG=* node yourfile.js`\n```\n\nor in the browser:\n\n```\nlocalStorage.debug = '*';\n```\n\nAnd then filter by the scopes you&#8217;re interested in. You can use `,` to separate them.\n","date":"2018-07-21T06:06:26.908Z","updated":"2018-07-21T06:06:26.908Z","path":"/docs/logging-and-debugging/index.html","comments":1,"layout":"page","_id":"cjjxdyebf0007jgcxxtkpv2hs","content":"<p>Socket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called <a href=\"https://github.com/visionmedia/debug\" target=\"_blank\" rel=\"noopener\">debug</a> by TJ Holowaychuk.</p>\n<p>Before 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.</p>\n<p>The basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the <code>DEBUG</code> env variable (Node.JS) or the <code>localStorage.debug</code> property (Browsers).</p>\n<p>You can see it in action for example on our homepage:</p>\n<video id=\"debugging-vid\" data-setup=\"{\"autoplay\":true,\"loop\":true, \"techOrder\": [\"html5\", \"flash\"], \"height\": 300}\" class=\"video-js vjs-default-skin\" autoplay loop width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/IL9alTr0eO.mp4\" type=\"video/mp4\"></video>\n\n<h2 id=\"Available-debugging-scopes\"><a href=\"#Available-debugging-scopes\" class=\"headerlink\" title=\"Available debugging scopes\"></a>Available debugging scopes</h2><p>The best way to see what information is available is to use the <code>*</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DEBUG=* node yourfile.js`</span><br></pre></td></tr></table></figure>\n<p>or in the browser:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">localStorage.debug = &apos;*&apos;;</span><br></pre></td></tr></table></figure>\n<p>And then filter by the scopes you&#8217;re interested in. You can use <code>,</code> to separate them.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Socket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called <a href=\"https://github.com/visionmedia/debug\" target=\"_blank\" rel=\"noopener\">debug</a> by TJ Holowaychuk.</p>\n<p>Before 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.</p>\n<p>The basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the <code>DEBUG</code> env variable (Node.JS) or the <code>localStorage.debug</code> property (Browsers).</p>\n<p>You can see it in action for example on our homepage:</p>\n<video id=\"debugging-vid\" data-setup=\"{\"autoplay\":true,\"loop\":true, \"techOrder\": [\"html5\", \"flash\"], \"height\": 300}\" class=\"video-js vjs-default-skin\" autoplay loop width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/IL9alTr0eO.mp4\" type=\"video/mp4\"></video>\n\n<h2 id=\"Available-debugging-scopes\"><a href=\"#Available-debugging-scopes\" class=\"headerlink\" title=\"Available debugging scopes\"></a>Available debugging scopes</h2><p>The best way to see what information is available is to use the <code>*</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DEBUG=* node yourfile.js`</span><br></pre></td></tr></table></figure>\n<p>or in the browser:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">localStorage.debug = &apos;*&apos;;</span><br></pre></td></tr></table></figure>\n<p>And then filter by the scopes you&#8217;re interested in. You can use <code>,</code> to separate them.</p>\n"},{"title":"Socket.IO  —  Docs","type":"docs","_content":"\n## Installing\n\n```\nnpm install socket.io\n```\n\n## Using with Node http server\n\n### Server (app.js)\n\n```js\nvar app = require('http').createServer(handler)\nvar io = require('socket.io')(app);\nvar fs = require('fs');\n\napp.listen(80);\n\nfunction handler (req, res) {\n  fs.readFile(__dirname + '/index.html',\n  function (err, data) {\n    if (err) {\n      res.writeHead(500);\n      return res.end('Error loading index.html');\n    }\n\n    res.writeHead(200);\n    res.end(data);\n  });\n}\n\nio.on('connection', function (socket) {\n  socket.emit('news', { hello: 'world' });\n  socket.on('my other event', function (data) {\n    console.log(data);\n  });\n});\n```\n\n### Client (index.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io('http://localhost');\n  socket.on('news', function (data) {\n    console.log(data);\n    socket.emit('my other event', { my: 'data' });\n  });\n</script>\n```\n\n## Using with Express 3/4\n\n### Server (app.js)\n\n```js\nvar app = require('express')();\nvar server = require('http').Server(app);\nvar io = require('socket.io')(server);\n\nserver.listen(80);\n\napp.get('/', function (req, res) {\n  res.sendfile(__dirname + '/index.html');\n});\n\nio.on('connection', function (socket) {\n  socket.emit('news', { hello: 'world' });\n  socket.on('my other event', function (data) {\n    console.log(data);\n  });\n});\n```\n\n### Client (index.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io.connect('http://localhost');\n  socket.on('news', function (data) {\n    console.log(data);\n    socket.emit('my other event', { my: 'data' });\n  });\n</script>\n```\n\n## Using with Express 2.x\n\n### Server (app.js)\n\n```js\nvar app = require('express').createServer();\nvar io = require('socket.io')(app);\n\napp.listen(80);\n\napp.get('/', function (req, res) {\n  res.sendFile(__dirname + '/index.html');\n});\n\nio.on('connection', function (socket) {\n  socket.emit('news', { hello: 'world' });\n  socket.on('my other event', function (data) {\n    console.log(data);\n  });\n});\n```\n\n### Client (index.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io.connect('http://localhost');\n  socket.on('news', function (data) {\n    console.log(data);\n    socket.emit('my other event', { my: 'data' });\n  });\n</script>\n```\n\n## Sending and receiving events\n\nSocket.IO allows you to emit and receive custom events. Besides `connect`, `message` and `disconnect`, you can emit custom events:\n\n### Server\n\n```js\n// note, io(<port>) will create a http server for you\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  io.emit('this', { will: 'be received by everyone'});\n\n  socket.on('private message', function (from, msg) {\n    console.log('I received a private message by ', from, ' saying ', msg);\n  });\n\n  socket.on('disconnect', function () {\n    io.emit('user disconnected');\n  });\n});\n```\n\n## Restricting yourself to a namespace\n\nIf you have control over all the messages and events emitted for a particular application, using the default / namespace works. If you want to leverage 3rd-party code, or produce code to share with others, socket.io provides a way of namespacing a socket.\n\nThis has the benefit of `multiplexing` a single connection. Instead of socket.io using two `WebSocket` connections, it’ll use one.\n\n### Server (app.js)\n\n```js\nvar io = require('socket.io')(80);\nvar chat = io\n  .of('/chat')\n  .on('connection', function (socket) {\n    socket.emit('a message', {\n        that: 'only'\n      , '/chat': 'will get'\n    });\n    chat.emit('a message', {\n        everyone: 'in'\n      , '/chat': 'will get'\n    });\n  });\n\nvar news = io\n  .of('/news')\n  .on('connection', function (socket) {\n    socket.emit('item', { news: 'item' });\n  });\n```\n\n### Client (index.html)\n\n```html\n<script>\n  var chat = io.connect('http://localhost/chat')\n    , news = io.connect('http://localhost/news');\n  \n  chat.on('connect', function () {\n    chat.emit('hi!');\n  });\n  \n  news.on('news', function () {\n    news.emit('woot');\n  });\n</script>\n```\n\n## Sending volatile messages\n\nSometimes certain messages can be dropped. Let’s say you have an app that shows realtime tweets for the keyword `bieber`.\n\nIf a certain client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle), if it doesn’t receive ALL the tweets related to bieber your application won’t suffer.\n\nIn that case, you might want to send those messages as volatile messages.\n\n### Server\n\n```js\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  var tweets = setInterval(function () {\n    getBieberTweet(function (tweet) {\n      socket.volatile.emit('bieber tweet', tweet);\n    });\n  }, 100);\n\n  socket.on('disconnect', function () {\n    clearInterval(tweets);\n  });\n});\n```\n\n## Sending and getting data (acknowledgements)\n\nSometimes, you might want to get a callback when the client confirmed the message reception.\n\nTo do this, simply pass a function as the last parameter of `.send` or `.emit`. What’s more, when you use `.emit`, the acknowledgement is done by you, which means you can also pass data along:\n\n### Server (app.js)\n\n```js\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  socket.on('ferret', function (name, fn) {\n    fn('woot');\n  });\n});\n```\n\n### Client (index.html)\n\n```html\n<script>\n  var socket = io(); // TIP: io() with no args does auto-discovery\n  socket.on('connect', function () { // TIP: you can avoid listening on `connect` and listen on events directly too!\n    socket.emit('ferret', 'tobi', function (data) {\n      console.log(data); // data will be 'woot'\n    });\n  });\n</script>\n```\n\n## Broadcasting messages\n\nTo broadcast, simply add a `broadcast` flag to `emit` and `send` method calls. Broadcasting means sending a message to everyone else except for the socket that starts it.\n\n### Server\n\n```js\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  socket.broadcast.emit('user connected');\n});\n```\n\n## Using it just as a cross-browser WebSocket\n\nIf you just want the WebSocket semantics, you can do that too. Simply leverage `send` and listen on the `message` event:\n\n### Server (app.js)\n\n```js\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  socket.on('message', function () { });\n  socket.on('disconnect', function () { });\n});\n```\n\n### Client (index.html)\n\n```html\n<script>\n  var socket = io('http://localhost/');\n  socket.on('connect', function () {\n    socket.send('hi');\n\n    socket.on('message', function (msg) {\n      // my msg\n    });\n  });\n</script>\n```\n\nIf you don’t care about reconnection logic and such, take a look at <a href=\"https://github.com/socketio/engine.io\">Engine.IO</a>, which is the WebSocket semantics transport layer Socket.IO uses.\n","source":"docs/index.md","raw":"title: Socket.IO  —  Docs\ntype: docs\n---\n\n## Installing\n\n```\nnpm install socket.io\n```\n\n## Using with Node http server\n\n### Server (app.js)\n\n```js\nvar app = require('http').createServer(handler)\nvar io = require('socket.io')(app);\nvar fs = require('fs');\n\napp.listen(80);\n\nfunction handler (req, res) {\n  fs.readFile(__dirname + '/index.html',\n  function (err, data) {\n    if (err) {\n      res.writeHead(500);\n      return res.end('Error loading index.html');\n    }\n\n    res.writeHead(200);\n    res.end(data);\n  });\n}\n\nio.on('connection', function (socket) {\n  socket.emit('news', { hello: 'world' });\n  socket.on('my other event', function (data) {\n    console.log(data);\n  });\n});\n```\n\n### Client (index.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io('http://localhost');\n  socket.on('news', function (data) {\n    console.log(data);\n    socket.emit('my other event', { my: 'data' });\n  });\n</script>\n```\n\n## Using with Express 3/4\n\n### Server (app.js)\n\n```js\nvar app = require('express')();\nvar server = require('http').Server(app);\nvar io = require('socket.io')(server);\n\nserver.listen(80);\n\napp.get('/', function (req, res) {\n  res.sendfile(__dirname + '/index.html');\n});\n\nio.on('connection', function (socket) {\n  socket.emit('news', { hello: 'world' });\n  socket.on('my other event', function (data) {\n    console.log(data);\n  });\n});\n```\n\n### Client (index.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io.connect('http://localhost');\n  socket.on('news', function (data) {\n    console.log(data);\n    socket.emit('my other event', { my: 'data' });\n  });\n</script>\n```\n\n## Using with Express 2.x\n\n### Server (app.js)\n\n```js\nvar app = require('express').createServer();\nvar io = require('socket.io')(app);\n\napp.listen(80);\n\napp.get('/', function (req, res) {\n  res.sendFile(__dirname + '/index.html');\n});\n\nio.on('connection', function (socket) {\n  socket.emit('news', { hello: 'world' });\n  socket.on('my other event', function (data) {\n    console.log(data);\n  });\n});\n```\n\n### Client (index.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io.connect('http://localhost');\n  socket.on('news', function (data) {\n    console.log(data);\n    socket.emit('my other event', { my: 'data' });\n  });\n</script>\n```\n\n## Sending and receiving events\n\nSocket.IO allows you to emit and receive custom events. Besides `connect`, `message` and `disconnect`, you can emit custom events:\n\n### Server\n\n```js\n// note, io(<port>) will create a http server for you\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  io.emit('this', { will: 'be received by everyone'});\n\n  socket.on('private message', function (from, msg) {\n    console.log('I received a private message by ', from, ' saying ', msg);\n  });\n\n  socket.on('disconnect', function () {\n    io.emit('user disconnected');\n  });\n});\n```\n\n## Restricting yourself to a namespace\n\nIf you have control over all the messages and events emitted for a particular application, using the default / namespace works. If you want to leverage 3rd-party code, or produce code to share with others, socket.io provides a way of namespacing a socket.\n\nThis has the benefit of `multiplexing` a single connection. Instead of socket.io using two `WebSocket` connections, it’ll use one.\n\n### Server (app.js)\n\n```js\nvar io = require('socket.io')(80);\nvar chat = io\n  .of('/chat')\n  .on('connection', function (socket) {\n    socket.emit('a message', {\n        that: 'only'\n      , '/chat': 'will get'\n    });\n    chat.emit('a message', {\n        everyone: 'in'\n      , '/chat': 'will get'\n    });\n  });\n\nvar news = io\n  .of('/news')\n  .on('connection', function (socket) {\n    socket.emit('item', { news: 'item' });\n  });\n```\n\n### Client (index.html)\n\n```html\n<script>\n  var chat = io.connect('http://localhost/chat')\n    , news = io.connect('http://localhost/news');\n  \n  chat.on('connect', function () {\n    chat.emit('hi!');\n  });\n  \n  news.on('news', function () {\n    news.emit('woot');\n  });\n</script>\n```\n\n## Sending volatile messages\n\nSometimes certain messages can be dropped. Let’s say you have an app that shows realtime tweets for the keyword `bieber`.\n\nIf a certain client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle), if it doesn’t receive ALL the tweets related to bieber your application won’t suffer.\n\nIn that case, you might want to send those messages as volatile messages.\n\n### Server\n\n```js\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  var tweets = setInterval(function () {\n    getBieberTweet(function (tweet) {\n      socket.volatile.emit('bieber tweet', tweet);\n    });\n  }, 100);\n\n  socket.on('disconnect', function () {\n    clearInterval(tweets);\n  });\n});\n```\n\n## Sending and getting data (acknowledgements)\n\nSometimes, you might want to get a callback when the client confirmed the message reception.\n\nTo do this, simply pass a function as the last parameter of `.send` or `.emit`. What’s more, when you use `.emit`, the acknowledgement is done by you, which means you can also pass data along:\n\n### Server (app.js)\n\n```js\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  socket.on('ferret', function (name, fn) {\n    fn('woot');\n  });\n});\n```\n\n### Client (index.html)\n\n```html\n<script>\n  var socket = io(); // TIP: io() with no args does auto-discovery\n  socket.on('connect', function () { // TIP: you can avoid listening on `connect` and listen on events directly too!\n    socket.emit('ferret', 'tobi', function (data) {\n      console.log(data); // data will be 'woot'\n    });\n  });\n</script>\n```\n\n## Broadcasting messages\n\nTo broadcast, simply add a `broadcast` flag to `emit` and `send` method calls. Broadcasting means sending a message to everyone else except for the socket that starts it.\n\n### Server\n\n```js\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  socket.broadcast.emit('user connected');\n});\n```\n\n## Using it just as a cross-browser WebSocket\n\nIf you just want the WebSocket semantics, you can do that too. Simply leverage `send` and listen on the `message` event:\n\n### Server (app.js)\n\n```js\nvar io = require('socket.io')(80);\n\nio.on('connection', function (socket) {\n  socket.on('message', function () { });\n  socket.on('disconnect', function () { });\n});\n```\n\n### Client (index.html)\n\n```html\n<script>\n  var socket = io('http://localhost/');\n  socket.on('connect', function () {\n    socket.send('hi');\n\n    socket.on('message', function (msg) {\n      // my msg\n    });\n  });\n</script>\n```\n\nIf you don’t care about reconnection logic and such, take a look at <a href=\"https://github.com/socketio/engine.io\">Engine.IO</a>, which is the WebSocket semantics transport layer Socket.IO uses.\n","date":"2018-07-21T05:19:36.879Z","updated":"2018-07-21T05:19:36.879Z","path":"docs/index.html","comments":1,"layout":"page","_id":"cjjxdyebf0008jgcxk5rfy9bs","content":"<h2 id=\"Installing\"><a href=\"#Installing\" class=\"headerlink\" title=\"Installing\"></a>Installing</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install socket.io</span><br></pre></td></tr></table></figure>\n<h2 id=\"Using-with-Node-http-server\"><a href=\"#Using-with-Node-http-server\" class=\"headerlink\" title=\"Using with Node http server\"></a>Using with Node http server</h2><h3 id=\"Server-app-js\"><a href=\"#Server-app-js\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer(handler)</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(app);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(__dirname + <span class=\"string\">'/index.html'</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      res.writeHead(<span class=\"number\">500</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.end(<span class=\"string\">'Error loading index.html'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">    res.end(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.emit(<span class=\"string\">'news'</span>, &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'world'</span> &#125;);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'my other event'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html\"><a href=\"#Client-index-html\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'news'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.emit(<span class=\"string\">'my other event'</span>, &#123; <span class=\"attr\">my</span>: <span class=\"string\">'data'</span> &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Using-with-Express-3-4\"><a href=\"#Using-with-Express-3-4\" class=\"headerlink\" title=\"Using with Express 3/4\"></a>Using with Express 3/4</h2><h3 id=\"Server-app-js-1\"><a href=\"#Server-app-js-1\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).Server(app);</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(server);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.sendfile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.emit(<span class=\"string\">'news'</span>, &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'world'</span> &#125;);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'my other event'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-1\"><a href=\"#Client-index-html-1\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io.connect(<span class=\"string\">'http://localhost'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'news'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.emit(<span class=\"string\">'my other event'</span>, &#123; <span class=\"attr\">my</span>: <span class=\"string\">'data'</span> &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Using-with-Express-2-x\"><a href=\"#Using-with-Express-2-x\" class=\"headerlink\" title=\"Using with Express 2.x\"></a>Using with Express 2.x</h2><h3 id=\"Server-app-js-2\"><a href=\"#Server-app-js-2\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>).createServer();</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.emit(<span class=\"string\">'news'</span>, &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'world'</span> &#125;);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'my other event'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-2\"><a href=\"#Client-index-html-2\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io.connect(<span class=\"string\">'http://localhost'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'news'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.emit(<span class=\"string\">'my other event'</span>, &#123; <span class=\"attr\">my</span>: <span class=\"string\">'data'</span> &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Sending-and-receiving-events\"><a href=\"#Sending-and-receiving-events\" class=\"headerlink\" title=\"Sending and receiving events\"></a>Sending and receiving events</h2><p>Socket.IO allows you to emit and receive custom events. Besides <code>connect</code>, <code>message</code> and <code>disconnect</code>, you can emit custom events:</p>\n<h3 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// note, io(&lt;port&gt;) will create a http server for you</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  io.emit(<span class=\"string\">'this'</span>, &#123; <span class=\"attr\">will</span>: <span class=\"string\">'be received by everyone'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.on(<span class=\"string\">'private message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">from, msg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I received a private message by '</span>, <span class=\"keyword\">from</span>, <span class=\"string\">' saying '</span>, msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    io.emit(<span class=\"string\">'user disconnected'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Restricting-yourself-to-a-namespace\"><a href=\"#Restricting-yourself-to-a-namespace\" class=\"headerlink\" title=\"Restricting yourself to a namespace\"></a>Restricting yourself to a namespace</h2><p>If you have control over all the messages and events emitted for a particular application, using the default / namespace works. If you want to leverage 3rd-party code, or produce code to share with others, socket.io provides a way of namespacing a socket.</p>\n<p>This has the benefit of <code>multiplexing</code> a single connection. Instead of socket.io using two <code>WebSocket</code> connections, it’ll use one.</p>\n<h3 id=\"Server-app-js-3\"><a href=\"#Server-app-js-3\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> chat = io</span><br><span class=\"line\">  .of(<span class=\"string\">'/chat'</span>)</span><br><span class=\"line\">  .on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    socket.emit(<span class=\"string\">'a message'</span>, &#123;</span><br><span class=\"line\">        that: <span class=\"string\">'only'</span></span><br><span class=\"line\">      , <span class=\"string\">'/chat'</span>: <span class=\"string\">'will get'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    chat.emit(<span class=\"string\">'a message'</span>, &#123;</span><br><span class=\"line\">        everyone: <span class=\"string\">'in'</span></span><br><span class=\"line\">      , <span class=\"string\">'/chat'</span>: <span class=\"string\">'will get'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> news = io</span><br><span class=\"line\">  .of(<span class=\"string\">'/news'</span>)</span><br><span class=\"line\">  .on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    socket.emit(<span class=\"string\">'item'</span>, &#123; <span class=\"attr\">news</span>: <span class=\"string\">'item'</span> &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-3\"><a href=\"#Client-index-html-3\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> chat = io.connect(<span class=\"string\">'http://localhost/chat'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    , news = io.connect(<span class=\"string\">'http://localhost/news'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">  </span></span><br><span class=\"line\"><span class=\"javascript\">  chat.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    chat.emit(<span class=\"string\">'hi!'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  </span></span><br><span class=\"line\"><span class=\"javascript\">  news.on(<span class=\"string\">'news'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    news.emit(<span class=\"string\">'woot'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Sending-volatile-messages\"><a href=\"#Sending-volatile-messages\" class=\"headerlink\" title=\"Sending volatile messages\"></a>Sending volatile messages</h2><p>Sometimes certain messages can be dropped. Let’s say you have an app that shows realtime tweets for the keyword <code>bieber</code>.</p>\n<p>If a certain client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle), if it doesn’t receive ALL the tweets related to bieber your application won’t suffer.</p>\n<p>In that case, you might want to send those messages as volatile messages.</p>\n<h3 id=\"Server-1\"><a href=\"#Server-1\" class=\"headerlink\" title=\"Server\"></a>Server</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tweets = setInterval(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    getBieberTweet(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tweet</span>) </span>&#123;</span><br><span class=\"line\">      socket.volatile.emit(<span class=\"string\">'bieber tweet'</span>, tweet);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearInterval(tweets);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Sending-and-getting-data-acknowledgements\"><a href=\"#Sending-and-getting-data-acknowledgements\" class=\"headerlink\" title=\"Sending and getting data (acknowledgements)\"></a>Sending and getting data (acknowledgements)</h2><p>Sometimes, you might want to get a callback when the client confirmed the message reception.</p>\n<p>To do this, simply pass a function as the last parameter of <code>.send</code> or <code>.emit</code>. What’s more, when you use <code>.emit</code>, the acknowledgement is done by you, which means you can also pass data along:</p>\n<h3 id=\"Server-app-js-4\"><a href=\"#Server-app-js-4\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'ferret'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, fn</span>) </span>&#123;</span><br><span class=\"line\">    fn(<span class=\"string\">'woot'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-4\"><a href=\"#Client-index-html-4\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io(); <span class=\"comment\">// TIP: io() with no args does auto-discovery</span></span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// TIP: you can avoid listening on `connect` and listen on events directly too!</span></span></span><br><span class=\"line\"><span class=\"javascript\">    socket.emit(<span class=\"string\">'ferret'</span>, <span class=\"string\">'tobi'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// data will be 'woot'</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Broadcasting-messages\"><a href=\"#Broadcasting-messages\" class=\"headerlink\" title=\"Broadcasting messages\"></a>Broadcasting messages</h2><p>To broadcast, simply add a <code>broadcast</code> flag to <code>emit</code> and <code>send</code> method calls. Broadcasting means sending a message to everyone else except for the socket that starts it.</p>\n<h3 id=\"Server-2\"><a href=\"#Server-2\" class=\"headerlink\" title=\"Server\"></a>Server</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.broadcast.emit(<span class=\"string\">'user connected'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Using-it-just-as-a-cross-browser-WebSocket\"><a href=\"#Using-it-just-as-a-cross-browser-WebSocket\" class=\"headerlink\" title=\"Using it just as a cross-browser WebSocket\"></a>Using it just as a cross-browser WebSocket</h2><p>If you just want the WebSocket semantics, you can do that too. Simply leverage <code>send</code> and listen on the <code>message</code> event:</p>\n<h3 id=\"Server-app-js-5\"><a href=\"#Server-app-js-5\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-5\"><a href=\"#Client-index-html-5\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io(<span class=\"string\">'http://localhost/'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.send(<span class=\"string\">'hi'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    socket.on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// my msg</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>If you don’t care about reconnection logic and such, take a look at <a href=\"https://github.com/socketio/engine.io\" target=\"_blank\" rel=\"noopener\">Engine.IO</a>, which is the WebSocket semantics transport layer Socket.IO uses.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Installing\"><a href=\"#Installing\" class=\"headerlink\" title=\"Installing\"></a>Installing</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install socket.io</span><br></pre></td></tr></table></figure>\n<h2 id=\"Using-with-Node-http-server\"><a href=\"#Using-with-Node-http-server\" class=\"headerlink\" title=\"Using with Node http server\"></a>Using with Node http server</h2><h3 id=\"Server-app-js\"><a href=\"#Server-app-js\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer(handler)</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(app);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(__dirname + <span class=\"string\">'/index.html'</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      res.writeHead(<span class=\"number\">500</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res.end(<span class=\"string\">'Error loading index.html'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">    res.end(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.emit(<span class=\"string\">'news'</span>, &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'world'</span> &#125;);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'my other event'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html\"><a href=\"#Client-index-html\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io(<span class=\"string\">'http://localhost'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'news'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.emit(<span class=\"string\">'my other event'</span>, &#123; <span class=\"attr\">my</span>: <span class=\"string\">'data'</span> &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Using-with-Express-3-4\"><a href=\"#Using-with-Express-3-4\" class=\"headerlink\" title=\"Using with Express 3/4\"></a>Using with Express 3/4</h2><h3 id=\"Server-app-js-1\"><a href=\"#Server-app-js-1\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).Server(app);</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(server);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.sendfile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.emit(<span class=\"string\">'news'</span>, &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'world'</span> &#125;);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'my other event'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-1\"><a href=\"#Client-index-html-1\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io.connect(<span class=\"string\">'http://localhost'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'news'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.emit(<span class=\"string\">'my other event'</span>, &#123; <span class=\"attr\">my</span>: <span class=\"string\">'data'</span> &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Using-with-Express-2-x\"><a href=\"#Using-with-Express-2-x\" class=\"headerlink\" title=\"Using with Express 2.x\"></a>Using with Express 2.x</h2><h3 id=\"Server-app-js-2\"><a href=\"#Server-app-js-2\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>).createServer();</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.emit(<span class=\"string\">'news'</span>, &#123; <span class=\"attr\">hello</span>: <span class=\"string\">'world'</span> &#125;);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'my other event'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-2\"><a href=\"#Client-index-html-2\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io.connect(<span class=\"string\">'http://localhost'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'news'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.emit(<span class=\"string\">'my other event'</span>, &#123; <span class=\"attr\">my</span>: <span class=\"string\">'data'</span> &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Sending-and-receiving-events\"><a href=\"#Sending-and-receiving-events\" class=\"headerlink\" title=\"Sending and receiving events\"></a>Sending and receiving events</h2><p>Socket.IO allows you to emit and receive custom events. Besides <code>connect</code>, <code>message</code> and <code>disconnect</code>, you can emit custom events:</p>\n<h3 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// note, io(&lt;port&gt;) will create a http server for you</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  io.emit(<span class=\"string\">'this'</span>, &#123; <span class=\"attr\">will</span>: <span class=\"string\">'be received by everyone'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.on(<span class=\"string\">'private message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">from, msg</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I received a private message by '</span>, <span class=\"keyword\">from</span>, <span class=\"string\">' saying '</span>, msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    io.emit(<span class=\"string\">'user disconnected'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Restricting-yourself-to-a-namespace\"><a href=\"#Restricting-yourself-to-a-namespace\" class=\"headerlink\" title=\"Restricting yourself to a namespace\"></a>Restricting yourself to a namespace</h2><p>If you have control over all the messages and events emitted for a particular application, using the default / namespace works. If you want to leverage 3rd-party code, or produce code to share with others, socket.io provides a way of namespacing a socket.</p>\n<p>This has the benefit of <code>multiplexing</code> a single connection. Instead of socket.io using two <code>WebSocket</code> connections, it’ll use one.</p>\n<h3 id=\"Server-app-js-3\"><a href=\"#Server-app-js-3\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> chat = io</span><br><span class=\"line\">  .of(<span class=\"string\">'/chat'</span>)</span><br><span class=\"line\">  .on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    socket.emit(<span class=\"string\">'a message'</span>, &#123;</span><br><span class=\"line\">        that: <span class=\"string\">'only'</span></span><br><span class=\"line\">      , <span class=\"string\">'/chat'</span>: <span class=\"string\">'will get'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    chat.emit(<span class=\"string\">'a message'</span>, &#123;</span><br><span class=\"line\">        everyone: <span class=\"string\">'in'</span></span><br><span class=\"line\">      , <span class=\"string\">'/chat'</span>: <span class=\"string\">'will get'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> news = io</span><br><span class=\"line\">  .of(<span class=\"string\">'/news'</span>)</span><br><span class=\"line\">  .on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">    socket.emit(<span class=\"string\">'item'</span>, &#123; <span class=\"attr\">news</span>: <span class=\"string\">'item'</span> &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-3\"><a href=\"#Client-index-html-3\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> chat = io.connect(<span class=\"string\">'http://localhost/chat'</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    , news = io.connect(<span class=\"string\">'http://localhost/news'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">  </span></span><br><span class=\"line\"><span class=\"javascript\">  chat.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    chat.emit(<span class=\"string\">'hi!'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  </span></span><br><span class=\"line\"><span class=\"javascript\">  news.on(<span class=\"string\">'news'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    news.emit(<span class=\"string\">'woot'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Sending-volatile-messages\"><a href=\"#Sending-volatile-messages\" class=\"headerlink\" title=\"Sending volatile messages\"></a>Sending volatile messages</h2><p>Sometimes certain messages can be dropped. Let’s say you have an app that shows realtime tweets for the keyword <code>bieber</code>.</p>\n<p>If a certain client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle), if it doesn’t receive ALL the tweets related to bieber your application won’t suffer.</p>\n<p>In that case, you might want to send those messages as volatile messages.</p>\n<h3 id=\"Server-1\"><a href=\"#Server-1\" class=\"headerlink\" title=\"Server\"></a>Server</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tweets = setInterval(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    getBieberTweet(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tweet</span>) </span>&#123;</span><br><span class=\"line\">      socket.volatile.emit(<span class=\"string\">'bieber tweet'</span>, tweet);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearInterval(tweets);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Sending-and-getting-data-acknowledgements\"><a href=\"#Sending-and-getting-data-acknowledgements\" class=\"headerlink\" title=\"Sending and getting data (acknowledgements)\"></a>Sending and getting data (acknowledgements)</h2><p>Sometimes, you might want to get a callback when the client confirmed the message reception.</p>\n<p>To do this, simply pass a function as the last parameter of <code>.send</code> or <code>.emit</code>. What’s more, when you use <code>.emit</code>, the acknowledgement is done by you, which means you can also pass data along:</p>\n<h3 id=\"Server-app-js-4\"><a href=\"#Server-app-js-4\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'ferret'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, fn</span>) </span>&#123;</span><br><span class=\"line\">    fn(<span class=\"string\">'woot'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-4\"><a href=\"#Client-index-html-4\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io(); <span class=\"comment\">// TIP: io() with no args does auto-discovery</span></span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// TIP: you can avoid listening on `connect` and listen on events directly too!</span></span></span><br><span class=\"line\"><span class=\"javascript\">    socket.emit(<span class=\"string\">'ferret'</span>, <span class=\"string\">'tobi'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// data will be 'woot'</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Broadcasting-messages\"><a href=\"#Broadcasting-messages\" class=\"headerlink\" title=\"Broadcasting messages\"></a>Broadcasting messages</h2><p>To broadcast, simply add a <code>broadcast</code> flag to <code>emit</code> and <code>send</code> method calls. Broadcasting means sending a message to everyone else except for the socket that starts it.</p>\n<h3 id=\"Server-2\"><a href=\"#Server-2\" class=\"headerlink\" title=\"Server\"></a>Server</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.broadcast.emit(<span class=\"string\">'user connected'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Using-it-just-as-a-cross-browser-WebSocket\"><a href=\"#Using-it-just-as-a-cross-browser-WebSocket\" class=\"headerlink\" title=\"Using it just as a cross-browser WebSocket\"></a>Using it just as a cross-browser WebSocket</h2><p>If you just want the WebSocket semantics, you can do that too. Simply leverage <code>send</code> and listen on the <code>message</code> event:</p>\n<h3 id=\"Server-app-js-5\"><a href=\"#Server-app-js-5\" class=\"headerlink\" title=\"Server (app.js)\"></a>Server (app.js)</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">socket</span>) </span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Client-index-html-5\"><a href=\"#Client-index-html-5\" class=\"headerlink\" title=\"Client (index.html)\"></a>Client (index.html)</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io(<span class=\"string\">'http://localhost/'</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.send(<span class=\"string\">'hi'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    socket.on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// my msg</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>If you don’t care about reconnection logic and such, take a look at <a href=\"https://github.com/socketio/engine.io\" target=\"_blank\" rel=\"noopener\">Engine.IO</a>, which is the WebSocket semantics transport layer Socket.IO uses.</p>\n"},{"title":"Socket.IO  —  Rooms and Namespaces","type":"docs","_content":"\n# Namespaces\n\nSocket.IO allows you to “namespace” your sockets, which essentially means assigning different *endpoints* or *paths*.\n\nThis is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels.\n\n## Default namespace\n\nWe call the default namespace `/` and it’s the one Socket.IO clients connect to by default, and the one the server listens to by default.\n\nThis namespace is identified by `io.sockets` or simply `io`:\n\n```js\n// the following two will emit to all the sockets connected to `/`\nio.sockets.emit('hi', 'everyone');\nio.emit('hi', 'everyone'); // short form\n```\n\nEach namespace emits a `connection` event that receives each `Socket` instance as a parameter\n\n```js\nio.on('connection', function(socket){\n  socket.on('disconnect', function(){ });\n});\n```\n\n## Custom namespaces\n\nTo set up a custom namespace, you can call the `of` function on the server-side:\n\n```js\nvar nsp = io.of('/my-namespace');\nnsp.on('connection', function(socket){\n  console.log('someone connected');\n});\nnsp.emit('hi', 'everyone!');\n```\n\nOn the client side, you tell Socket.IO client to connect to that namespace:\n```js\nvar socket = io('/my-namespace');\n```\n\n**Important note:** The namespace is an implementation detail of the Socket.IO protocol, and is not related to the actual URL of the underlying transport, which defaults to `/socket.io/…`.\n\n# Rooms\n\nWithin each namespace, you can also define arbitrary channels that sockets can `join` and `leave`.\n\n## Joining and leaving\n\nYou can call `join` to subscribe the socket to a given channel:\n\n```js\nio.on('connection', function(socket){\n  socket.join('some room');\n});\n```\n\nAnd then simply use `to` or `in` (they are the same) when broadcasting or emitting:\n\n```js\nio.to('some room').emit('some event');\n```\n\nTo leave a channel you call `leave` in the same fashion as `join`.\n\n## Default room\n\nEach `Socket` in Socket.IO is identified by a random, unguessable, unique identifier `Socket#id`. For your convenience, each socket automatically joins a room identified by this id.\n\nThis makes it easy to broadcast messages to other sockets:\n\n```js\nio.on('connection', function(socket){\n  socket.on('say to someone', function(id, msg){\n    socket.broadcast.to(id).emit('my message', msg);\n  });\n});\n```\n\n## Disconnection\n\nUpon disconnection, sockets `leave` all the channels they were part of automatically, and no special teardown is needed on your part.\n\n# Sending messages from the outside-world\n\nIn some cases, you might want to emit events to sockets in Socket.IO namespaces / rooms from outside the context of your Socket.IO processes.\n\nThere’s several ways to tackle this problem, like implementing your own channel to send messages into the process.\n\nTo facilitate this use case, we created two modules:\n\n- [socket.io-redis](https://github.com/socketio/socket.io-redis)\n- [socket.io-emitter](https://github.com/socketio/socket.io-emitter)\n\nBy implementing the Redis `Adapter`:\n\n```js\nvar io = require('socket.io')(3000);\nvar redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));\n```\n\nyou can then `emit` messages from any other process to any channel\n\n```js\nvar io = require('socket.io-emitter')({ host: '127.0.0.1', port: 6379 });\nsetInterval(function(){\n  io.emit('time', new Date);\n}, 5000);\n```\n","source":"docs/rooms-and-namespaces.md","raw":"title: Socket.IO  —  Rooms and Namespaces\npermalink: /docs/rooms-and-namespaces/\ntype: docs\n---\n\n# Namespaces\n\nSocket.IO allows you to “namespace” your sockets, which essentially means assigning different *endpoints* or *paths*.\n\nThis is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels.\n\n## Default namespace\n\nWe call the default namespace `/` and it’s the one Socket.IO clients connect to by default, and the one the server listens to by default.\n\nThis namespace is identified by `io.sockets` or simply `io`:\n\n```js\n// the following two will emit to all the sockets connected to `/`\nio.sockets.emit('hi', 'everyone');\nio.emit('hi', 'everyone'); // short form\n```\n\nEach namespace emits a `connection` event that receives each `Socket` instance as a parameter\n\n```js\nio.on('connection', function(socket){\n  socket.on('disconnect', function(){ });\n});\n```\n\n## Custom namespaces\n\nTo set up a custom namespace, you can call the `of` function on the server-side:\n\n```js\nvar nsp = io.of('/my-namespace');\nnsp.on('connection', function(socket){\n  console.log('someone connected');\n});\nnsp.emit('hi', 'everyone!');\n```\n\nOn the client side, you tell Socket.IO client to connect to that namespace:\n```js\nvar socket = io('/my-namespace');\n```\n\n**Important note:** The namespace is an implementation detail of the Socket.IO protocol, and is not related to the actual URL of the underlying transport, which defaults to `/socket.io/…`.\n\n# Rooms\n\nWithin each namespace, you can also define arbitrary channels that sockets can `join` and `leave`.\n\n## Joining and leaving\n\nYou can call `join` to subscribe the socket to a given channel:\n\n```js\nio.on('connection', function(socket){\n  socket.join('some room');\n});\n```\n\nAnd then simply use `to` or `in` (they are the same) when broadcasting or emitting:\n\n```js\nio.to('some room').emit('some event');\n```\n\nTo leave a channel you call `leave` in the same fashion as `join`.\n\n## Default room\n\nEach `Socket` in Socket.IO is identified by a random, unguessable, unique identifier `Socket#id`. For your convenience, each socket automatically joins a room identified by this id.\n\nThis makes it easy to broadcast messages to other sockets:\n\n```js\nio.on('connection', function(socket){\n  socket.on('say to someone', function(id, msg){\n    socket.broadcast.to(id).emit('my message', msg);\n  });\n});\n```\n\n## Disconnection\n\nUpon disconnection, sockets `leave` all the channels they were part of automatically, and no special teardown is needed on your part.\n\n# Sending messages from the outside-world\n\nIn some cases, you might want to emit events to sockets in Socket.IO namespaces / rooms from outside the context of your Socket.IO processes.\n\nThere’s several ways to tackle this problem, like implementing your own channel to send messages into the process.\n\nTo facilitate this use case, we created two modules:\n\n- [socket.io-redis](https://github.com/socketio/socket.io-redis)\n- [socket.io-emitter](https://github.com/socketio/socket.io-emitter)\n\nBy implementing the Redis `Adapter`:\n\n```js\nvar io = require('socket.io')(3000);\nvar redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));\n```\n\nyou can then `emit` messages from any other process to any channel\n\n```js\nvar io = require('socket.io-emitter')({ host: '127.0.0.1', port: 6379 });\nsetInterval(function(){\n  io.emit('time', new Date);\n}, 5000);\n```\n","date":"2018-07-21T05:38:17.145Z","updated":"2018-07-21T05:38:17.145Z","path":"/docs/rooms-and-namespaces/index.html","comments":1,"layout":"page","_id":"cjjxdyebg0009jgcx0v0g4eih","content":"<h1 id=\"Namespaces\"><a href=\"#Namespaces\" class=\"headerlink\" title=\"Namespaces\"></a>Namespaces</h1><p>Socket.IO allows you to “namespace” your sockets, which essentially means assigning different <em>endpoints</em> or <em>paths</em>.</p>\n<p>This is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels.</p>\n<h2 id=\"Default-namespace\"><a href=\"#Default-namespace\" class=\"headerlink\" title=\"Default namespace\"></a>Default namespace</h2><p>We call the default namespace <code>/</code> and it’s the one Socket.IO clients connect to by default, and the one the server listens to by default.</p>\n<p>This namespace is identified by <code>io.sockets</code> or simply <code>io</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// the following two will emit to all the sockets connected to `/`</span></span><br><span class=\"line\">io.sockets.emit(<span class=\"string\">'hi'</span>, <span class=\"string\">'everyone'</span>);</span><br><span class=\"line\">io.emit(<span class=\"string\">'hi'</span>, <span class=\"string\">'everyone'</span>); <span class=\"comment\">// short form</span></span><br></pre></td></tr></table></figure>\n<p>Each namespace emits a <code>connection</code> event that receives each <code>Socket</code> instance as a parameter</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Custom-namespaces\"><a href=\"#Custom-namespaces\" class=\"headerlink\" title=\"Custom namespaces\"></a>Custom namespaces</h2><p>To set up a custom namespace, you can call the <code>of</code> function on the server-side:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nsp = io.of(<span class=\"string\">'/my-namespace'</span>);</span><br><span class=\"line\">nsp.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'someone connected'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">nsp.emit(<span class=\"string\">'hi'</span>, <span class=\"string\">'everyone!'</span>);</span><br></pre></td></tr></table></figure>\n<p>On the client side, you tell Socket.IO client to connect to that namespace:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = io(<span class=\"string\">'/my-namespace'</span>);</span><br></pre></td></tr></table></figure></p>\n<p><strong>Important note:</strong> The namespace is an implementation detail of the Socket.IO protocol, and is not related to the actual URL of the underlying transport, which defaults to <code>/socket.io/…</code>.</p>\n<h1 id=\"Rooms\"><a href=\"#Rooms\" class=\"headerlink\" title=\"Rooms\"></a>Rooms</h1><p>Within each namespace, you can also define arbitrary channels that sockets can <code>join</code> and <code>leave</code>.</p>\n<h2 id=\"Joining-and-leaving\"><a href=\"#Joining-and-leaving\" class=\"headerlink\" title=\"Joining and leaving\"></a>Joining and leaving</h2><p>You can call <code>join</code> to subscribe the socket to a given channel:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.join(<span class=\"string\">'some room'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>And then simply use <code>to</code> or <code>in</code> (they are the same) when broadcasting or emitting:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.to(<span class=\"string\">'some room'</span>).emit(<span class=\"string\">'some event'</span>);</span><br></pre></td></tr></table></figure>\n<p>To leave a channel you call <code>leave</code> in the same fashion as <code>join</code>.</p>\n<h2 id=\"Default-room\"><a href=\"#Default-room\" class=\"headerlink\" title=\"Default room\"></a>Default room</h2><p>Each <code>Socket</code> in Socket.IO is identified by a random, unguessable, unique identifier <code>Socket#id</code>. For your convenience, each socket automatically joins a room identified by this id.</p>\n<p>This makes it easy to broadcast messages to other sockets:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'say to someone'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, msg</span>)</span>&#123;</span><br><span class=\"line\">    socket.broadcast.to(id).emit(<span class=\"string\">'my message'</span>, msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Disconnection\"><a href=\"#Disconnection\" class=\"headerlink\" title=\"Disconnection\"></a>Disconnection</h2><p>Upon disconnection, sockets <code>leave</code> all the channels they were part of automatically, and no special teardown is needed on your part.</p>\n<h1 id=\"Sending-messages-from-the-outside-world\"><a href=\"#Sending-messages-from-the-outside-world\" class=\"headerlink\" title=\"Sending messages from the outside-world\"></a>Sending messages from the outside-world</h1><p>In some cases, you might want to emit events to sockets in Socket.IO namespaces / rooms from outside the context of your Socket.IO processes.</p>\n<p>There’s several ways to tackle this problem, like implementing your own channel to send messages into the process.</p>\n<p>To facilitate this use case, we created two modules:</p>\n<ul>\n<li><a href=\"https://github.com/socketio/socket.io-redis\" target=\"_blank\" rel=\"noopener\">socket.io-redis</a></li>\n<li><a href=\"https://github.com/socketio/socket.io-emitter\" target=\"_blank\" rel=\"noopener\">socket.io-emitter</a></li>\n</ul>\n<p>By implementing the Redis <code>Adapter</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-redis'</span>);</span><br><span class=\"line\">io.adapter(redis(&#123; <span class=\"attr\">host</span>: <span class=\"string\">'localhost'</span>, <span class=\"attr\">port</span>: <span class=\"number\">6379</span> &#125;));</span><br></pre></td></tr></table></figure>\n<p>you can then <code>emit</code> messages from any other process to any channel</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-emitter'</span>)(&#123; <span class=\"attr\">host</span>: <span class=\"string\">'127.0.0.1'</span>, <span class=\"attr\">port</span>: <span class=\"number\">6379</span> &#125;);</span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  io.emit(<span class=\"string\">'time'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Namespaces\"><a href=\"#Namespaces\" class=\"headerlink\" title=\"Namespaces\"></a>Namespaces</h1><p>Socket.IO allows you to “namespace” your sockets, which essentially means assigning different <em>endpoints</em> or <em>paths</em>.</p>\n<p>This is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels.</p>\n<h2 id=\"Default-namespace\"><a href=\"#Default-namespace\" class=\"headerlink\" title=\"Default namespace\"></a>Default namespace</h2><p>We call the default namespace <code>/</code> and it’s the one Socket.IO clients connect to by default, and the one the server listens to by default.</p>\n<p>This namespace is identified by <code>io.sockets</code> or simply <code>io</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// the following two will emit to all the sockets connected to `/`</span></span><br><span class=\"line\">io.sockets.emit(<span class=\"string\">'hi'</span>, <span class=\"string\">'everyone'</span>);</span><br><span class=\"line\">io.emit(<span class=\"string\">'hi'</span>, <span class=\"string\">'everyone'</span>); <span class=\"comment\">// short form</span></span><br></pre></td></tr></table></figure>\n<p>Each namespace emits a <code>connection</code> event that receives each <code>Socket</code> instance as a parameter</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Custom-namespaces\"><a href=\"#Custom-namespaces\" class=\"headerlink\" title=\"Custom namespaces\"></a>Custom namespaces</h2><p>To set up a custom namespace, you can call the <code>of</code> function on the server-side:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nsp = io.of(<span class=\"string\">'/my-namespace'</span>);</span><br><span class=\"line\">nsp.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'someone connected'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">nsp.emit(<span class=\"string\">'hi'</span>, <span class=\"string\">'everyone!'</span>);</span><br></pre></td></tr></table></figure>\n<p>On the client side, you tell Socket.IO client to connect to that namespace:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = io(<span class=\"string\">'/my-namespace'</span>);</span><br></pre></td></tr></table></figure></p>\n<p><strong>Important note:</strong> The namespace is an implementation detail of the Socket.IO protocol, and is not related to the actual URL of the underlying transport, which defaults to <code>/socket.io/…</code>.</p>\n<h1 id=\"Rooms\"><a href=\"#Rooms\" class=\"headerlink\" title=\"Rooms\"></a>Rooms</h1><p>Within each namespace, you can also define arbitrary channels that sockets can <code>join</code> and <code>leave</code>.</p>\n<h2 id=\"Joining-and-leaving\"><a href=\"#Joining-and-leaving\" class=\"headerlink\" title=\"Joining and leaving\"></a>Joining and leaving</h2><p>You can call <code>join</code> to subscribe the socket to a given channel:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.join(<span class=\"string\">'some room'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>And then simply use <code>to</code> or <code>in</code> (they are the same) when broadcasting or emitting:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.to(<span class=\"string\">'some room'</span>).emit(<span class=\"string\">'some event'</span>);</span><br></pre></td></tr></table></figure>\n<p>To leave a channel you call <code>leave</code> in the same fashion as <code>join</code>.</p>\n<h2 id=\"Default-room\"><a href=\"#Default-room\" class=\"headerlink\" title=\"Default room\"></a>Default room</h2><p>Each <code>Socket</code> in Socket.IO is identified by a random, unguessable, unique identifier <code>Socket#id</code>. For your convenience, each socket automatically joins a room identified by this id.</p>\n<p>This makes it easy to broadcast messages to other sockets:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'say to someone'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id, msg</span>)</span>&#123;</span><br><span class=\"line\">    socket.broadcast.to(id).emit(<span class=\"string\">'my message'</span>, msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Disconnection\"><a href=\"#Disconnection\" class=\"headerlink\" title=\"Disconnection\"></a>Disconnection</h2><p>Upon disconnection, sockets <code>leave</code> all the channels they were part of automatically, and no special teardown is needed on your part.</p>\n<h1 id=\"Sending-messages-from-the-outside-world\"><a href=\"#Sending-messages-from-the-outside-world\" class=\"headerlink\" title=\"Sending messages from the outside-world\"></a>Sending messages from the outside-world</h1><p>In some cases, you might want to emit events to sockets in Socket.IO namespaces / rooms from outside the context of your Socket.IO processes.</p>\n<p>There’s several ways to tackle this problem, like implementing your own channel to send messages into the process.</p>\n<p>To facilitate this use case, we created two modules:</p>\n<ul>\n<li><a href=\"https://github.com/socketio/socket.io-redis\" target=\"_blank\" rel=\"noopener\">socket.io-redis</a></li>\n<li><a href=\"https://github.com/socketio/socket.io-emitter\" target=\"_blank\" rel=\"noopener\">socket.io-emitter</a></li>\n</ul>\n<p>By implementing the Redis <code>Adapter</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-redis'</span>);</span><br><span class=\"line\">io.adapter(redis(&#123; <span class=\"attr\">host</span>: <span class=\"string\">'localhost'</span>, <span class=\"attr\">port</span>: <span class=\"number\">6379</span> &#125;));</span><br></pre></td></tr></table></figure>\n<p>you can then <code>emit</code> messages from any other process to any channel</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-emitter'</span>)(&#123; <span class=\"attr\">host</span>: <span class=\"string\">'127.0.0.1'</span>, <span class=\"attr\">port</span>: <span class=\"number\">6379</span> &#125;);</span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  io.emit(<span class=\"string\">'time'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>);</span><br></pre></td></tr></table></figure>\n"},{"title":"Socket.IO  —  Migrating from 0.9","type":"docs","_content":"\nFor most applications, the transition to 1.0 should be completely seamless and devoid of any hiccups. That said, we’ve done some work to streamline some APIs, and we have changed some internals, so this is a recommended read for most existing users.\n\n## Authentication differences\n\n### Socket.io uses middleware now\n\nYou can give a Socket.io server arbitrary functions via `io.use()` that are run when a socket is created. Check out this example:\n\n```js\nvar srv = require('http').createServer();\nvar io = require('socket.io')(srv);\nvar run = 0;\nio.use(function(socket, next){\n  run++; // 0 -> 1\n  next();\n});\nio.use(function(socket, next) {\n  run++; // 1 -> 2\n  next();\n});\nvar socket = require('socket.io-client')();\nsocket.on('connect', function(){\n  // run == 2 at this time\n});\n```\n\n### … so its cleaner to do auth via middleware now\n\nThe old `io.set()` and `io.get()` methods are deprecated and only supported for backwards compatibility. Here is a translation of an old authorization example into middleware-style.\n\n```js\nio.set('authorization', function (handshakeData, callback) {\n  // make sure the handshake data looks good\n  callback(null, true); // error first, 'authorized' boolean second \n});\n```\n\nvs.\n\n```js\nio.use(function(socket, next) {\n  var handshakeData = socket.request;\n  // make sure the handshake data looks good as before\n  // if error do this:\n    // next(new Error('not authorized'));\n  // else just call next\n  next();\n});\n```\n\n### Namespace authorization?\n\n````js\nio.of('/namespace').use(function(socket, next) {\n  var handshakeData = socket.request;\n  next();\n});\n```\n\n## Log differences\n\n### Logging is now based on debug\n\nTo print all debug logging, set the environment variable DEBUG to *. ie: `DEBUG=* node index.js`\n\nTo print only socket.io related logging: `DEBUG=socket.io:* node index.js`.\n\nTo print logging only from the socket object: `DEBUG=socket.io:socket node index.js`.\n\nThis pattern should hopefully be making sense at this point. The names of the files in socket.io/lib are equivalent to their debug names.\n\nDebug also works in the browser; logs are persisted to localstorage.\n\nTo use: open the developer console and type `localStorage.debug = 'socket.io:*'` (or any debug level) and then refresh the page. Everything is logged until you run `localStorage.debug = ''`\n\nSee more at the debug documentation [here](https://www.npmjs.org/package/debug).\n\n## Shortcuts\n\nIn general there are some new shortcuts for common things. The old versions should still work, but shortcuts are nice.\n\n### Broadcasting to all clients in default namespace\n\nPreviously:\n\n```js\nio.sockets.emit('eventname', 'eventdata');\n```\n\nNow:\n\n```js\nio.emit('eventname', 'eventdata');\n```\n\nNeat. Note that in both cases, these messages reach all clients connected to the default ‘/’ namespace, but not clients in other namespaces.\n\n### Starting the server\n\nPreviously:\n\n```js\nvar io = require('socket.io');\nvar socket = io.listen(80, { /* options */ });\n```\n\nNow:\n\n```js\nvar io = require('socket.io');\nvar socket = io({ /* options */ });\n```\n\n## Configuration differences\n\n### io.set is gone\n\nInstead do configuration in server initialization like this:\n\n```js\nvar socket = require('socket.io')({\n  // options go here\n});\n```\n\nOptions like log-level are gone. `io.set('transports')`, `io.set('heartbeat interval')`, `io.set('heartbeat timeout'`, and `io.set('resource')` are still supported for backwards compatibility.\n\n### Setting resource path\n\nThe previous `resource` option is equivalent to the new `path` option, but needs a `/` in the beginning. For example, the following configuration:\n\n```js\nvar socket = io.connect('localhost:3000', {\n  'resource': 'path/to/socket.io';\n});\n```\n\nbecomes:\n\n```js\nvar socket = io.connect('localhost:3000', {\n  'path': '/path/to/socket.io';\n});\n```\n\n## Parser / Protocol differences\n\nThis is only relevant for updating things like socket.io implementations in other languages, custom socket.io clients, etc.\n\n### Difference 1 – packet encoding\n\nParsing is now class based and asynchronous. Instead of returning a single encoded string, encode calls callback with an array of encodings as the only argument. Each encoding should be written to the transport in order. This is more flexible and makes binary data transport work. Here’s an example:\n\n```js\nvar encoding = parser.encode(packet);\nconsole.log(encoding); // fully encoded packet`\n```\n\nvs.\n\n```js\nvar encoder = new parser.Encoder();\nencoder.encode(packet, function(encodings) {\n  for (var i = 0; i &lt; encodings.length; i++) {\n    console.log(encodings[i]); // encoded parts of the packet\n  }\n});\n```\n\n### Difference 2 – packet decoding\n\nDecoding takes things a step further and is event-based. This is done because some objects (binary-containing) are both encoded and decoded in multiple parts. This example should help:\n\n```js\nvar packet = parser.decode(decoding);\nconsole.log(packet); // formed socket.io packet to handle\n```\n\nvs.\n\n```js\nvar decoder = new parser.Decoder();\ndecoder.on('decoded', function(packet) {\n  console.log(packet); // formed socket.io packet to handle\n});\ndecoder.add(encodings[0]); // say encodings is array of two encodings received from transport\ndecoder.add(encodings[1]); // after adding the last element, 'decoded' is emitted from decoder\n```\n","source":"docs/migrating-from-0-9.md","raw":"title: Socket.IO  —  Migrating from 0.9\npermalink: /docs/migrating-from-0-9/\ntype: docs\n---\n\nFor most applications, the transition to 1.0 should be completely seamless and devoid of any hiccups. That said, we’ve done some work to streamline some APIs, and we have changed some internals, so this is a recommended read for most existing users.\n\n## Authentication differences\n\n### Socket.io uses middleware now\n\nYou can give a Socket.io server arbitrary functions via `io.use()` that are run when a socket is created. Check out this example:\n\n```js\nvar srv = require('http').createServer();\nvar io = require('socket.io')(srv);\nvar run = 0;\nio.use(function(socket, next){\n  run++; // 0 -> 1\n  next();\n});\nio.use(function(socket, next) {\n  run++; // 1 -> 2\n  next();\n});\nvar socket = require('socket.io-client')();\nsocket.on('connect', function(){\n  // run == 2 at this time\n});\n```\n\n### … so its cleaner to do auth via middleware now\n\nThe old `io.set()` and `io.get()` methods are deprecated and only supported for backwards compatibility. Here is a translation of an old authorization example into middleware-style.\n\n```js\nio.set('authorization', function (handshakeData, callback) {\n  // make sure the handshake data looks good\n  callback(null, true); // error first, 'authorized' boolean second \n});\n```\n\nvs.\n\n```js\nio.use(function(socket, next) {\n  var handshakeData = socket.request;\n  // make sure the handshake data looks good as before\n  // if error do this:\n    // next(new Error('not authorized'));\n  // else just call next\n  next();\n});\n```\n\n### Namespace authorization?\n\n````js\nio.of('/namespace').use(function(socket, next) {\n  var handshakeData = socket.request;\n  next();\n});\n```\n\n## Log differences\n\n### Logging is now based on debug\n\nTo print all debug logging, set the environment variable DEBUG to *. ie: `DEBUG=* node index.js`\n\nTo print only socket.io related logging: `DEBUG=socket.io:* node index.js`.\n\nTo print logging only from the socket object: `DEBUG=socket.io:socket node index.js`.\n\nThis pattern should hopefully be making sense at this point. The names of the files in socket.io/lib are equivalent to their debug names.\n\nDebug also works in the browser; logs are persisted to localstorage.\n\nTo use: open the developer console and type `localStorage.debug = 'socket.io:*'` (or any debug level) and then refresh the page. Everything is logged until you run `localStorage.debug = ''`\n\nSee more at the debug documentation [here](https://www.npmjs.org/package/debug).\n\n## Shortcuts\n\nIn general there are some new shortcuts for common things. The old versions should still work, but shortcuts are nice.\n\n### Broadcasting to all clients in default namespace\n\nPreviously:\n\n```js\nio.sockets.emit('eventname', 'eventdata');\n```\n\nNow:\n\n```js\nio.emit('eventname', 'eventdata');\n```\n\nNeat. Note that in both cases, these messages reach all clients connected to the default ‘/’ namespace, but not clients in other namespaces.\n\n### Starting the server\n\nPreviously:\n\n```js\nvar io = require('socket.io');\nvar socket = io.listen(80, { /* options */ });\n```\n\nNow:\n\n```js\nvar io = require('socket.io');\nvar socket = io({ /* options */ });\n```\n\n## Configuration differences\n\n### io.set is gone\n\nInstead do configuration in server initialization like this:\n\n```js\nvar socket = require('socket.io')({\n  // options go here\n});\n```\n\nOptions like log-level are gone. `io.set('transports')`, `io.set('heartbeat interval')`, `io.set('heartbeat timeout'`, and `io.set('resource')` are still supported for backwards compatibility.\n\n### Setting resource path\n\nThe previous `resource` option is equivalent to the new `path` option, but needs a `/` in the beginning. For example, the following configuration:\n\n```js\nvar socket = io.connect('localhost:3000', {\n  'resource': 'path/to/socket.io';\n});\n```\n\nbecomes:\n\n```js\nvar socket = io.connect('localhost:3000', {\n  'path': '/path/to/socket.io';\n});\n```\n\n## Parser / Protocol differences\n\nThis is only relevant for updating things like socket.io implementations in other languages, custom socket.io clients, etc.\n\n### Difference 1 – packet encoding\n\nParsing is now class based and asynchronous. Instead of returning a single encoded string, encode calls callback with an array of encodings as the only argument. Each encoding should be written to the transport in order. This is more flexible and makes binary data transport work. Here’s an example:\n\n```js\nvar encoding = parser.encode(packet);\nconsole.log(encoding); // fully encoded packet`\n```\n\nvs.\n\n```js\nvar encoder = new parser.Encoder();\nencoder.encode(packet, function(encodings) {\n  for (var i = 0; i &lt; encodings.length; i++) {\n    console.log(encodings[i]); // encoded parts of the packet\n  }\n});\n```\n\n### Difference 2 – packet decoding\n\nDecoding takes things a step further and is event-based. This is done because some objects (binary-containing) are both encoded and decoded in multiple parts. This example should help:\n\n```js\nvar packet = parser.decode(decoding);\nconsole.log(packet); // formed socket.io packet to handle\n```\n\nvs.\n\n```js\nvar decoder = new parser.Decoder();\ndecoder.on('decoded', function(packet) {\n  console.log(packet); // formed socket.io packet to handle\n});\ndecoder.add(encodings[0]); // say encodings is array of two encodings received from transport\ndecoder.add(encodings[1]); // after adding the last element, 'decoded' is emitted from decoder\n```\n","date":"2018-07-21T05:50:30.830Z","updated":"2018-07-21T05:50:30.830Z","path":"/docs/migrating-from-0-9/index.html","comments":1,"layout":"page","_id":"cjjxdyebh000ajgcxtayfp7xv","content":"<p>For most applications, the transition to 1.0 should be completely seamless and devoid of any hiccups. That said, we’ve done some work to streamline some APIs, and we have changed some internals, so this is a recommended read for most existing users.</p>\n<h2 id=\"Authentication-differences\"><a href=\"#Authentication-differences\" class=\"headerlink\" title=\"Authentication differences\"></a>Authentication differences</h2><h3 id=\"Socket-io-uses-middleware-now\"><a href=\"#Socket-io-uses-middleware-now\" class=\"headerlink\" title=\"Socket.io uses middleware now\"></a>Socket.io uses middleware now</h3><p>You can give a Socket.io server arbitrary functions via <code>io.use()</code> that are run when a socket is created. Check out this example:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> srv = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(srv);</span><br><span class=\"line\"><span class=\"keyword\">var</span> run = <span class=\"number\">0</span>;</span><br><span class=\"line\">io.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket, next</span>)</span>&#123;</span><br><span class=\"line\">  run++; <span class=\"comment\">// 0 -&gt; 1</span></span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">io.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket, next</span>) </span>&#123;</span><br><span class=\"line\">  run++; <span class=\"comment\">// 1 -&gt; 2</span></span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> socket = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-client'</span>)();</span><br><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// run == 2 at this time</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"…-so-its-cleaner-to-do-auth-via-middleware-now\"><a href=\"#…-so-its-cleaner-to-do-auth-via-middleware-now\" class=\"headerlink\" title=\"… so its cleaner to do auth via middleware now\"></a>… so its cleaner to do auth via middleware now</h3><p>The old <code>io.set()</code> and <code>io.get()</code> methods are deprecated and only supported for backwards compatibility. Here is a translation of an old authorization example into middleware-style.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.set(<span class=\"string\">'authorization'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">handshakeData, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// make sure the handshake data looks good</span></span><br><span class=\"line\">  callback(<span class=\"literal\">null</span>, <span class=\"literal\">true</span>); <span class=\"comment\">// error first, 'authorized' boolean second </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>vs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> handshakeData = socket.request;</span><br><span class=\"line\">  <span class=\"comment\">// make sure the handshake data looks good as before</span></span><br><span class=\"line\">  <span class=\"comment\">// if error do this:</span></span><br><span class=\"line\">    <span class=\"comment\">// next(new Error('not authorized'));</span></span><br><span class=\"line\">  <span class=\"comment\">// else just call next</span></span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Namespace-authorization\"><a href=\"#Namespace-authorization\" class=\"headerlink\" title=\"Namespace authorization?\"></a>Namespace authorization?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.of(&apos;/namespace&apos;).use(function(socket, next) &#123;</span><br><span class=\"line\">  var handshakeData = socket.request;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Log-differences\"><a href=\"#Log-differences\" class=\"headerlink\" title=\"Log differences\"></a>Log differences</h2><h3 id=\"Logging-is-now-based-on-debug\"><a href=\"#Logging-is-now-based-on-debug\" class=\"headerlink\" title=\"Logging is now based on debug\"></a>Logging is now based on debug</h3><p>To print all debug logging, set the environment variable DEBUG to <em>. ie: `DEBUG=</em> node index.js`</p>\n<p>To print only socket.io related logging: <code>DEBUG=socket.io:* node index.js</code>.</p>\n<p>To print logging only from the socket object: <code>DEBUG=socket.io:socket node index.js</code>.</p>\n<p>This pattern should hopefully be making sense at this point. The names of the files in socket.io/lib are equivalent to their debug names.</p>\n<p>Debug also works in the browser; logs are persisted to localstorage.</p>\n<p>To use: open the developer console and type <code>localStorage.debug = &#39;socket.io:*&#39;</code> (or any debug level) and then refresh the page. Everything is logged until you run <code>localStorage.debug = &#39;&#39;</code></p>\n<p>See more at the debug documentation <a href=\"https://www.npmjs.org/package/debug\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<h2 id=\"Shortcuts\"><a href=\"#Shortcuts\" class=\"headerlink\" title=\"Shortcuts\"></a>Shortcuts</h2><p>In general there are some new shortcuts for common things. The old versions should still work, but shortcuts are nice.</p>\n<h3 id=\"Broadcasting-to-all-clients-in-default-namespace\"><a href=\"#Broadcasting-to-all-clients-in-default-namespace\" class=\"headerlink\" title=\"Broadcasting to all clients in default namespace\"></a>Broadcasting to all clients in default namespace</h3><p>Previously:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.sockets.emit(<span class=\"string\">'eventname'</span>, <span class=\"string\">'eventdata'</span>);</span><br></pre></td></tr></table></figure>\n<p>Now:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.emit(<span class=\"string\">'eventname'</span>, <span class=\"string\">'eventdata'</span>);</span><br></pre></td></tr></table></figure>\n<p>Neat. Note that in both cases, these messages reach all clients connected to the default ‘/’ namespace, but not clients in other namespaces.</p>\n<h3 id=\"Starting-the-server\"><a href=\"#Starting-the-server\" class=\"headerlink\" title=\"Starting the server\"></a>Starting the server</h3><p>Previously:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> socket = io.listen(<span class=\"number\">80</span>, &#123; <span class=\"comment\">/* options */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>Now:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> socket = io(&#123; <span class=\"comment\">/* options */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Configuration-differences\"><a href=\"#Configuration-differences\" class=\"headerlink\" title=\"Configuration differences\"></a>Configuration differences</h2><h3 id=\"io-set-is-gone\"><a href=\"#io-set-is-gone\" class=\"headerlink\" title=\"io.set is gone\"></a>io.set is gone</h3><p>Instead do configuration in server initialization like this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// options go here</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Options like log-level are gone. <code>io.set(&#39;transports&#39;)</code>, <code>io.set(&#39;heartbeat interval&#39;)</code>, <code>io.set(&#39;heartbeat timeout&#39;</code>, and <code>io.set(&#39;resource&#39;)</code> are still supported for backwards compatibility.</p>\n<h3 id=\"Setting-resource-path\"><a href=\"#Setting-resource-path\" class=\"headerlink\" title=\"Setting resource path\"></a>Setting resource path</h3><p>The previous <code>resource</code> option is equivalent to the new <code>path</code> option, but needs a <code>/</code> in the beginning. For example, the following configuration:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = io.connect(<span class=\"string\">'localhost:3000'</span>, &#123;</span><br><span class=\"line\">  <span class=\"string\">'resource'</span>: <span class=\"string\">'path/to/socket.io'</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>becomes:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = io.connect(<span class=\"string\">'localhost:3000'</span>, &#123;</span><br><span class=\"line\">  <span class=\"string\">'path'</span>: <span class=\"string\">'/path/to/socket.io'</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Parser-Protocol-differences\"><a href=\"#Parser-Protocol-differences\" class=\"headerlink\" title=\"Parser / Protocol differences\"></a>Parser / Protocol differences</h2><p>This is only relevant for updating things like socket.io implementations in other languages, custom socket.io clients, etc.</p>\n<h3 id=\"Difference-1-–-packet-encoding\"><a href=\"#Difference-1-–-packet-encoding\" class=\"headerlink\" title=\"Difference 1 – packet encoding\"></a>Difference 1 – packet encoding</h3><p>Parsing is now class based and asynchronous. Instead of returning a single encoded string, encode calls callback with an array of encodings as the only argument. Each encoding should be written to the transport in order. This is more flexible and makes binary data transport work. Here’s an example:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> encoding = parser.encode(packet);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(encoding); <span class=\"comment\">// fully encoded packet`</span></span><br></pre></td></tr></table></figure>\n<p>vs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> encoder = <span class=\"keyword\">new</span> parser.Encoder();</span><br><span class=\"line\">encoder.encode(packet, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">encodings</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; encodings.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(encodings[i]); <span class=\"comment\">// encoded parts of the packet</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Difference-2-–-packet-decoding\"><a href=\"#Difference-2-–-packet-decoding\" class=\"headerlink\" title=\"Difference 2 – packet decoding\"></a>Difference 2 – packet decoding</h3><p>Decoding takes things a step further and is event-based. This is done because some objects (binary-containing) are both encoded and decoded in multiple parts. This example should help:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> packet = parser.decode(decoding);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(packet); <span class=\"comment\">// formed socket.io packet to handle</span></span><br></pre></td></tr></table></figure>\n<p>vs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> decoder = <span class=\"keyword\">new</span> parser.Decoder();</span><br><span class=\"line\">decoder.on(<span class=\"string\">'decoded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">packet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(packet); <span class=\"comment\">// formed socket.io packet to handle</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">decoder.add(encodings[<span class=\"number\">0</span>]); <span class=\"comment\">// say encodings is array of two encodings received from transport</span></span><br><span class=\"line\">decoder.add(encodings[<span class=\"number\">1</span>]); <span class=\"comment\">// after adding the last element, 'decoded' is emitted from decoder</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>For most applications, the transition to 1.0 should be completely seamless and devoid of any hiccups. That said, we’ve done some work to streamline some APIs, and we have changed some internals, so this is a recommended read for most existing users.</p>\n<h2 id=\"Authentication-differences\"><a href=\"#Authentication-differences\" class=\"headerlink\" title=\"Authentication differences\"></a>Authentication differences</h2><h3 id=\"Socket-io-uses-middleware-now\"><a href=\"#Socket-io-uses-middleware-now\" class=\"headerlink\" title=\"Socket.io uses middleware now\"></a>Socket.io uses middleware now</h3><p>You can give a Socket.io server arbitrary functions via <code>io.use()</code> that are run when a socket is created. Check out this example:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> srv = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(srv);</span><br><span class=\"line\"><span class=\"keyword\">var</span> run = <span class=\"number\">0</span>;</span><br><span class=\"line\">io.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket, next</span>)</span>&#123;</span><br><span class=\"line\">  run++; <span class=\"comment\">// 0 -&gt; 1</span></span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">io.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket, next</span>) </span>&#123;</span><br><span class=\"line\">  run++; <span class=\"comment\">// 1 -&gt; 2</span></span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> socket = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-client'</span>)();</span><br><span class=\"line\">socket.on(<span class=\"string\">'connect'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// run == 2 at this time</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"…-so-its-cleaner-to-do-auth-via-middleware-now\"><a href=\"#…-so-its-cleaner-to-do-auth-via-middleware-now\" class=\"headerlink\" title=\"… so its cleaner to do auth via middleware now\"></a>… so its cleaner to do auth via middleware now</h3><p>The old <code>io.set()</code> and <code>io.get()</code> methods are deprecated and only supported for backwards compatibility. Here is a translation of an old authorization example into middleware-style.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.set(<span class=\"string\">'authorization'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">handshakeData, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// make sure the handshake data looks good</span></span><br><span class=\"line\">  callback(<span class=\"literal\">null</span>, <span class=\"literal\">true</span>); <span class=\"comment\">// error first, 'authorized' boolean second </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>vs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> handshakeData = socket.request;</span><br><span class=\"line\">  <span class=\"comment\">// make sure the handshake data looks good as before</span></span><br><span class=\"line\">  <span class=\"comment\">// if error do this:</span></span><br><span class=\"line\">    <span class=\"comment\">// next(new Error('not authorized'));</span></span><br><span class=\"line\">  <span class=\"comment\">// else just call next</span></span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Namespace-authorization\"><a href=\"#Namespace-authorization\" class=\"headerlink\" title=\"Namespace authorization?\"></a>Namespace authorization?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.of(&apos;/namespace&apos;).use(function(socket, next) &#123;</span><br><span class=\"line\">  var handshakeData = socket.request;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Log-differences\"><a href=\"#Log-differences\" class=\"headerlink\" title=\"Log differences\"></a>Log differences</h2><h3 id=\"Logging-is-now-based-on-debug\"><a href=\"#Logging-is-now-based-on-debug\" class=\"headerlink\" title=\"Logging is now based on debug\"></a>Logging is now based on debug</h3><p>To print all debug logging, set the environment variable DEBUG to <em>. ie: `DEBUG=</em> node index.js`</p>\n<p>To print only socket.io related logging: <code>DEBUG=socket.io:* node index.js</code>.</p>\n<p>To print logging only from the socket object: <code>DEBUG=socket.io:socket node index.js</code>.</p>\n<p>This pattern should hopefully be making sense at this point. The names of the files in socket.io/lib are equivalent to their debug names.</p>\n<p>Debug also works in the browser; logs are persisted to localstorage.</p>\n<p>To use: open the developer console and type <code>localStorage.debug = &#39;socket.io:*&#39;</code> (or any debug level) and then refresh the page. Everything is logged until you run <code>localStorage.debug = &#39;&#39;</code></p>\n<p>See more at the debug documentation <a href=\"https://www.npmjs.org/package/debug\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<h2 id=\"Shortcuts\"><a href=\"#Shortcuts\" class=\"headerlink\" title=\"Shortcuts\"></a>Shortcuts</h2><p>In general there are some new shortcuts for common things. The old versions should still work, but shortcuts are nice.</p>\n<h3 id=\"Broadcasting-to-all-clients-in-default-namespace\"><a href=\"#Broadcasting-to-all-clients-in-default-namespace\" class=\"headerlink\" title=\"Broadcasting to all clients in default namespace\"></a>Broadcasting to all clients in default namespace</h3><p>Previously:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.sockets.emit(<span class=\"string\">'eventname'</span>, <span class=\"string\">'eventdata'</span>);</span><br></pre></td></tr></table></figure>\n<p>Now:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.emit(<span class=\"string\">'eventname'</span>, <span class=\"string\">'eventdata'</span>);</span><br></pre></td></tr></table></figure>\n<p>Neat. Note that in both cases, these messages reach all clients connected to the default ‘/’ namespace, but not clients in other namespaces.</p>\n<h3 id=\"Starting-the-server\"><a href=\"#Starting-the-server\" class=\"headerlink\" title=\"Starting the server\"></a>Starting the server</h3><p>Previously:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> socket = io.listen(<span class=\"number\">80</span>, &#123; <span class=\"comment\">/* options */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>Now:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> socket = io(&#123; <span class=\"comment\">/* options */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Configuration-differences\"><a href=\"#Configuration-differences\" class=\"headerlink\" title=\"Configuration differences\"></a>Configuration differences</h2><h3 id=\"io-set-is-gone\"><a href=\"#io-set-is-gone\" class=\"headerlink\" title=\"io.set is gone\"></a>io.set is gone</h3><p>Instead do configuration in server initialization like this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// options go here</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Options like log-level are gone. <code>io.set(&#39;transports&#39;)</code>, <code>io.set(&#39;heartbeat interval&#39;)</code>, <code>io.set(&#39;heartbeat timeout&#39;</code>, and <code>io.set(&#39;resource&#39;)</code> are still supported for backwards compatibility.</p>\n<h3 id=\"Setting-resource-path\"><a href=\"#Setting-resource-path\" class=\"headerlink\" title=\"Setting resource path\"></a>Setting resource path</h3><p>The previous <code>resource</code> option is equivalent to the new <code>path</code> option, but needs a <code>/</code> in the beginning. For example, the following configuration:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = io.connect(<span class=\"string\">'localhost:3000'</span>, &#123;</span><br><span class=\"line\">  <span class=\"string\">'resource'</span>: <span class=\"string\">'path/to/socket.io'</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>becomes:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = io.connect(<span class=\"string\">'localhost:3000'</span>, &#123;</span><br><span class=\"line\">  <span class=\"string\">'path'</span>: <span class=\"string\">'/path/to/socket.io'</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Parser-Protocol-differences\"><a href=\"#Parser-Protocol-differences\" class=\"headerlink\" title=\"Parser / Protocol differences\"></a>Parser / Protocol differences</h2><p>This is only relevant for updating things like socket.io implementations in other languages, custom socket.io clients, etc.</p>\n<h3 id=\"Difference-1-–-packet-encoding\"><a href=\"#Difference-1-–-packet-encoding\" class=\"headerlink\" title=\"Difference 1 – packet encoding\"></a>Difference 1 – packet encoding</h3><p>Parsing is now class based and asynchronous. Instead of returning a single encoded string, encode calls callback with an array of encodings as the only argument. Each encoding should be written to the transport in order. This is more flexible and makes binary data transport work. Here’s an example:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> encoding = parser.encode(packet);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(encoding); <span class=\"comment\">// fully encoded packet`</span></span><br></pre></td></tr></table></figure>\n<p>vs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> encoder = <span class=\"keyword\">new</span> parser.Encoder();</span><br><span class=\"line\">encoder.encode(packet, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">encodings</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; encodings.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(encodings[i]); <span class=\"comment\">// encoded parts of the packet</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Difference-2-–-packet-decoding\"><a href=\"#Difference-2-–-packet-decoding\" class=\"headerlink\" title=\"Difference 2 – packet decoding\"></a>Difference 2 – packet decoding</h3><p>Decoding takes things a step further and is event-based. This is done because some objects (binary-containing) are both encoded and decoded in multiple parts. This example should help:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> packet = parser.decode(decoding);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(packet); <span class=\"comment\">// formed socket.io packet to handle</span></span><br></pre></td></tr></table></figure>\n<p>vs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> decoder = <span class=\"keyword\">new</span> parser.Decoder();</span><br><span class=\"line\">decoder.on(<span class=\"string\">'decoded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">packet</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(packet); <span class=\"comment\">// formed socket.io packet to handle</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">decoder.add(encodings[<span class=\"number\">0</span>]); <span class=\"comment\">// say encodings is array of two encodings received from transport</span></span><br><span class=\"line\">decoder.add(encodings[<span class=\"number\">1</span>]); <span class=\"comment\">// after adding the last element, 'decoded' is emitted from decoder</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Socket.IO  —  Server API","type":"api","_content":"\n# Server\n\nExposed by `require('socket.io')`.\n\n## new Server(httpServer[, options])\n\n  - `httpServer` _(http.Server)_ the server to bind to.\n  - `options` _(Object)_\n    - `path` _(String)_: name of the path to capture (`/socket.io`)\n    - `serveClient` _(Boolean)_: whether to serve the client files (`true`)\n    - `adapter` _(Adapter)_: the adapter to use. Defaults to an instance of the `Adapter` that ships with socket.io which is memory based. See [socket.io-adapter](https://github.com/socketio/socket.io-adapter)\n    - `origins` _(String)_: the allowed origins (`*`)\n    - `parser` _(Parser)_: the parser to use. Defaults to an instance of the `Parser` that ships with socket.io. See [socket.io-parser](https://github.com/socketio/socket.io-parser).\n\nWorks with and without `new`:\n\n```js\nconst io = require('socket.io')();\n// or\nconst Server = require('socket.io');\nconst io = new Server();\n```\n\nThe same options passed to socket.io are always passed to the `engine.io` `Server` that gets created. See engine.io [options](https://github.com/socketio/engine.io#methods-1) as reference.\n\nAmong those options:\n\n  - `pingTimeout` _(Number)_: how many ms without a pong packet to consider the connection closed (`60000`)\n  - `pingInterval` _(Number)_: how many ms before sending a new ping packet (`25000`).\n\nThose two parameters will impact the delay before a client knows the server is not available anymore. For example, if the underlying TCP connection is not closed properly due to a network issue, a client may have to wait up to `pingTimeout + pingInterval` ms before getting a `disconnect` event.\n\n  - `transports` _(Array<String>)_: transports to allow connections to (`['polling', 'websocket']`).\n\n**Note:** The order is important. By default, a long-polling connection is established first, and then upgraded to WebSocket if possible. Using `['websocket']` means there will be no fallback if a WebSocket connection cannot be opened.\n\n```js\nconst server = require('http').createServer();\n\nconst io = require('socket.io')(server, {\n  path: '/test',\n  serveClient: false,\n  // below are engine.IO options\n  pingInterval: 10000,\n  pingTimeout: 5000,\n  cookie: false\n});\n\nserver.listen(3000);\n```\n\n## new Server(port[, options])\n\n  - `port` _(Number)_ a port to listen to (a new `http.Server` will be created)\n  - `options` _(Object)_\n\nSee [above](#new-serverhttpserver-options) for available options.\n\n```js\nconst server = require('http').createServer();\n\nconst io = require('socket.io')(3000, {\n  path: '/test',\n  serveClient: false,\n  // below are engine.IO options\n  pingInterval: 10000,\n  pingTimeout: 5000,\n  cookie: false\n});\n```\n\n## new Server(options)\n\n  - `options` _(Object)_\n\nSee [above](#new-serverhttpserver-options) for available options.\n\n```js\nconst io = require('socket.io')({\n  path: '/test',\n  serveClient: false,\n});\n\n// either\nconst server = require('http').createServer();\n\nio.attach(server, {\n  pingInterval: 10000,\n  pingTimeout: 5000,\n  cookie: false\n});\n\nserver.listen(3000);\n\n// or\nio.attach(3000, {\n  pingInterval: 10000,\n  pingTimeout: 5000,\n  cookie: false\n});\n```\n\n## server.sockets\n\n  * _(Namespace)_\n\nThe default (`/`) namespace.\n\n## server.serveClient([value])\n\n  - `value` _(Boolean)_\n  - **Returns** `Server|Boolean`\n\nIf `value` is `true` the attached server (see `Server#attach`) will serve the client files. Defaults to `true`. This method has no effect after `attach` is called. If no arguments are supplied this method returns the current value.\n\n```js\n// pass a server and the `serveClient` option\nconst io = require('socket.io')(http, { serveClient: false });\n\n// or pass no server and then you can call the method\nconst io = require('socket.io')();\nio.serveClient(false);\nio.attach(http);\n```\n\n## server.path([value])\n\n  - `value` _(String)_\n  - **Returns** `Server|String`\n\nSets the path `value` under which `engine.io` and the static files will be served. Defaults to `/socket.io`. If no arguments are supplied this method returns the current value.\n\n```js\nconst io = require('socket.io')();\nio.path('/myownpath');\n\n// client-side\nconst socket = io({\n  path: '/myownpath'\n});\n```\n\n## server.adapter([value])\n\n  - `value` _(Adapter)_\n  - **Returns** `Server|Adapter`\n\nSets the adapter `value`. Defaults to an instance of the `Adapter` that ships with socket.io which is memory based. See [socket.io-adapter](https://github.com/socketio/socket.io-adapter). If no arguments are supplied this method returns the current value.\n\n```js\nconst io = require('socket.io')(3000);\nconst redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));\n```\n\n## server.origins([value])\n\n  - `value` _(String|String[])_\n  - **Returns** `Server|String`\n\nSets the allowed origins `value`. Defaults to any origins being allowed. If no arguments are supplied this method returns the current value.\n\n```js\nio.origins(['https://foo.example.com:443']);\n```\n\n## server.origins(fn)\n\n  - `fn` _(Function)_\n  - **Returns** `Server`\n\nProvides a function taking two arguments `origin:String` and `callback(error, success)`, where `success` is a boolean value indicating whether origin is allowed or not.  If `success` is set to `false`, `error` must be provided as a string value that will be appended to the server response, e.g. \"Origin not allowed\".\n\n__Potential drawbacks__:\n* in some situations, when it is not possible to determine `origin` it may have value of `*`\n* As this function will be executed for every request, it is advised to make this function work as fast as possible\n* If `socket.io` is used together with `Express`, the CORS headers will be affected only for `socket.io` requests. For Express you can use [cors](https://github.com/expressjs/cors).\n\n```js\nio.origins((origin, callback) => {\n  if (origin !== 'https://foo.example.com') {\n    return callback('origin not allowed', false);\n  }\n  callback(null, true);\n});\n```\n\n## server.attach(httpServer[, options])\n\n  - `httpServer` _(http.Server)_ the server to attach to\n  - `options` _(Object)_\n\nAttaches the `Server` to an engine.io instance on `httpServer` with the supplied `options` (optionally).\n\n## server.attach(port[, options])\n\n  - `port` _(Number)_ the port to listen on\n  - `options` _(Object)_\n\nAttaches the `Server` to an engine.io instance on a new http.Server with the supplied `options` (optionally).\n\n## server.listen(httpServer[, options])\n\nSynonym of [server.attach(httpServer[, options])](#serverattachhttpserver-options).\n\n## server.listen(port[, options])\n\nSynonym of [server.attach(port[, options])](#serverattachport-options).\n\n## server.bind(engine)\n\n  - `engine` _(engine.Server)_\n  - **Returns** `Server`\n\nAdvanced use only. Binds the server to a specific engine.io `Server` (or compatible API) instance.\n\n## server.onconnection(socket)\n\n  - `socket` _(engine.Socket)_\n  - **Returns** `Server`\n\nAdvanced use only. Creates a new `socket.io` client from the incoming engine.io (or compatible API) `Socket`.\n\n## server.of(nsp)\n\n  - `nsp` _(String|RegExp|Function)_\n  - **Returns** `Namespace`\n\nInitializes and retrieves the given `Namespace` by its pathname identifier `nsp`. If the namespace was already initialized it returns it immediately.\n\n```js\nconst adminNamespace = io.of('/admin');\n```\n\nA regex or a function can also be provided, in order to create namespace in a dynamic way:\n\n```js\nconst dynamicNsp = io.of(/^\\/dynamic-\\d+$/).on('connect', (socket) => {\n  const newNamespace = socket.nsp; // newNamespace.name === '/dynamic-101'\n\n  // broadcast to all clients in the given sub-namespace\n  newNamespace.emit('hello');\n});\n\n// client-side\nconst socket = io('/dynamic-101');\n\n// broadcast to all clients in each sub-namespace\ndynamicNsp.emit('hello');\n\n// use a middleware for each sub-namespace\ndynamicNsp.use((socket, next) => { /* ... */ });\n```\n\nWith a function:\n\n```js\nio.of((name, query, next) => {\n  next(null, checkToken(query.token));\n}).on('connect', (socket) => { /* ... */ });\n```\n\n## server.close([callback])\n\n  - `callback` _(Function)_\n\nCloses the socket.io server. The `callback` argument is optional and will be called when all connections are closed.\n\n```js\nconst Server = require('socket.io');\nconst PORT   = 3030;\nconst server = require('http').Server();\n\nconst io = Server(PORT);\n\nio.close(); // Close current server\n\nserver.listen(PORT); // PORT is free to use\n\nio = Server(server);\n```\n\n## server.engine.generateId\n\nOverwrites the default method to generate your custom socket id.\n\nThe function is called with a node request object (`http.IncomingMessage`) as first parameter.\n\n```js\nio.engine.generateId = (req) => {\n  return \"custom:id:\" + custom_id++; // custom id must be unique\n}\n```\n\n# Namespace\n\nRepresents a pool of sockets connected under a given scope identified\nby a pathname (eg: `/chat`).\n\nA client always connects to `/` (the main namespace), then potentially connect to other namespaces (while using the same underlying connection).\n\n## namespace.name\n\n  * _(String)_\n\nThe namespace identifier property.\n\n## namespace.connected\n\n  * _(Object<Socket>)_\n\nThe hash of `Socket` objects that are connected to this namespace, indexed by `id`.\n\n## namespace.adapter\n\n  * _(Adapter)_\n\nThe `Adapter` used for the namespace. Useful when using the `Adapter` based on [Redis](https://github.com/socketio/socket.io-redis), as it exposes methods to manage sockets and rooms accross your cluster.\n\n**Note:** the adapter of the main namespace can be accessed with `io.of('/').adapter`.\n\n## namespace.to(room)\n\n  - `room` _(String)_\n  - **Returns** `Namespace` for chaining\n\nSets a modifier for a subsequent event emission that the event will only be _broadcasted_ to clients that have joined the given `room`.\n\nTo emit to multiple rooms, you can call `to` several times.\n\n```js\nconst io = require('socket.io')();\nconst adminNamespace = io.of('/admin');\n\nadminNamespace.to('level1').emit('an event', { some: 'data' });\n```\n\n## namespace.in(room)\n\nSynonym of [namespace.to(room)](#namespacetoroom).\n\n## namespace.emit(eventName[, ...args])\n\n  - `eventName` _(String)_\n  - `args`\n\nEmits an event to all connected clients. The following two are equivalent:\n\n```js\nconst io = require('socket.io')();\nio.emit('an event sent to all connected clients'); // main namespace\n\nconst chat = io.of('/chat');\nchat.emit('an event sent to all connected clients in chat namespace');\n```\n\n**Note:** acknowledgements are not supported when emitting from namespace.\n\n## namespace.clients(callback)\n\n  - `callback` _(Function)_\n\nGets a list of client IDs connected to this namespace (across all nodes if applicable).\n\n```js\nconst io = require('socket.io')();\nio.of('/chat').clients((error, clients) => {\n  if (error) throw error;\n  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]\n});\n```\n\nAn example to get all clients in namespace's room:\n\n```js\nio.of('/chat').in('general').clients((error, clients) => {\n  if (error) throw error;\n  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]\n});\n```\n\nAs with broadcasting, the default is all clients from the default namespace ('/'):\n\n```js\nio.clients((error, clients) => {\n  if (error) throw error;\n  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]\n});\n```\n\n## namespace.use(fn)\n\n  - `fn` _(Function)_\n\nRegisters a middleware, which is a function that gets executed for every incoming `Socket`, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.\n\nErrors passed to middleware callbacks are sent as special `error` packets to clients.\n\n```js\nio.use((socket, next) => {\n  if (socket.request.headers.cookie) return next();\n  next(new Error('Authentication error'));\n});\n```\n\n## Event: 'connect'\n\n  - `socket` _(Socket)_ socket connection with client\n\nFired upon a connection from client.\n\n```js\nio.on('connect', (socket) => {\n  // ...\n});\n\nio.of('/admin').on('connect', (socket) => {\n  // ...\n});\n```\n\n## Event: 'connection'\n\nSynonym of [Event: 'connect'](#event-connect).\n\n## Flag: 'volatile'\n\nSets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).\n\n```js\nio.volatile.emit('an event', { some: 'data' }); // the clients may or may not receive it\n```\n\n## Flag: 'binary'\n\nSpecifies whether there is binary data in the emitted data. Increases performance when specified. Can be `true` or `false`.\n\n```js\nio.binary(false).emit('an event', { some: 'data' });\n```\n\n## Flag: 'local'\n\nSets a modifier for a subsequent event emission that the event data will only be _broadcast_ to the current node (when the [Redis adapter](https://github.com/socketio/socket.io-redis) is used).\n\n```js\nio.local.emit('an event', { some: 'data' });\n```\n\n# Socket\n\nA `Socket` is the fundamental class for interacting with browser clients. A `Socket` belongs to a certain `Namespace` (by default `/`) and uses an underlying `Client` to communicate.\n\nIt should be noted the `Socket` doesn't relate directly to the actual underlying TCP/IP `socket` and it is only the name of the class.\n\nWithin each `Namespace`, you can also define arbitrary channels (called `room`) that the `Socket` can join and leave. That provides a convenient way to broadcast to a group of `Socket`s (see `Socket#to` below).\n\nThe `Socket` class inherits from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter). The `Socket` class overrides the `emit` method, and does not modify any other `EventEmitter` method. All methods documented here which also appear as `EventEmitter` methods (apart from `emit`) are implemented by `EventEmitter`, and documentation for `EventEmitter` applies.\n\n## socket.id\n\n  * _(String)_\n\nA unique identifier for the session, that comes from the underlying `Client`.\n\n## socket.rooms\n\n  * _(Object)_\n\nA hash of strings identifying the rooms this client is in, indexed by room name.\n\n```js\nio.on('connection', (socket) => {\n  socket.join('room 237', () => {\n    let rooms = Object.keys(socket.rooms);\n    console.log(rooms); // [ <socket.id>, 'room 237' ]\n  });\n});\n```\n\n## socket.client\n\n  * _(Client)_\n\nA reference to the underlying `Client` object.\n\n## socket.conn\n\n  * _(engine.Socket)_\n\nA reference to the underlying `Client` transport connection (engine.io `Socket` object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.\n\n## socket.request\n\n  * _(Request)_\n\nA getter proxy that returns the reference to the `request` that originated the underlying engine.io `Client`. Useful for accessing request headers such as `Cookie` or `User-Agent`.\n\n## socket.handshake\n\n  * _(Object)_\n\nThe handshake details:\n\n```js\n{\n  headers: /* the headers sent as part of the handshake */,\n  time: /* the date of creation (as string) */,\n  address: /* the ip of the client */,\n  xdomain: /* whether the connection is cross-domain */,\n  secure: /* whether the connection is secure */,\n  issued: /* the date of creation (as unix timestamp) */,\n  url: /* the request URL string */,\n  query: /* the query object */\n}\n```\n\nUsage:\n\n```js\nio.use((socket, next) => {\n  let handshake = socket.handshake;\n  // ...\n});\n\nio.on('connection', (socket) => {\n  let handshake = socket.handshake;\n  // ...\n});\n```\n\n## socket.use(fn)\n\n  - `fn` _(Function)_\n\nRegisters a middleware, which is a function that gets executed for every incoming `Packet` and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.\n\nErrors passed to middleware callbacks are sent as special `error` packets to clients.\n\n```js\nio.on('connection', (socket) => {\n  socket.use((packet, next) => {\n    if (packet.doge === true) return next();\n    next(new Error('Not a doge error'));\n  });\n});\n```\n\n## socket.send([...args][, ack])\n\n  - `args`\n  - `ack` _(Function)_\n  - **Returns** `Socket`\n\nSends a `message` event. See [socket.emit(eventName[, ...args][, ack])](#socketemiteventname-args-ack).\n\n## socket.emit(eventName[, ...args][, ack])\n\n*(overrides `EventEmitter.emit`)*\n  - `eventName` _(String)_\n  - `args`\n  - `ack` _(Function)_\n  - **Returns** `Socket`\n\nEmits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including `Buffer`.\n\n```js\nsocket.emit('hello', 'world');\nsocket.emit('with-binary', 1, '2', { 3: '4', 5: new Buffer(6) });\n```\n\nThe `ack` argument is optional and will be called with the client's answer.\n\n```js\nio.on('connection', (socket) => {\n  socket.emit('an event', { some: 'data' });\n\n  socket.emit('ferret', 'tobi', (data) => {\n    console.log(data); // data will be 'woot'\n  });\n\n  // the client code\n  // client.on('ferret', (name, fn) => {\n  //   fn('woot');\n  // });\n\n});\n```\n\n## socket.on(eventName, callback)\n\n*(inherited from `EventEmitter`)*\n  - `eventName` _(String)_\n  - `callback` _(Function)_\n  - **Returns** `Socket`\n\nRegister a new handler for the given event.\n\n```js\nsocket.on('news', (data) => {\n  console.log(data);\n});\n// with several arguments\nsocket.on('news', (arg1, arg2, arg3) => {\n  // ...\n});\n// or with acknowledgement\nsocket.on('news', (data, callback) => {\n  callback(0);\n});\n```\n\n## socket.once(eventName, listener)\n## socket.removeListener(eventName, listener)\n## socket.removeAllListeners([eventName])\n## socket.eventNames()\n\nInherited from `EventEmitter` (along with other methods not mentioned here). See Node.js documentation for the `events` module.\n\n## socket.join(room[, callback])\n\n  - `room` _(String)_\n  - `callback` _(Function)_\n  - **Returns** `Socket` for chaining\n\nAdds the client to the `room`, and fires optionally a callback with `err` signature (if any).\n\n```js\nio.on('connection', (socket) => {\n  socket.join('room 237', () => {\n    let rooms = Object.keys(socket.rooms);\n    console.log(rooms); // [ <socket.id>, 'room 237' ]\n    io.to('room 237').emit('a new user has joined the room'); // broadcast to everyone in the room\n  });\n});\n```\n\nThe mechanics of joining rooms are handled by the `Adapter` that has been configured (see `Server#adapter` above), defaulting to [socket.io-adapter](https://github.com/socketio/socket.io-adapter).\n\nFor your convenience, each socket automatically joins a room identified by its id (see `Socket#id`). This makes it easy to broadcast messages to other sockets:\n\n```js\nio.on('connection', (socket) => {\n  socket.on('say to someone', (id, msg) => {\n    // send a private message to the socket with the given id\n    socket.to(id).emit('my message', msg);\n  });\n});\n```\n\n## socket.join(rooms[, callback])\n\n  - `rooms` _(Array)_\n  - `callback` _(Function)_\n  - **Returns** `Socket` for chaining\n\nAdds the client to the list of room, and fires optionally a callback with `err` signature (if any).\n\n## socket.leave(room[, callback])\n\n  - `room` _(String)_\n  - `callback` _(Function)_\n  - **Returns** `Socket` for chaining\n\nRemoves the client from `room`, and fires optionally a callback with `err` signature (if any).\n\n**Rooms are left automatically upon disconnection**.\n\n## socket.to(room)\n\n  - `room` _(String)_\n  - **Returns** `Socket` for chaining\n\nSets a modifier for a subsequent event emission that the event will only be _broadcasted_ to clients that have joined the given `room` (the socket itself being excluded).\n\nTo emit to multiple rooms, you can call `to` several times.\n\n```js\nio.on('connection', (socket) => {\n  // to one room\n  socket.to('others').emit('an event', { some: 'data' });\n  // to multiple rooms\n  socket.to('room1').to('room2').emit('hello');\n  // a private message to another socket\n  socket.to(/* another socket id */).emit('hey');\n});\n```\n\n**Note:** acknowledgements are not supported when broadcasting.\n\n## socket.in(room)\n\nSynonym of [socket.to(room)](#sockettoroom).\n\n## socket.compress(value)\n\n  - `value` _(Boolean)_ whether to following packet will be compressed\n  - **Returns** `Socket` for chaining\n\nSets a modifier for a subsequent event emission that the event data will only be _compressed_ if the value is `true`. Defaults to `true` when you don't call the method.\n\n```js\nio.on('connection', (socket) => {\n  socket.compress(false).emit('uncompressed', \"that's rough\");\n});\n```\n\n## socket.disconnect(close)\n\n  - `close` _(Boolean)_ whether to close the underlying connection\n  - **Returns** `Socket`\n\nDisconnects this client. If value of close is `true`, closes the underlying connection. Otherwise, it just disconnects the namespace.\n\n```js\nio.on('connection', (socket) => {\n  setTimeout(() => socket.disconnect(true), 5000);\n});\n```\n\n## Flag: 'broadcast'\n\nSets a modifier for a subsequent event emission that the event data will only be _broadcast_ to every sockets but the sender.\n\n```js\nio.on('connection', (socket) => {\n  socket.broadcast.emit('an event', { some: 'data' }); // everyone gets it but the sender\n});\n```\n\n## Flag: 'volatile'\n\nSets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).\n\n```js\nio.on('connection', (socket) => {\n  socket.volatile.emit('an event', { some: 'data' }); // the client may or may not receive it\n});\n```\n\n## Flag: 'binary'\n\nSpecifies whether there is binary data in the emitted data. Increases performance when specified. Can be `true` or `false`.\n\n```js\nvar io = require('socket.io')();\nio.on('connection', function(socket){\n  socket.binary(false).emit('an event', { some: 'data' }); // The data to send has no binary data\n});\n```\n\n## Event: 'disconnect'\n\n  - `reason` _(String)_ the reason of the disconnection (either client or server-side)\n\nFired upon disconnection.\n\n```js\nio.on('connection', (socket) => {\n  socket.on('disconnect', (reason) => {\n    // ...\n  });\n});\n```\n\n## Event: 'error'\n\n  - `error` _(Object)_ error object\n\nFired when an error occurs.\n\n```js\nio.on('connection', (socket) => {\n  socket.on('error', (error) => {\n    // ...\n  });\n});\n```\n\n## Event: 'disconnecting'\n\n  - `reason` _(String)_ the reason of the disconnection (either client or server-side)\n\nFired when the client is going to be disconnected (but hasn't left its `rooms` yet).\n\n```js\nio.on('connection', (socket) => {\n  socket.on('disconnecting', (reason) => {\n    let rooms = Object.keys(socket.rooms);\n    // ...\n  });\n});\n```\n\nThese are reserved events (along with `connect`, `newListener` and `removeListener`) which cannot be used as event names.\n\n# Client\n\nThe `Client` class represents an incoming transport (engine.io) connection. A `Client` can be associated with many multiplexed `Socket`s that belong to different `Namespace`s.\n\n## client.conn\n\n  * _(engine.Socket)_\n\nA reference to the underlying `engine.io` `Socket` connection.\n\n## client.request\n\n  * _(Request)_\n\nA getter proxy that returns the reference to the `request` that originated the engine.io connection. Useful for accessing request headers such as `Cookie` or `User-Agent`.\n","source":"docs/server-api.md","raw":"title: Socket.IO  —  Server API\npermalink: /docs/server-api/\ntype: api\n---\n\n# Server\n\nExposed by `require('socket.io')`.\n\n## new Server(httpServer[, options])\n\n  - `httpServer` _(http.Server)_ the server to bind to.\n  - `options` _(Object)_\n    - `path` _(String)_: name of the path to capture (`/socket.io`)\n    - `serveClient` _(Boolean)_: whether to serve the client files (`true`)\n    - `adapter` _(Adapter)_: the adapter to use. Defaults to an instance of the `Adapter` that ships with socket.io which is memory based. See [socket.io-adapter](https://github.com/socketio/socket.io-adapter)\n    - `origins` _(String)_: the allowed origins (`*`)\n    - `parser` _(Parser)_: the parser to use. Defaults to an instance of the `Parser` that ships with socket.io. See [socket.io-parser](https://github.com/socketio/socket.io-parser).\n\nWorks with and without `new`:\n\n```js\nconst io = require('socket.io')();\n// or\nconst Server = require('socket.io');\nconst io = new Server();\n```\n\nThe same options passed to socket.io are always passed to the `engine.io` `Server` that gets created. See engine.io [options](https://github.com/socketio/engine.io#methods-1) as reference.\n\nAmong those options:\n\n  - `pingTimeout` _(Number)_: how many ms without a pong packet to consider the connection closed (`60000`)\n  - `pingInterval` _(Number)_: how many ms before sending a new ping packet (`25000`).\n\nThose two parameters will impact the delay before a client knows the server is not available anymore. For example, if the underlying TCP connection is not closed properly due to a network issue, a client may have to wait up to `pingTimeout + pingInterval` ms before getting a `disconnect` event.\n\n  - `transports` _(Array<String>)_: transports to allow connections to (`['polling', 'websocket']`).\n\n**Note:** The order is important. By default, a long-polling connection is established first, and then upgraded to WebSocket if possible. Using `['websocket']` means there will be no fallback if a WebSocket connection cannot be opened.\n\n```js\nconst server = require('http').createServer();\n\nconst io = require('socket.io')(server, {\n  path: '/test',\n  serveClient: false,\n  // below are engine.IO options\n  pingInterval: 10000,\n  pingTimeout: 5000,\n  cookie: false\n});\n\nserver.listen(3000);\n```\n\n## new Server(port[, options])\n\n  - `port` _(Number)_ a port to listen to (a new `http.Server` will be created)\n  - `options` _(Object)_\n\nSee [above](#new-serverhttpserver-options) for available options.\n\n```js\nconst server = require('http').createServer();\n\nconst io = require('socket.io')(3000, {\n  path: '/test',\n  serveClient: false,\n  // below are engine.IO options\n  pingInterval: 10000,\n  pingTimeout: 5000,\n  cookie: false\n});\n```\n\n## new Server(options)\n\n  - `options` _(Object)_\n\nSee [above](#new-serverhttpserver-options) for available options.\n\n```js\nconst io = require('socket.io')({\n  path: '/test',\n  serveClient: false,\n});\n\n// either\nconst server = require('http').createServer();\n\nio.attach(server, {\n  pingInterval: 10000,\n  pingTimeout: 5000,\n  cookie: false\n});\n\nserver.listen(3000);\n\n// or\nio.attach(3000, {\n  pingInterval: 10000,\n  pingTimeout: 5000,\n  cookie: false\n});\n```\n\n## server.sockets\n\n  * _(Namespace)_\n\nThe default (`/`) namespace.\n\n## server.serveClient([value])\n\n  - `value` _(Boolean)_\n  - **Returns** `Server|Boolean`\n\nIf `value` is `true` the attached server (see `Server#attach`) will serve the client files. Defaults to `true`. This method has no effect after `attach` is called. If no arguments are supplied this method returns the current value.\n\n```js\n// pass a server and the `serveClient` option\nconst io = require('socket.io')(http, { serveClient: false });\n\n// or pass no server and then you can call the method\nconst io = require('socket.io')();\nio.serveClient(false);\nio.attach(http);\n```\n\n## server.path([value])\n\n  - `value` _(String)_\n  - **Returns** `Server|String`\n\nSets the path `value` under which `engine.io` and the static files will be served. Defaults to `/socket.io`. If no arguments are supplied this method returns the current value.\n\n```js\nconst io = require('socket.io')();\nio.path('/myownpath');\n\n// client-side\nconst socket = io({\n  path: '/myownpath'\n});\n```\n\n## server.adapter([value])\n\n  - `value` _(Adapter)_\n  - **Returns** `Server|Adapter`\n\nSets the adapter `value`. Defaults to an instance of the `Adapter` that ships with socket.io which is memory based. See [socket.io-adapter](https://github.com/socketio/socket.io-adapter). If no arguments are supplied this method returns the current value.\n\n```js\nconst io = require('socket.io')(3000);\nconst redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));\n```\n\n## server.origins([value])\n\n  - `value` _(String|String[])_\n  - **Returns** `Server|String`\n\nSets the allowed origins `value`. Defaults to any origins being allowed. If no arguments are supplied this method returns the current value.\n\n```js\nio.origins(['https://foo.example.com:443']);\n```\n\n## server.origins(fn)\n\n  - `fn` _(Function)_\n  - **Returns** `Server`\n\nProvides a function taking two arguments `origin:String` and `callback(error, success)`, where `success` is a boolean value indicating whether origin is allowed or not.  If `success` is set to `false`, `error` must be provided as a string value that will be appended to the server response, e.g. \"Origin not allowed\".\n\n__Potential drawbacks__:\n* in some situations, when it is not possible to determine `origin` it may have value of `*`\n* As this function will be executed for every request, it is advised to make this function work as fast as possible\n* If `socket.io` is used together with `Express`, the CORS headers will be affected only for `socket.io` requests. For Express you can use [cors](https://github.com/expressjs/cors).\n\n```js\nio.origins((origin, callback) => {\n  if (origin !== 'https://foo.example.com') {\n    return callback('origin not allowed', false);\n  }\n  callback(null, true);\n});\n```\n\n## server.attach(httpServer[, options])\n\n  - `httpServer` _(http.Server)_ the server to attach to\n  - `options` _(Object)_\n\nAttaches the `Server` to an engine.io instance on `httpServer` with the supplied `options` (optionally).\n\n## server.attach(port[, options])\n\n  - `port` _(Number)_ the port to listen on\n  - `options` _(Object)_\n\nAttaches the `Server` to an engine.io instance on a new http.Server with the supplied `options` (optionally).\n\n## server.listen(httpServer[, options])\n\nSynonym of [server.attach(httpServer[, options])](#serverattachhttpserver-options).\n\n## server.listen(port[, options])\n\nSynonym of [server.attach(port[, options])](#serverattachport-options).\n\n## server.bind(engine)\n\n  - `engine` _(engine.Server)_\n  - **Returns** `Server`\n\nAdvanced use only. Binds the server to a specific engine.io `Server` (or compatible API) instance.\n\n## server.onconnection(socket)\n\n  - `socket` _(engine.Socket)_\n  - **Returns** `Server`\n\nAdvanced use only. Creates a new `socket.io` client from the incoming engine.io (or compatible API) `Socket`.\n\n## server.of(nsp)\n\n  - `nsp` _(String|RegExp|Function)_\n  - **Returns** `Namespace`\n\nInitializes and retrieves the given `Namespace` by its pathname identifier `nsp`. If the namespace was already initialized it returns it immediately.\n\n```js\nconst adminNamespace = io.of('/admin');\n```\n\nA regex or a function can also be provided, in order to create namespace in a dynamic way:\n\n```js\nconst dynamicNsp = io.of(/^\\/dynamic-\\d+$/).on('connect', (socket) => {\n  const newNamespace = socket.nsp; // newNamespace.name === '/dynamic-101'\n\n  // broadcast to all clients in the given sub-namespace\n  newNamespace.emit('hello');\n});\n\n// client-side\nconst socket = io('/dynamic-101');\n\n// broadcast to all clients in each sub-namespace\ndynamicNsp.emit('hello');\n\n// use a middleware for each sub-namespace\ndynamicNsp.use((socket, next) => { /* ... */ });\n```\n\nWith a function:\n\n```js\nio.of((name, query, next) => {\n  next(null, checkToken(query.token));\n}).on('connect', (socket) => { /* ... */ });\n```\n\n## server.close([callback])\n\n  - `callback` _(Function)_\n\nCloses the socket.io server. The `callback` argument is optional and will be called when all connections are closed.\n\n```js\nconst Server = require('socket.io');\nconst PORT   = 3030;\nconst server = require('http').Server();\n\nconst io = Server(PORT);\n\nio.close(); // Close current server\n\nserver.listen(PORT); // PORT is free to use\n\nio = Server(server);\n```\n\n## server.engine.generateId\n\nOverwrites the default method to generate your custom socket id.\n\nThe function is called with a node request object (`http.IncomingMessage`) as first parameter.\n\n```js\nio.engine.generateId = (req) => {\n  return \"custom:id:\" + custom_id++; // custom id must be unique\n}\n```\n\n# Namespace\n\nRepresents a pool of sockets connected under a given scope identified\nby a pathname (eg: `/chat`).\n\nA client always connects to `/` (the main namespace), then potentially connect to other namespaces (while using the same underlying connection).\n\n## namespace.name\n\n  * _(String)_\n\nThe namespace identifier property.\n\n## namespace.connected\n\n  * _(Object<Socket>)_\n\nThe hash of `Socket` objects that are connected to this namespace, indexed by `id`.\n\n## namespace.adapter\n\n  * _(Adapter)_\n\nThe `Adapter` used for the namespace. Useful when using the `Adapter` based on [Redis](https://github.com/socketio/socket.io-redis), as it exposes methods to manage sockets and rooms accross your cluster.\n\n**Note:** the adapter of the main namespace can be accessed with `io.of('/').adapter`.\n\n## namespace.to(room)\n\n  - `room` _(String)_\n  - **Returns** `Namespace` for chaining\n\nSets a modifier for a subsequent event emission that the event will only be _broadcasted_ to clients that have joined the given `room`.\n\nTo emit to multiple rooms, you can call `to` several times.\n\n```js\nconst io = require('socket.io')();\nconst adminNamespace = io.of('/admin');\n\nadminNamespace.to('level1').emit('an event', { some: 'data' });\n```\n\n## namespace.in(room)\n\nSynonym of [namespace.to(room)](#namespacetoroom).\n\n## namespace.emit(eventName[, ...args])\n\n  - `eventName` _(String)_\n  - `args`\n\nEmits an event to all connected clients. The following two are equivalent:\n\n```js\nconst io = require('socket.io')();\nio.emit('an event sent to all connected clients'); // main namespace\n\nconst chat = io.of('/chat');\nchat.emit('an event sent to all connected clients in chat namespace');\n```\n\n**Note:** acknowledgements are not supported when emitting from namespace.\n\n## namespace.clients(callback)\n\n  - `callback` _(Function)_\n\nGets a list of client IDs connected to this namespace (across all nodes if applicable).\n\n```js\nconst io = require('socket.io')();\nio.of('/chat').clients((error, clients) => {\n  if (error) throw error;\n  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]\n});\n```\n\nAn example to get all clients in namespace's room:\n\n```js\nio.of('/chat').in('general').clients((error, clients) => {\n  if (error) throw error;\n  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]\n});\n```\n\nAs with broadcasting, the default is all clients from the default namespace ('/'):\n\n```js\nio.clients((error, clients) => {\n  if (error) throw error;\n  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]\n});\n```\n\n## namespace.use(fn)\n\n  - `fn` _(Function)_\n\nRegisters a middleware, which is a function that gets executed for every incoming `Socket`, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.\n\nErrors passed to middleware callbacks are sent as special `error` packets to clients.\n\n```js\nio.use((socket, next) => {\n  if (socket.request.headers.cookie) return next();\n  next(new Error('Authentication error'));\n});\n```\n\n## Event: 'connect'\n\n  - `socket` _(Socket)_ socket connection with client\n\nFired upon a connection from client.\n\n```js\nio.on('connect', (socket) => {\n  // ...\n});\n\nio.of('/admin').on('connect', (socket) => {\n  // ...\n});\n```\n\n## Event: 'connection'\n\nSynonym of [Event: 'connect'](#event-connect).\n\n## Flag: 'volatile'\n\nSets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).\n\n```js\nio.volatile.emit('an event', { some: 'data' }); // the clients may or may not receive it\n```\n\n## Flag: 'binary'\n\nSpecifies whether there is binary data in the emitted data. Increases performance when specified. Can be `true` or `false`.\n\n```js\nio.binary(false).emit('an event', { some: 'data' });\n```\n\n## Flag: 'local'\n\nSets a modifier for a subsequent event emission that the event data will only be _broadcast_ to the current node (when the [Redis adapter](https://github.com/socketio/socket.io-redis) is used).\n\n```js\nio.local.emit('an event', { some: 'data' });\n```\n\n# Socket\n\nA `Socket` is the fundamental class for interacting with browser clients. A `Socket` belongs to a certain `Namespace` (by default `/`) and uses an underlying `Client` to communicate.\n\nIt should be noted the `Socket` doesn't relate directly to the actual underlying TCP/IP `socket` and it is only the name of the class.\n\nWithin each `Namespace`, you can also define arbitrary channels (called `room`) that the `Socket` can join and leave. That provides a convenient way to broadcast to a group of `Socket`s (see `Socket#to` below).\n\nThe `Socket` class inherits from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter). The `Socket` class overrides the `emit` method, and does not modify any other `EventEmitter` method. All methods documented here which also appear as `EventEmitter` methods (apart from `emit`) are implemented by `EventEmitter`, and documentation for `EventEmitter` applies.\n\n## socket.id\n\n  * _(String)_\n\nA unique identifier for the session, that comes from the underlying `Client`.\n\n## socket.rooms\n\n  * _(Object)_\n\nA hash of strings identifying the rooms this client is in, indexed by room name.\n\n```js\nio.on('connection', (socket) => {\n  socket.join('room 237', () => {\n    let rooms = Object.keys(socket.rooms);\n    console.log(rooms); // [ <socket.id>, 'room 237' ]\n  });\n});\n```\n\n## socket.client\n\n  * _(Client)_\n\nA reference to the underlying `Client` object.\n\n## socket.conn\n\n  * _(engine.Socket)_\n\nA reference to the underlying `Client` transport connection (engine.io `Socket` object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.\n\n## socket.request\n\n  * _(Request)_\n\nA getter proxy that returns the reference to the `request` that originated the underlying engine.io `Client`. Useful for accessing request headers such as `Cookie` or `User-Agent`.\n\n## socket.handshake\n\n  * _(Object)_\n\nThe handshake details:\n\n```js\n{\n  headers: /* the headers sent as part of the handshake */,\n  time: /* the date of creation (as string) */,\n  address: /* the ip of the client */,\n  xdomain: /* whether the connection is cross-domain */,\n  secure: /* whether the connection is secure */,\n  issued: /* the date of creation (as unix timestamp) */,\n  url: /* the request URL string */,\n  query: /* the query object */\n}\n```\n\nUsage:\n\n```js\nio.use((socket, next) => {\n  let handshake = socket.handshake;\n  // ...\n});\n\nio.on('connection', (socket) => {\n  let handshake = socket.handshake;\n  // ...\n});\n```\n\n## socket.use(fn)\n\n  - `fn` _(Function)_\n\nRegisters a middleware, which is a function that gets executed for every incoming `Packet` and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.\n\nErrors passed to middleware callbacks are sent as special `error` packets to clients.\n\n```js\nio.on('connection', (socket) => {\n  socket.use((packet, next) => {\n    if (packet.doge === true) return next();\n    next(new Error('Not a doge error'));\n  });\n});\n```\n\n## socket.send([...args][, ack])\n\n  - `args`\n  - `ack` _(Function)_\n  - **Returns** `Socket`\n\nSends a `message` event. See [socket.emit(eventName[, ...args][, ack])](#socketemiteventname-args-ack).\n\n## socket.emit(eventName[, ...args][, ack])\n\n*(overrides `EventEmitter.emit`)*\n  - `eventName` _(String)_\n  - `args`\n  - `ack` _(Function)_\n  - **Returns** `Socket`\n\nEmits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including `Buffer`.\n\n```js\nsocket.emit('hello', 'world');\nsocket.emit('with-binary', 1, '2', { 3: '4', 5: new Buffer(6) });\n```\n\nThe `ack` argument is optional and will be called with the client's answer.\n\n```js\nio.on('connection', (socket) => {\n  socket.emit('an event', { some: 'data' });\n\n  socket.emit('ferret', 'tobi', (data) => {\n    console.log(data); // data will be 'woot'\n  });\n\n  // the client code\n  // client.on('ferret', (name, fn) => {\n  //   fn('woot');\n  // });\n\n});\n```\n\n## socket.on(eventName, callback)\n\n*(inherited from `EventEmitter`)*\n  - `eventName` _(String)_\n  - `callback` _(Function)_\n  - **Returns** `Socket`\n\nRegister a new handler for the given event.\n\n```js\nsocket.on('news', (data) => {\n  console.log(data);\n});\n// with several arguments\nsocket.on('news', (arg1, arg2, arg3) => {\n  // ...\n});\n// or with acknowledgement\nsocket.on('news', (data, callback) => {\n  callback(0);\n});\n```\n\n## socket.once(eventName, listener)\n## socket.removeListener(eventName, listener)\n## socket.removeAllListeners([eventName])\n## socket.eventNames()\n\nInherited from `EventEmitter` (along with other methods not mentioned here). See Node.js documentation for the `events` module.\n\n## socket.join(room[, callback])\n\n  - `room` _(String)_\n  - `callback` _(Function)_\n  - **Returns** `Socket` for chaining\n\nAdds the client to the `room`, and fires optionally a callback with `err` signature (if any).\n\n```js\nio.on('connection', (socket) => {\n  socket.join('room 237', () => {\n    let rooms = Object.keys(socket.rooms);\n    console.log(rooms); // [ <socket.id>, 'room 237' ]\n    io.to('room 237').emit('a new user has joined the room'); // broadcast to everyone in the room\n  });\n});\n```\n\nThe mechanics of joining rooms are handled by the `Adapter` that has been configured (see `Server#adapter` above), defaulting to [socket.io-adapter](https://github.com/socketio/socket.io-adapter).\n\nFor your convenience, each socket automatically joins a room identified by its id (see `Socket#id`). This makes it easy to broadcast messages to other sockets:\n\n```js\nio.on('connection', (socket) => {\n  socket.on('say to someone', (id, msg) => {\n    // send a private message to the socket with the given id\n    socket.to(id).emit('my message', msg);\n  });\n});\n```\n\n## socket.join(rooms[, callback])\n\n  - `rooms` _(Array)_\n  - `callback` _(Function)_\n  - **Returns** `Socket` for chaining\n\nAdds the client to the list of room, and fires optionally a callback with `err` signature (if any).\n\n## socket.leave(room[, callback])\n\n  - `room` _(String)_\n  - `callback` _(Function)_\n  - **Returns** `Socket` for chaining\n\nRemoves the client from `room`, and fires optionally a callback with `err` signature (if any).\n\n**Rooms are left automatically upon disconnection**.\n\n## socket.to(room)\n\n  - `room` _(String)_\n  - **Returns** `Socket` for chaining\n\nSets a modifier for a subsequent event emission that the event will only be _broadcasted_ to clients that have joined the given `room` (the socket itself being excluded).\n\nTo emit to multiple rooms, you can call `to` several times.\n\n```js\nio.on('connection', (socket) => {\n  // to one room\n  socket.to('others').emit('an event', { some: 'data' });\n  // to multiple rooms\n  socket.to('room1').to('room2').emit('hello');\n  // a private message to another socket\n  socket.to(/* another socket id */).emit('hey');\n});\n```\n\n**Note:** acknowledgements are not supported when broadcasting.\n\n## socket.in(room)\n\nSynonym of [socket.to(room)](#sockettoroom).\n\n## socket.compress(value)\n\n  - `value` _(Boolean)_ whether to following packet will be compressed\n  - **Returns** `Socket` for chaining\n\nSets a modifier for a subsequent event emission that the event data will only be _compressed_ if the value is `true`. Defaults to `true` when you don't call the method.\n\n```js\nio.on('connection', (socket) => {\n  socket.compress(false).emit('uncompressed', \"that's rough\");\n});\n```\n\n## socket.disconnect(close)\n\n  - `close` _(Boolean)_ whether to close the underlying connection\n  - **Returns** `Socket`\n\nDisconnects this client. If value of close is `true`, closes the underlying connection. Otherwise, it just disconnects the namespace.\n\n```js\nio.on('connection', (socket) => {\n  setTimeout(() => socket.disconnect(true), 5000);\n});\n```\n\n## Flag: 'broadcast'\n\nSets a modifier for a subsequent event emission that the event data will only be _broadcast_ to every sockets but the sender.\n\n```js\nio.on('connection', (socket) => {\n  socket.broadcast.emit('an event', { some: 'data' }); // everyone gets it but the sender\n});\n```\n\n## Flag: 'volatile'\n\nSets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).\n\n```js\nio.on('connection', (socket) => {\n  socket.volatile.emit('an event', { some: 'data' }); // the client may or may not receive it\n});\n```\n\n## Flag: 'binary'\n\nSpecifies whether there is binary data in the emitted data. Increases performance when specified. Can be `true` or `false`.\n\n```js\nvar io = require('socket.io')();\nio.on('connection', function(socket){\n  socket.binary(false).emit('an event', { some: 'data' }); // The data to send has no binary data\n});\n```\n\n## Event: 'disconnect'\n\n  - `reason` _(String)_ the reason of the disconnection (either client or server-side)\n\nFired upon disconnection.\n\n```js\nio.on('connection', (socket) => {\n  socket.on('disconnect', (reason) => {\n    // ...\n  });\n});\n```\n\n## Event: 'error'\n\n  - `error` _(Object)_ error object\n\nFired when an error occurs.\n\n```js\nio.on('connection', (socket) => {\n  socket.on('error', (error) => {\n    // ...\n  });\n});\n```\n\n## Event: 'disconnecting'\n\n  - `reason` _(String)_ the reason of the disconnection (either client or server-side)\n\nFired when the client is going to be disconnected (but hasn't left its `rooms` yet).\n\n```js\nio.on('connection', (socket) => {\n  socket.on('disconnecting', (reason) => {\n    let rooms = Object.keys(socket.rooms);\n    // ...\n  });\n});\n```\n\nThese are reserved events (along with `connect`, `newListener` and `removeListener`) which cannot be used as event names.\n\n# Client\n\nThe `Client` class represents an incoming transport (engine.io) connection. A `Client` can be associated with many multiplexed `Socket`s that belong to different `Namespace`s.\n\n## client.conn\n\n  * _(engine.Socket)_\n\nA reference to the underlying `engine.io` `Socket` connection.\n\n## client.request\n\n  * _(Request)_\n\nA getter proxy that returns the reference to the `request` that originated the engine.io connection. Useful for accessing request headers such as `Cookie` or `User-Agent`.\n","date":"2018-07-17T21:31:45.648Z","updated":"2018-07-17T21:31:45.648Z","path":"/docs/server-api/index.html","comments":1,"layout":"page","_id":"cjjxdyebj000bjgcx5m9r4k6u","content":"<h1 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h1><p>Exposed by <code>require(&#39;socket.io&#39;)</code>.</p>\n<h2 id=\"new-Server-httpServer-options\"><a href=\"#new-Server-httpServer-options\" class=\"headerlink\" title=\"new Server(httpServer[, options])\"></a>new Server(httpServer[, options])</h2><ul>\n<li><code>httpServer</code> <em>(http.Server)</em> the server to bind to.</li>\n<li><code>options</code> <em>(Object)</em><ul>\n<li><code>path</code> <em>(String)</em>: name of the path to capture (<code>/socket.io</code>)</li>\n<li><code>serveClient</code> <em>(Boolean)</em>: whether to serve the client files (<code>true</code>)</li>\n<li><code>adapter</code> <em>(Adapter)</em>: the adapter to use. Defaults to an instance of the <code>Adapter</code> that ships with socket.io which is memory based. See <a href=\"https://github.com/socketio/socket.io-adapter\" target=\"_blank\" rel=\"noopener\">socket.io-adapter</a></li>\n<li><code>origins</code> <em>(String)</em>: the allowed origins (<code>*</code>)</li>\n<li><code>parser</code> <em>(Parser)</em>: the parser to use. Defaults to an instance of the <code>Parser</code> that ships with socket.io. See <a href=\"https://github.com/socketio/socket.io-parser\" target=\"_blank\" rel=\"noopener\">socket.io-parser</a>.</li>\n</ul>\n</li>\n</ul>\n<p>Works with and without <code>new</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Server = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"keyword\">new</span> Server();</span><br></pre></td></tr></table></figure>\n<p>The same options passed to socket.io are always passed to the <code>engine.io</code> <code>Server</code> that gets created. See engine.io <a href=\"https://github.com/socketio/engine.io#methods-1\" target=\"_blank\" rel=\"noopener\">options</a> as reference.</p>\n<p>Among those options:</p>\n<ul>\n<li><code>pingTimeout</code> <em>(Number)</em>: how many ms without a pong packet to consider the connection closed (<code>60000</code>)</li>\n<li><code>pingInterval</code> <em>(Number)</em>: how many ms before sending a new ping packet (<code>25000</code>).</li>\n</ul>\n<p>Those two parameters will impact the delay before a client knows the server is not available anymore. For example, if the underlying TCP connection is not closed properly due to a network issue, a client may have to wait up to <code>pingTimeout + pingInterval</code> ms before getting a <code>disconnect</code> event.</p>\n<ul>\n<li><code>transports</code> <em>(Array<string>)</string></em>: transports to allow connections to (<code>[&#39;polling&#39;, &#39;websocket&#39;]</code>).</li>\n</ul>\n<p><strong>Note:</strong> The order is important. By default, a long-polling connection is established first, and then upgraded to WebSocket if possible. Using <code>[&#39;websocket&#39;]</code> means there will be no fallback if a WebSocket connection cannot be opened.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(server, &#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/test'</span>,</span><br><span class=\"line\">  serveClient: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// below are engine.IO options</span></span><br><span class=\"line\">  pingInterval: <span class=\"number\">10000</span>,</span><br><span class=\"line\">  pingTimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">  cookie: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"new-Server-port-options\"><a href=\"#new-Server-port-options\" class=\"headerlink\" title=\"new Server(port[, options])\"></a>new Server(port[, options])</h2><ul>\n<li><code>port</code> <em>(Number)</em> a port to listen to (a new <code>http.Server</code> will be created)</li>\n<li><code>options</code> <em>(Object)</em></li>\n</ul>\n<p>See <a href=\"#new-serverhttpserver-options\">above</a> for available options.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">3000</span>, &#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/test'</span>,</span><br><span class=\"line\">  serveClient: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// below are engine.IO options</span></span><br><span class=\"line\">  pingInterval: <span class=\"number\">10000</span>,</span><br><span class=\"line\">  pingTimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">  cookie: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"new-Server-options\"><a href=\"#new-Server-options\" class=\"headerlink\" title=\"new Server(options)\"></a>new Server(options)</h2><ul>\n<li><code>options</code> <em>(Object)</em></li>\n</ul>\n<p>See <a href=\"#new-serverhttpserver-options\">above</a> for available options.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/test'</span>,</span><br><span class=\"line\">  serveClient: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// either</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"></span><br><span class=\"line\">io.attach(server, &#123;</span><br><span class=\"line\">  pingInterval: <span class=\"number\">10000</span>,</span><br><span class=\"line\">  pingTimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">  cookie: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\">io.attach(<span class=\"number\">3000</span>, &#123;</span><br><span class=\"line\">  pingInterval: <span class=\"number\">10000</span>,</span><br><span class=\"line\">  pingTimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">  cookie: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-sockets\"><a href=\"#server-sockets\" class=\"headerlink\" title=\"server.sockets\"></a>server.sockets</h2><ul>\n<li><em>(Namespace)</em></li>\n</ul>\n<p>The default (<code>/</code>) namespace.</p>\n<h2 id=\"server-serveClient-value\"><a href=\"#server-serveClient-value\" class=\"headerlink\" title=\"server.serveClient([value])\"></a>server.serveClient([value])</h2><ul>\n<li><code>value</code> <em>(Boolean)</em></li>\n<li><strong>Returns</strong> <code>Server|Boolean</code></li>\n</ul>\n<p>If <code>value</code> is <code>true</code> the attached server (see <code>Server#attach</code>) will serve the client files. Defaults to <code>true</code>. This method has no effect after <code>attach</code> is called. If no arguments are supplied this method returns the current value.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pass a server and the `serveClient` option</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(http, &#123; <span class=\"attr\">serveClient</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or pass no server and then you can call the method</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.serveClient(<span class=\"literal\">false</span>);</span><br><span class=\"line\">io.attach(http);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-path-value\"><a href=\"#server-path-value\" class=\"headerlink\" title=\"server.path([value])\"></a>server.path([value])</h2><ul>\n<li><code>value</code> <em>(String)</em></li>\n<li><strong>Returns</strong> <code>Server|String</code></li>\n</ul>\n<p>Sets the path <code>value</code> under which <code>engine.io</code> and the static files will be served. Defaults to <code>/socket.io</code>. If no arguments are supplied this method returns the current value.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.path(<span class=\"string\">'/myownpath'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// client-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/myownpath'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-adapter-value\"><a href=\"#server-adapter-value\" class=\"headerlink\" title=\"server.adapter([value])\"></a>server.adapter([value])</h2><ul>\n<li><code>value</code> <em>(Adapter)</em></li>\n<li><strong>Returns</strong> <code>Server|Adapter</code></li>\n</ul>\n<p>Sets the adapter <code>value</code>. Defaults to an instance of the <code>Adapter</code> that ships with socket.io which is memory based. See <a href=\"https://github.com/socketio/socket.io-adapter\" target=\"_blank\" rel=\"noopener\">socket.io-adapter</a>. If no arguments are supplied this method returns the current value.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-redis'</span>);</span><br><span class=\"line\">io.adapter(redis(&#123; <span class=\"attr\">host</span>: <span class=\"string\">'localhost'</span>, <span class=\"attr\">port</span>: <span class=\"number\">6379</span> &#125;));</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-origins-value\"><a href=\"#server-origins-value\" class=\"headerlink\" title=\"server.origins([value])\"></a>server.origins([value])</h2><ul>\n<li><code>value</code> <em>(String|String[])</em></li>\n<li><strong>Returns</strong> <code>Server|String</code></li>\n</ul>\n<p>Sets the allowed origins <code>value</code>. Defaults to any origins being allowed. If no arguments are supplied this method returns the current value.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.origins([<span class=\"string\">'https://foo.example.com:443'</span>]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-origins-fn\"><a href=\"#server-origins-fn\" class=\"headerlink\" title=\"server.origins(fn)\"></a>server.origins(fn)</h2><ul>\n<li><code>fn</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Server</code></li>\n</ul>\n<p>Provides a function taking two arguments <code>origin:String</code> and <code>callback(error, success)</code>, where <code>success</code> is a boolean value indicating whether origin is allowed or not.  If <code>success</code> is set to <code>false</code>, <code>error</code> must be provided as a string value that will be appended to the server response, e.g. “Origin not allowed”.</p>\n<p><strong>Potential drawbacks</strong>:</p>\n<ul>\n<li>in some situations, when it is not possible to determine <code>origin</code> it may have value of <code>*</code></li>\n<li>As this function will be executed for every request, it is advised to make this function work as fast as possible</li>\n<li>If <code>socket.io</code> is used together with <code>Express</code>, the CORS headers will be affected only for <code>socket.io</code> requests. For Express you can use <a href=\"https://github.com/expressjs/cors\" target=\"_blank\" rel=\"noopener\">cors</a>.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.origins(<span class=\"function\">(<span class=\"params\">origin, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (origin !== <span class=\"string\">'https://foo.example.com'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback(<span class=\"string\">'origin not allowed'</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  callback(<span class=\"literal\">null</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-attach-httpServer-options\"><a href=\"#server-attach-httpServer-options\" class=\"headerlink\" title=\"server.attach(httpServer[, options])\"></a>server.attach(httpServer[, options])</h2><ul>\n<li><code>httpServer</code> <em>(http.Server)</em> the server to attach to</li>\n<li><code>options</code> <em>(Object)</em></li>\n</ul>\n<p>Attaches the <code>Server</code> to an engine.io instance on <code>httpServer</code> with the supplied <code>options</code> (optionally).</p>\n<h2 id=\"server-attach-port-options\"><a href=\"#server-attach-port-options\" class=\"headerlink\" title=\"server.attach(port[, options])\"></a>server.attach(port[, options])</h2><ul>\n<li><code>port</code> <em>(Number)</em> the port to listen on</li>\n<li><code>options</code> <em>(Object)</em></li>\n</ul>\n<p>Attaches the <code>Server</code> to an engine.io instance on a new http.Server with the supplied <code>options</code> (optionally).</p>\n<h2 id=\"server-listen-httpServer-options\"><a href=\"#server-listen-httpServer-options\" class=\"headerlink\" title=\"server.listen(httpServer[, options])\"></a>server.listen(httpServer[, options])</h2><p>Synonym of <a href=\"#serverattachhttpserver-options\">server.attach(httpServer[, options])</a>.</p>\n<h2 id=\"server-listen-port-options\"><a href=\"#server-listen-port-options\" class=\"headerlink\" title=\"server.listen(port[, options])\"></a>server.listen(port[, options])</h2><p>Synonym of <a href=\"#serverattachport-options\">server.attach(port[, options])</a>.</p>\n<h2 id=\"server-bind-engine\"><a href=\"#server-bind-engine\" class=\"headerlink\" title=\"server.bind(engine)\"></a>server.bind(engine)</h2><ul>\n<li><code>engine</code> <em>(engine.Server)</em></li>\n<li><strong>Returns</strong> <code>Server</code></li>\n</ul>\n<p>Advanced use only. Binds the server to a specific engine.io <code>Server</code> (or compatible API) instance.</p>\n<h2 id=\"server-onconnection-socket\"><a href=\"#server-onconnection-socket\" class=\"headerlink\" title=\"server.onconnection(socket)\"></a>server.onconnection(socket)</h2><ul>\n<li><code>socket</code> <em>(engine.Socket)</em></li>\n<li><strong>Returns</strong> <code>Server</code></li>\n</ul>\n<p>Advanced use only. Creates a new <code>socket.io</code> client from the incoming engine.io (or compatible API) <code>Socket</code>.</p>\n<h2 id=\"server-of-nsp\"><a href=\"#server-of-nsp\" class=\"headerlink\" title=\"server.of(nsp)\"></a>server.of(nsp)</h2><ul>\n<li><code>nsp</code> <em>(String|RegExp|Function)</em></li>\n<li><strong>Returns</strong> <code>Namespace</code></li>\n</ul>\n<p>Initializes and retrieves the given <code>Namespace</code> by its pathname identifier <code>nsp</code>. If the namespace was already initialized it returns it immediately.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adminNamespace = io.of(<span class=\"string\">'/admin'</span>);</span><br></pre></td></tr></table></figure>\n<p>A regex or a function can also be provided, in order to create namespace in a dynamic way:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dynamicNsp = io.of(<span class=\"regexp\">/^\\/dynamic-\\d+$/</span>).on(<span class=\"string\">'connect'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newNamespace = socket.nsp; <span class=\"comment\">// newNamespace.name === '/dynamic-101'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// broadcast to all clients in the given sub-namespace</span></span><br><span class=\"line\">  newNamespace.emit(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// client-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'/dynamic-101'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// broadcast to all clients in each sub-namespace</span></span><br><span class=\"line\">dynamicNsp.emit(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// use a middleware for each sub-namespace</span></span><br><span class=\"line\">dynamicNsp.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123; <span class=\"comment\">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>With a function:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.of(<span class=\"function\">(<span class=\"params\">name, query, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  next(<span class=\"literal\">null</span>, checkToken(query.token));</span><br><span class=\"line\">&#125;).on(<span class=\"string\">'connect'</span>, (socket) =&gt; &#123; <span class=\"comment\">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-close-callback\"><a href=\"#server-close-callback\" class=\"headerlink\" title=\"server.close([callback])\"></a>server.close([callback])</h2><ul>\n<li><code>callback</code> <em>(Function)</em></li>\n</ul>\n<p>Closes the socket.io server. The <code>callback</code> argument is optional and will be called when all connections are closed.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Server = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> PORT   = <span class=\"number\">3030</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).Server();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = Server(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">io.close(); <span class=\"comment\">// Close current server</span></span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(PORT); <span class=\"comment\">// PORT is free to use</span></span><br><span class=\"line\"></span><br><span class=\"line\">io = Server(server);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-engine-generateId\"><a href=\"#server-engine-generateId\" class=\"headerlink\" title=\"server.engine.generateId\"></a>server.engine.generateId</h2><p>Overwrites the default method to generate your custom socket id.</p>\n<p>The function is called with a node request object (<code>http.IncomingMessage</code>) as first parameter.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.engine.generateId = <span class=\"function\">(<span class=\"params\">req</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"custom:id:\"</span> + custom_id++; <span class=\"comment\">// custom id must be unique</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Namespace\"><a href=\"#Namespace\" class=\"headerlink\" title=\"Namespace\"></a>Namespace</h1><p>Represents a pool of sockets connected under a given scope identified<br>by a pathname (eg: <code>/chat</code>).</p>\n<p>A client always connects to <code>/</code> (the main namespace), then potentially connect to other namespaces (while using the same underlying connection).</p>\n<h2 id=\"namespace-name\"><a href=\"#namespace-name\" class=\"headerlink\" title=\"namespace.name\"></a>namespace.name</h2><ul>\n<li><em>(String)</em></li>\n</ul>\n<p>The namespace identifier property.</p>\n<h2 id=\"namespace-connected\"><a href=\"#namespace-connected\" class=\"headerlink\" title=\"namespace.connected\"></a>namespace.connected</h2><ul>\n<li><em>(Object<socket>)</socket></em></li>\n</ul>\n<p>The hash of <code>Socket</code> objects that are connected to this namespace, indexed by <code>id</code>.</p>\n<h2 id=\"namespace-adapter\"><a href=\"#namespace-adapter\" class=\"headerlink\" title=\"namespace.adapter\"></a>namespace.adapter</h2><ul>\n<li><em>(Adapter)</em></li>\n</ul>\n<p>The <code>Adapter</code> used for the namespace. Useful when using the <code>Adapter</code> based on <a href=\"https://github.com/socketio/socket.io-redis\" target=\"_blank\" rel=\"noopener\">Redis</a>, as it exposes methods to manage sockets and rooms accross your cluster.</p>\n<p><strong>Note:</strong> the adapter of the main namespace can be accessed with <code>io.of(&#39;/&#39;).adapter</code>.</p>\n<h2 id=\"namespace-to-room\"><a href=\"#namespace-to-room\" class=\"headerlink\" title=\"namespace.to(room)\"></a>namespace.to(room)</h2><ul>\n<li><code>room</code> <em>(String)</em></li>\n<li><strong>Returns</strong> <code>Namespace</code> for chaining</li>\n</ul>\n<p>Sets a modifier for a subsequent event emission that the event will only be <em>broadcasted</em> to clients that have joined the given <code>room</code>.</p>\n<p>To emit to multiple rooms, you can call <code>to</code> several times.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">const</span> adminNamespace = io.of(<span class=\"string\">'/admin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">adminNamespace.to(<span class=\"string\">'level1'</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"namespace-in-room\"><a href=\"#namespace-in-room\" class=\"headerlink\" title=\"namespace.in(room)\"></a>namespace.in(room)</h2><p>Synonym of <a href=\"#namespacetoroom\">namespace.to(room)</a>.</p>\n<h2 id=\"namespace-emit-eventName-…args\"><a href=\"#namespace-emit-eventName-…args\" class=\"headerlink\" title=\"namespace.emit(eventName[, …args])\"></a>namespace.emit(eventName[, …args])</h2><ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>args</code></li>\n</ul>\n<p>Emits an event to all connected clients. The following two are equivalent:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.emit(<span class=\"string\">'an event sent to all connected clients'</span>); <span class=\"comment\">// main namespace</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> chat = io.of(<span class=\"string\">'/chat'</span>);</span><br><span class=\"line\">chat.emit(<span class=\"string\">'an event sent to all connected clients in chat namespace'</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> acknowledgements are not supported when emitting from namespace.</p>\n<h2 id=\"namespace-clients-callback\"><a href=\"#namespace-clients-callback\" class=\"headerlink\" title=\"namespace.clients(callback)\"></a>namespace.clients(callback)</h2><ul>\n<li><code>callback</code> <em>(Function)</em></li>\n</ul>\n<p>Gets a list of client IDs connected to this namespace (across all nodes if applicable).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.of(<span class=\"string\">'/chat'</span>).clients(<span class=\"function\">(<span class=\"params\">error, clients</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clients); <span class=\"comment\">// =&gt; [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>An example to get all clients in namespace’s room:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.of(<span class=\"string\">'/chat'</span>).in(<span class=\"string\">'general'</span>).clients(<span class=\"function\">(<span class=\"params\">error, clients</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clients); <span class=\"comment\">// =&gt; [Anw2LatarvGVVXEIAAAD]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>As with broadcasting, the default is all clients from the default namespace (‘/‘):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.clients(<span class=\"function\">(<span class=\"params\">error, clients</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clients); <span class=\"comment\">// =&gt; [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"namespace-use-fn\"><a href=\"#namespace-use-fn\" class=\"headerlink\" title=\"namespace.use(fn)\"></a>namespace.use(fn)</h2><ul>\n<li><code>fn</code> <em>(Function)</em></li>\n</ul>\n<p>Registers a middleware, which is a function that gets executed for every incoming <code>Socket</code>, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.</p>\n<p>Errors passed to middleware callbacks are sent as special <code>error</code> packets to clients.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (socket.request.headers.cookie) <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">  next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Authentication error'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘connect’\"><a href=\"#Event-‘connect’\" class=\"headerlink\" title=\"Event: ‘connect’\"></a>Event: ‘connect’</h2><ul>\n<li><code>socket</code> <em>(Socket)</em> socket connection with client</li>\n</ul>\n<p>Fired upon a connection from client.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connect'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.of(<span class=\"string\">'/admin'</span>).on(<span class=\"string\">'connect'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘connection’\"><a href=\"#Event-‘connection’\" class=\"headerlink\" title=\"Event: ‘connection’\"></a>Event: ‘connection’</h2><p>Synonym of <a href=\"#event-connect\">Event: ‘connect’</a>.</p>\n<h2 id=\"Flag-‘volatile’\"><a href=\"#Flag-‘volatile’\" class=\"headerlink\" title=\"Flag: ‘volatile’\"></a>Flag: ‘volatile’</h2><p>Sets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.volatile.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;); <span class=\"comment\">// the clients may or may not receive it</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘binary’\"><a href=\"#Flag-‘binary’\" class=\"headerlink\" title=\"Flag: ‘binary’\"></a>Flag: ‘binary’</h2><p>Specifies whether there is binary data in the emitted data. Increases performance when specified. Can be <code>true</code> or <code>false</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.binary(<span class=\"literal\">false</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘local’\"><a href=\"#Flag-‘local’\" class=\"headerlink\" title=\"Flag: ‘local’\"></a>Flag: ‘local’</h2><p>Sets a modifier for a subsequent event emission that the event data will only be <em>broadcast</em> to the current node (when the <a href=\"https://github.com/socketio/socket.io-redis\" target=\"_blank\" rel=\"noopener\">Redis adapter</a> is used).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.local.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1><p>A <code>Socket</code> is the fundamental class for interacting with browser clients. A <code>Socket</code> belongs to a certain <code>Namespace</code> (by default <code>/</code>) and uses an underlying <code>Client</code> to communicate.</p>\n<p>It should be noted the <code>Socket</code> doesn’t relate directly to the actual underlying TCP/IP <code>socket</code> and it is only the name of the class.</p>\n<p>Within each <code>Namespace</code>, you can also define arbitrary channels (called <code>room</code>) that the <code>Socket</code> can join and leave. That provides a convenient way to broadcast to a group of <code>Socket</code>s (see <code>Socket#to</code> below).</p>\n<p>The <code>Socket</code> class inherits from <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\" target=\"_blank\" rel=\"noopener\">EventEmitter</a>. The <code>Socket</code> class overrides the <code>emit</code> method, and does not modify any other <code>EventEmitter</code> method. All methods documented here which also appear as <code>EventEmitter</code> methods (apart from <code>emit</code>) are implemented by <code>EventEmitter</code>, and documentation for <code>EventEmitter</code> applies.</p>\n<h2 id=\"socket-id\"><a href=\"#socket-id\" class=\"headerlink\" title=\"socket.id\"></a>socket.id</h2><ul>\n<li><em>(String)</em></li>\n</ul>\n<p>A unique identifier for the session, that comes from the underlying <code>Client</code>.</p>\n<h2 id=\"socket-rooms\"><a href=\"#socket-rooms\" class=\"headerlink\" title=\"socket.rooms\"></a>socket.rooms</h2><ul>\n<li><em>(Object)</em></li>\n</ul>\n<p>A hash of strings identifying the rooms this client is in, indexed by room name.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.join(<span class=\"string\">'room 237'</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rooms = <span class=\"built_in\">Object</span>.keys(socket.rooms);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(rooms); <span class=\"comment\">// [ &lt;socket.id&gt;, 'room 237' ]</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-client\"><a href=\"#socket-client\" class=\"headerlink\" title=\"socket.client\"></a>socket.client</h2><ul>\n<li><em>(Client)</em></li>\n</ul>\n<p>A reference to the underlying <code>Client</code> object.</p>\n<h2 id=\"socket-conn\"><a href=\"#socket-conn\" class=\"headerlink\" title=\"socket.conn\"></a>socket.conn</h2><ul>\n<li><em>(engine.Socket)</em></li>\n</ul>\n<p>A reference to the underlying <code>Client</code> transport connection (engine.io <code>Socket</code> object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.</p>\n<h2 id=\"socket-request\"><a href=\"#socket-request\" class=\"headerlink\" title=\"socket.request\"></a>socket.request</h2><ul>\n<li><em>(Request)</em></li>\n</ul>\n<p>A getter proxy that returns the reference to the <code>request</code> that originated the underlying engine.io <code>Client</code>. Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.</p>\n<h2 id=\"socket-handshake\"><a href=\"#socket-handshake\" class=\"headerlink\" title=\"socket.handshake\"></a>socket.handshake</h2><ul>\n<li><em>(Object)</em></li>\n</ul>\n<p>The handshake details:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  headers: <span class=\"comment\">/* the headers sent as part of the handshake */</span>,</span><br><span class=\"line\">  time: <span class=\"comment\">/* the date of creation (as string) */</span>,</span><br><span class=\"line\">  address: <span class=\"comment\">/* the ip of the client */</span>,</span><br><span class=\"line\">  xdomain: <span class=\"comment\">/* whether the connection is cross-domain */</span>,</span><br><span class=\"line\">  secure: <span class=\"comment\">/* whether the connection is secure */</span>,</span><br><span class=\"line\">  issued: <span class=\"comment\">/* the date of creation (as unix timestamp) */</span>,</span><br><span class=\"line\">  url: <span class=\"comment\">/* the request URL string */</span>,</span><br><span class=\"line\">  query: <span class=\"comment\">/* the query object */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Usage:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handshake = socket.handshake;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handshake = socket.handshake;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-use-fn\"><a href=\"#socket-use-fn\" class=\"headerlink\" title=\"socket.use(fn)\"></a>socket.use(fn)</h2><ul>\n<li><code>fn</code> <em>(Function)</em></li>\n</ul>\n<p>Registers a middleware, which is a function that gets executed for every incoming <code>Packet</code> and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.</p>\n<p>Errors passed to middleware callbacks are sent as special <code>error</code> packets to clients.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.use(<span class=\"function\">(<span class=\"params\">packet, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (packet.doge === <span class=\"literal\">true</span>) <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">    next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Not a doge error'</span>));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-send-…args-ack\"><a href=\"#socket-send-…args-ack\" class=\"headerlink\" title=\"socket.send([…args][, ack])\"></a>socket.send([…args][, ack])</h2><ul>\n<li><code>args</code></li>\n<li><code>ack</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Sends a <code>message</code> event. See <a href=\"#socketemiteventname-args-ack\">socket.emit(eventName[, …args][, ack])</a>.</p>\n<h2 id=\"socket-emit-eventName-…args-ack\"><a href=\"#socket-emit-eventName-…args-ack\" class=\"headerlink\" title=\"socket.emit(eventName[, …args][, ack])\"></a>socket.emit(eventName[, …args][, ack])</h2><p><em>(overrides <code>EventEmitter.emit</code>)</em></p>\n<ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>args</code></li>\n<li><code>ack</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including <code>Buffer</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.emit(<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>);</span><br><span class=\"line\">socket.emit(<span class=\"string\">'with-binary'</span>, <span class=\"number\">1</span>, <span class=\"string\">'2'</span>, &#123; <span class=\"number\">3</span>: <span class=\"string\">'4'</span>, <span class=\"number\">5</span>: <span class=\"keyword\">new</span> Buffer(<span class=\"number\">6</span>) &#125;);</span><br></pre></td></tr></table></figure>\n<p>The <code>ack</code> argument is optional and will be called with the client’s answer.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.emit(<span class=\"string\">'ferret'</span>, <span class=\"string\">'tobi'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// data will be 'woot'</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// the client code</span></span><br><span class=\"line\">  <span class=\"comment\">// client.on('ferret', (name, fn) =&gt; &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   fn('woot');</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-on-eventName-callback\"><a href=\"#socket-on-eventName-callback\" class=\"headerlink\" title=\"socket.on(eventName, callback)\"></a>socket.on(eventName, callback)</h2><p><em>(inherited from <code>EventEmitter</code>)</em></p>\n<ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Register a new handler for the given event.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// with several arguments</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (arg1, arg2, arg3) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// or with acknowledgement</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (data, callback) =&gt; &#123;</span><br><span class=\"line\">  callback(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-once-eventName-listener\"><a href=\"#socket-once-eventName-listener\" class=\"headerlink\" title=\"socket.once(eventName, listener)\"></a>socket.once(eventName, listener)</h2><h2 id=\"socket-removeListener-eventName-listener\"><a href=\"#socket-removeListener-eventName-listener\" class=\"headerlink\" title=\"socket.removeListener(eventName, listener)\"></a>socket.removeListener(eventName, listener)</h2><h2 id=\"socket-removeAllListeners-eventName\"><a href=\"#socket-removeAllListeners-eventName\" class=\"headerlink\" title=\"socket.removeAllListeners([eventName])\"></a>socket.removeAllListeners([eventName])</h2><h2 id=\"socket-eventNames\"><a href=\"#socket-eventNames\" class=\"headerlink\" title=\"socket.eventNames()\"></a>socket.eventNames()</h2><p>Inherited from <code>EventEmitter</code> (along with other methods not mentioned here). See Node.js documentation for the <code>events</code> module.</p>\n<h2 id=\"socket-join-room-callback\"><a href=\"#socket-join-room-callback\" class=\"headerlink\" title=\"socket.join(room[, callback])\"></a>socket.join(room[, callback])</h2><ul>\n<li><code>room</code> <em>(String)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Adds the client to the <code>room</code>, and fires optionally a callback with <code>err</code> signature (if any).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.join(<span class=\"string\">'room 237'</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rooms = <span class=\"built_in\">Object</span>.keys(socket.rooms);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(rooms); <span class=\"comment\">// [ &lt;socket.id&gt;, 'room 237' ]</span></span><br><span class=\"line\">    io.to(<span class=\"string\">'room 237'</span>).emit(<span class=\"string\">'a new user has joined the room'</span>); <span class=\"comment\">// broadcast to everyone in the room</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The mechanics of joining rooms are handled by the <code>Adapter</code> that has been configured (see <code>Server#adapter</code> above), defaulting to <a href=\"https://github.com/socketio/socket.io-adapter\" target=\"_blank\" rel=\"noopener\">socket.io-adapter</a>.</p>\n<p>For your convenience, each socket automatically joins a room identified by its id (see <code>Socket#id</code>). This makes it easy to broadcast messages to other sockets:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'say to someone'</span>, (id, msg) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// send a private message to the socket with the given id</span></span><br><span class=\"line\">    socket.to(id).emit(<span class=\"string\">'my message'</span>, msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-join-rooms-callback\"><a href=\"#socket-join-rooms-callback\" class=\"headerlink\" title=\"socket.join(rooms[, callback])\"></a>socket.join(rooms[, callback])</h2><ul>\n<li><code>rooms</code> <em>(Array)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Adds the client to the list of room, and fires optionally a callback with <code>err</code> signature (if any).</p>\n<h2 id=\"socket-leave-room-callback\"><a href=\"#socket-leave-room-callback\" class=\"headerlink\" title=\"socket.leave(room[, callback])\"></a>socket.leave(room[, callback])</h2><ul>\n<li><code>room</code> <em>(String)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Removes the client from <code>room</code>, and fires optionally a callback with <code>err</code> signature (if any).</p>\n<p><strong>Rooms are left automatically upon disconnection</strong>.</p>\n<h2 id=\"socket-to-room\"><a href=\"#socket-to-room\" class=\"headerlink\" title=\"socket.to(room)\"></a>socket.to(room)</h2><ul>\n<li><code>room</code> <em>(String)</em></li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Sets a modifier for a subsequent event emission that the event will only be <em>broadcasted</em> to clients that have joined the given <code>room</code> (the socket itself being excluded).</p>\n<p>To emit to multiple rooms, you can call <code>to</code> several times.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// to one room</span></span><br><span class=\"line\">  socket.to(<span class=\"string\">'others'</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// to multiple rooms</span></span><br><span class=\"line\">  socket.to(<span class=\"string\">'room1'</span>).to(<span class=\"string\">'room2'</span>).emit(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">  <span class=\"comment\">// a private message to another socket</span></span><br><span class=\"line\">  socket.to(<span class=\"comment\">/* another socket id */</span>).emit(<span class=\"string\">'hey'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> acknowledgements are not supported when broadcasting.</p>\n<h2 id=\"socket-in-room\"><a href=\"#socket-in-room\" class=\"headerlink\" title=\"socket.in(room)\"></a>socket.in(room)</h2><p>Synonym of <a href=\"#sockettoroom\">socket.to(room)</a>.</p>\n<h2 id=\"socket-compress-value\"><a href=\"#socket-compress-value\" class=\"headerlink\" title=\"socket.compress(value)\"></a>socket.compress(value)</h2><ul>\n<li><code>value</code> <em>(Boolean)</em> whether to following packet will be compressed</li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Sets a modifier for a subsequent event emission that the event data will only be <em>compressed</em> if the value is <code>true</code>. Defaults to <code>true</code> when you don’t call the method.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.compress(<span class=\"literal\">false</span>).emit(<span class=\"string\">'uncompressed'</span>, <span class=\"string\">\"that's rough\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-disconnect-close\"><a href=\"#socket-disconnect-close\" class=\"headerlink\" title=\"socket.disconnect(close)\"></a>socket.disconnect(close)</h2><ul>\n<li><code>close</code> <em>(Boolean)</em> whether to close the underlying connection</li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Disconnects this client. If value of close is <code>true</code>, closes the underlying connection. Otherwise, it just disconnects the namespace.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> socket.disconnect(<span class=\"literal\">true</span>), <span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘broadcast’\"><a href=\"#Flag-‘broadcast’\" class=\"headerlink\" title=\"Flag: ‘broadcast’\"></a>Flag: ‘broadcast’</h2><p>Sets a modifier for a subsequent event emission that the event data will only be <em>broadcast</em> to every sockets but the sender.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.broadcast.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;); <span class=\"comment\">// everyone gets it but the sender</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘volatile’-1\"><a href=\"#Flag-‘volatile’-1\" class=\"headerlink\" title=\"Flag: ‘volatile’\"></a>Flag: ‘volatile’</h2><p>Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.volatile.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;); <span class=\"comment\">// the client may or may not receive it</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘binary’-1\"><a href=\"#Flag-‘binary’-1\" class=\"headerlink\" title=\"Flag: ‘binary’\"></a>Flag: ‘binary’</h2><p>Specifies whether there is binary data in the emitted data. Increases performance when specified. Can be <code>true</code> or <code>false</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.binary(<span class=\"literal\">false</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;); <span class=\"comment\">// The data to send has no binary data</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘disconnect’\"><a href=\"#Event-‘disconnect’\" class=\"headerlink\" title=\"Event: ‘disconnect’\"></a>Event: ‘disconnect’</h2><ul>\n<li><code>reason</code> <em>(String)</em> the reason of the disconnection (either client or server-side)</li>\n</ul>\n<p>Fired upon disconnection.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, (reason) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘error’\"><a href=\"#Event-‘error’\" class=\"headerlink\" title=\"Event: ‘error’\"></a>Event: ‘error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired when an error occurs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'error'</span>, (error) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘disconnecting’\"><a href=\"#Event-‘disconnecting’\" class=\"headerlink\" title=\"Event: ‘disconnecting’\"></a>Event: ‘disconnecting’</h2><ul>\n<li><code>reason</code> <em>(String)</em> the reason of the disconnection (either client or server-side)</li>\n</ul>\n<p>Fired when the client is going to be disconnected (but hasn’t left its <code>rooms</code> yet).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnecting'</span>, (reason) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rooms = <span class=\"built_in\">Object</span>.keys(socket.rooms);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>These are reserved events (along with <code>connect</code>, <code>newListener</code> and <code>removeListener</code>) which cannot be used as event names.</p>\n<h1 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h1><p>The <code>Client</code> class represents an incoming transport (engine.io) connection. A <code>Client</code> can be associated with many multiplexed <code>Socket</code>s that belong to different <code>Namespace</code>s.</p>\n<h2 id=\"client-conn\"><a href=\"#client-conn\" class=\"headerlink\" title=\"client.conn\"></a>client.conn</h2><ul>\n<li><em>(engine.Socket)</em></li>\n</ul>\n<p>A reference to the underlying <code>engine.io</code> <code>Socket</code> connection.</p>\n<h2 id=\"client-request\"><a href=\"#client-request\" class=\"headerlink\" title=\"client.request\"></a>client.request</h2><ul>\n<li><em>(Request)</em></li>\n</ul>\n<p>A getter proxy that returns the reference to the <code>request</code> that originated the engine.io connection. Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h1><p>Exposed by <code>require(&#39;socket.io&#39;)</code>.</p>\n<h2 id=\"new-Server-httpServer-options\"><a href=\"#new-Server-httpServer-options\" class=\"headerlink\" title=\"new Server(httpServer[, options])\"></a>new Server(httpServer[, options])</h2><ul>\n<li><code>httpServer</code> <em>(http.Server)</em> the server to bind to.</li>\n<li><code>options</code> <em>(Object)</em><ul>\n<li><code>path</code> <em>(String)</em>: name of the path to capture (<code>/socket.io</code>)</li>\n<li><code>serveClient</code> <em>(Boolean)</em>: whether to serve the client files (<code>true</code>)</li>\n<li><code>adapter</code> <em>(Adapter)</em>: the adapter to use. Defaults to an instance of the <code>Adapter</code> that ships with socket.io which is memory based. See <a href=\"https://github.com/socketio/socket.io-adapter\" target=\"_blank\" rel=\"noopener\">socket.io-adapter</a></li>\n<li><code>origins</code> <em>(String)</em>: the allowed origins (<code>*</code>)</li>\n<li><code>parser</code> <em>(Parser)</em>: the parser to use. Defaults to an instance of the <code>Parser</code> that ships with socket.io. See <a href=\"https://github.com/socketio/socket.io-parser\" target=\"_blank\" rel=\"noopener\">socket.io-parser</a>.</li>\n</ul>\n</li>\n</ul>\n<p>Works with and without <code>new</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Server = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"keyword\">new</span> Server();</span><br></pre></td></tr></table></figure>\n<p>The same options passed to socket.io are always passed to the <code>engine.io</code> <code>Server</code> that gets created. See engine.io <a href=\"https://github.com/socketio/engine.io#methods-1\" target=\"_blank\" rel=\"noopener\">options</a> as reference.</p>\n<p>Among those options:</p>\n<ul>\n<li><code>pingTimeout</code> <em>(Number)</em>: how many ms without a pong packet to consider the connection closed (<code>60000</code>)</li>\n<li><code>pingInterval</code> <em>(Number)</em>: how many ms before sending a new ping packet (<code>25000</code>).</li>\n</ul>\n<p>Those two parameters will impact the delay before a client knows the server is not available anymore. For example, if the underlying TCP connection is not closed properly due to a network issue, a client may have to wait up to <code>pingTimeout + pingInterval</code> ms before getting a <code>disconnect</code> event.</p>\n<ul>\n<li><code>transports</code> <em>(Array<string>)</string></em>: transports to allow connections to (<code>[&#39;polling&#39;, &#39;websocket&#39;]</code>).</li>\n</ul>\n<p><strong>Note:</strong> The order is important. By default, a long-polling connection is established first, and then upgraded to WebSocket if possible. Using <code>[&#39;websocket&#39;]</code> means there will be no fallback if a WebSocket connection cannot be opened.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(server, &#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/test'</span>,</span><br><span class=\"line\">  serveClient: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// below are engine.IO options</span></span><br><span class=\"line\">  pingInterval: <span class=\"number\">10000</span>,</span><br><span class=\"line\">  pingTimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">  cookie: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"new-Server-port-options\"><a href=\"#new-Server-port-options\" class=\"headerlink\" title=\"new Server(port[, options])\"></a>new Server(port[, options])</h2><ul>\n<li><code>port</code> <em>(Number)</em> a port to listen to (a new <code>http.Server</code> will be created)</li>\n<li><code>options</code> <em>(Object)</em></li>\n</ul>\n<p>See <a href=\"#new-serverhttpserver-options\">above</a> for available options.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">3000</span>, &#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/test'</span>,</span><br><span class=\"line\">  serveClient: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// below are engine.IO options</span></span><br><span class=\"line\">  pingInterval: <span class=\"number\">10000</span>,</span><br><span class=\"line\">  pingTimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">  cookie: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"new-Server-options\"><a href=\"#new-Server-options\" class=\"headerlink\" title=\"new Server(options)\"></a>new Server(options)</h2><ul>\n<li><code>options</code> <em>(Object)</em></li>\n</ul>\n<p>See <a href=\"#new-serverhttpserver-options\">above</a> for available options.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/test'</span>,</span><br><span class=\"line\">  serveClient: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// either</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).createServer();</span><br><span class=\"line\"></span><br><span class=\"line\">io.attach(server, &#123;</span><br><span class=\"line\">  pingInterval: <span class=\"number\">10000</span>,</span><br><span class=\"line\">  pingTimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">  cookie: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\">io.attach(<span class=\"number\">3000</span>, &#123;</span><br><span class=\"line\">  pingInterval: <span class=\"number\">10000</span>,</span><br><span class=\"line\">  pingTimeout: <span class=\"number\">5000</span>,</span><br><span class=\"line\">  cookie: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-sockets\"><a href=\"#server-sockets\" class=\"headerlink\" title=\"server.sockets\"></a>server.sockets</h2><ul>\n<li><em>(Namespace)</em></li>\n</ul>\n<p>The default (<code>/</code>) namespace.</p>\n<h2 id=\"server-serveClient-value\"><a href=\"#server-serveClient-value\" class=\"headerlink\" title=\"server.serveClient([value])\"></a>server.serveClient([value])</h2><ul>\n<li><code>value</code> <em>(Boolean)</em></li>\n<li><strong>Returns</strong> <code>Server|Boolean</code></li>\n</ul>\n<p>If <code>value</code> is <code>true</code> the attached server (see <code>Server#attach</code>) will serve the client files. Defaults to <code>true</code>. This method has no effect after <code>attach</code> is called. If no arguments are supplied this method returns the current value.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pass a server and the `serveClient` option</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(http, &#123; <span class=\"attr\">serveClient</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or pass no server and then you can call the method</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.serveClient(<span class=\"literal\">false</span>);</span><br><span class=\"line\">io.attach(http);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-path-value\"><a href=\"#server-path-value\" class=\"headerlink\" title=\"server.path([value])\"></a>server.path([value])</h2><ul>\n<li><code>value</code> <em>(String)</em></li>\n<li><strong>Returns</strong> <code>Server|String</code></li>\n</ul>\n<p>Sets the path <code>value</code> under which <code>engine.io</code> and the static files will be served. Defaults to <code>/socket.io</code>. If no arguments are supplied this method returns the current value.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.path(<span class=\"string\">'/myownpath'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// client-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> socket = io(&#123;</span><br><span class=\"line\">  path: <span class=\"string\">'/myownpath'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-adapter-value\"><a href=\"#server-adapter-value\" class=\"headerlink\" title=\"server.adapter([value])\"></a>server.adapter([value])</h2><ul>\n<li><code>value</code> <em>(Adapter)</em></li>\n<li><strong>Returns</strong> <code>Server|Adapter</code></li>\n</ul>\n<p>Sets the adapter <code>value</code>. Defaults to an instance of the <code>Adapter</code> that ships with socket.io which is memory based. See <a href=\"https://github.com/socketio/socket.io-adapter\" target=\"_blank\" rel=\"noopener\">socket.io-adapter</a>. If no arguments are supplied this method returns the current value.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-redis'</span>);</span><br><span class=\"line\">io.adapter(redis(&#123; <span class=\"attr\">host</span>: <span class=\"string\">'localhost'</span>, <span class=\"attr\">port</span>: <span class=\"number\">6379</span> &#125;));</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-origins-value\"><a href=\"#server-origins-value\" class=\"headerlink\" title=\"server.origins([value])\"></a>server.origins([value])</h2><ul>\n<li><code>value</code> <em>(String|String[])</em></li>\n<li><strong>Returns</strong> <code>Server|String</code></li>\n</ul>\n<p>Sets the allowed origins <code>value</code>. Defaults to any origins being allowed. If no arguments are supplied this method returns the current value.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.origins([<span class=\"string\">'https://foo.example.com:443'</span>]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-origins-fn\"><a href=\"#server-origins-fn\" class=\"headerlink\" title=\"server.origins(fn)\"></a>server.origins(fn)</h2><ul>\n<li><code>fn</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Server</code></li>\n</ul>\n<p>Provides a function taking two arguments <code>origin:String</code> and <code>callback(error, success)</code>, where <code>success</code> is a boolean value indicating whether origin is allowed or not.  If <code>success</code> is set to <code>false</code>, <code>error</code> must be provided as a string value that will be appended to the server response, e.g. “Origin not allowed”.</p>\n<p><strong>Potential drawbacks</strong>:</p>\n<ul>\n<li>in some situations, when it is not possible to determine <code>origin</code> it may have value of <code>*</code></li>\n<li>As this function will be executed for every request, it is advised to make this function work as fast as possible</li>\n<li>If <code>socket.io</code> is used together with <code>Express</code>, the CORS headers will be affected only for <code>socket.io</code> requests. For Express you can use <a href=\"https://github.com/expressjs/cors\" target=\"_blank\" rel=\"noopener\">cors</a>.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.origins(<span class=\"function\">(<span class=\"params\">origin, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (origin !== <span class=\"string\">'https://foo.example.com'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback(<span class=\"string\">'origin not allowed'</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  callback(<span class=\"literal\">null</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-attach-httpServer-options\"><a href=\"#server-attach-httpServer-options\" class=\"headerlink\" title=\"server.attach(httpServer[, options])\"></a>server.attach(httpServer[, options])</h2><ul>\n<li><code>httpServer</code> <em>(http.Server)</em> the server to attach to</li>\n<li><code>options</code> <em>(Object)</em></li>\n</ul>\n<p>Attaches the <code>Server</code> to an engine.io instance on <code>httpServer</code> with the supplied <code>options</code> (optionally).</p>\n<h2 id=\"server-attach-port-options\"><a href=\"#server-attach-port-options\" class=\"headerlink\" title=\"server.attach(port[, options])\"></a>server.attach(port[, options])</h2><ul>\n<li><code>port</code> <em>(Number)</em> the port to listen on</li>\n<li><code>options</code> <em>(Object)</em></li>\n</ul>\n<p>Attaches the <code>Server</code> to an engine.io instance on a new http.Server with the supplied <code>options</code> (optionally).</p>\n<h2 id=\"server-listen-httpServer-options\"><a href=\"#server-listen-httpServer-options\" class=\"headerlink\" title=\"server.listen(httpServer[, options])\"></a>server.listen(httpServer[, options])</h2><p>Synonym of <a href=\"#serverattachhttpserver-options\">server.attach(httpServer[, options])</a>.</p>\n<h2 id=\"server-listen-port-options\"><a href=\"#server-listen-port-options\" class=\"headerlink\" title=\"server.listen(port[, options])\"></a>server.listen(port[, options])</h2><p>Synonym of <a href=\"#serverattachport-options\">server.attach(port[, options])</a>.</p>\n<h2 id=\"server-bind-engine\"><a href=\"#server-bind-engine\" class=\"headerlink\" title=\"server.bind(engine)\"></a>server.bind(engine)</h2><ul>\n<li><code>engine</code> <em>(engine.Server)</em></li>\n<li><strong>Returns</strong> <code>Server</code></li>\n</ul>\n<p>Advanced use only. Binds the server to a specific engine.io <code>Server</code> (or compatible API) instance.</p>\n<h2 id=\"server-onconnection-socket\"><a href=\"#server-onconnection-socket\" class=\"headerlink\" title=\"server.onconnection(socket)\"></a>server.onconnection(socket)</h2><ul>\n<li><code>socket</code> <em>(engine.Socket)</em></li>\n<li><strong>Returns</strong> <code>Server</code></li>\n</ul>\n<p>Advanced use only. Creates a new <code>socket.io</code> client from the incoming engine.io (or compatible API) <code>Socket</code>.</p>\n<h2 id=\"server-of-nsp\"><a href=\"#server-of-nsp\" class=\"headerlink\" title=\"server.of(nsp)\"></a>server.of(nsp)</h2><ul>\n<li><code>nsp</code> <em>(String|RegExp|Function)</em></li>\n<li><strong>Returns</strong> <code>Namespace</code></li>\n</ul>\n<p>Initializes and retrieves the given <code>Namespace</code> by its pathname identifier <code>nsp</code>. If the namespace was already initialized it returns it immediately.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adminNamespace = io.of(<span class=\"string\">'/admin'</span>);</span><br></pre></td></tr></table></figure>\n<p>A regex or a function can also be provided, in order to create namespace in a dynamic way:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dynamicNsp = io.of(<span class=\"regexp\">/^\\/dynamic-\\d+$/</span>).on(<span class=\"string\">'connect'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newNamespace = socket.nsp; <span class=\"comment\">// newNamespace.name === '/dynamic-101'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// broadcast to all clients in the given sub-namespace</span></span><br><span class=\"line\">  newNamespace.emit(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// client-side</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> socket = io(<span class=\"string\">'/dynamic-101'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// broadcast to all clients in each sub-namespace</span></span><br><span class=\"line\">dynamicNsp.emit(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// use a middleware for each sub-namespace</span></span><br><span class=\"line\">dynamicNsp.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123; <span class=\"comment\">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>With a function:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.of(<span class=\"function\">(<span class=\"params\">name, query, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  next(<span class=\"literal\">null</span>, checkToken(query.token));</span><br><span class=\"line\">&#125;).on(<span class=\"string\">'connect'</span>, (socket) =&gt; &#123; <span class=\"comment\">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-close-callback\"><a href=\"#server-close-callback\" class=\"headerlink\" title=\"server.close([callback])\"></a>server.close([callback])</h2><ul>\n<li><code>callback</code> <em>(Function)</em></li>\n</ul>\n<p>Closes the socket.io server. The <code>callback</code> argument is optional and will be called when all connections are closed.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Server = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> PORT   = <span class=\"number\">3030</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).Server();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> io = Server(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">io.close(); <span class=\"comment\">// Close current server</span></span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(PORT); <span class=\"comment\">// PORT is free to use</span></span><br><span class=\"line\"></span><br><span class=\"line\">io = Server(server);</span><br></pre></td></tr></table></figure>\n<h2 id=\"server-engine-generateId\"><a href=\"#server-engine-generateId\" class=\"headerlink\" title=\"server.engine.generateId\"></a>server.engine.generateId</h2><p>Overwrites the default method to generate your custom socket id.</p>\n<p>The function is called with a node request object (<code>http.IncomingMessage</code>) as first parameter.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.engine.generateId = <span class=\"function\">(<span class=\"params\">req</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"custom:id:\"</span> + custom_id++; <span class=\"comment\">// custom id must be unique</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Namespace\"><a href=\"#Namespace\" class=\"headerlink\" title=\"Namespace\"></a>Namespace</h1><p>Represents a pool of sockets connected under a given scope identified<br>by a pathname (eg: <code>/chat</code>).</p>\n<p>A client always connects to <code>/</code> (the main namespace), then potentially connect to other namespaces (while using the same underlying connection).</p>\n<h2 id=\"namespace-name\"><a href=\"#namespace-name\" class=\"headerlink\" title=\"namespace.name\"></a>namespace.name</h2><ul>\n<li><em>(String)</em></li>\n</ul>\n<p>The namespace identifier property.</p>\n<h2 id=\"namespace-connected\"><a href=\"#namespace-connected\" class=\"headerlink\" title=\"namespace.connected\"></a>namespace.connected</h2><ul>\n<li><em>(Object<socket>)</socket></em></li>\n</ul>\n<p>The hash of <code>Socket</code> objects that are connected to this namespace, indexed by <code>id</code>.</p>\n<h2 id=\"namespace-adapter\"><a href=\"#namespace-adapter\" class=\"headerlink\" title=\"namespace.adapter\"></a>namespace.adapter</h2><ul>\n<li><em>(Adapter)</em></li>\n</ul>\n<p>The <code>Adapter</code> used for the namespace. Useful when using the <code>Adapter</code> based on <a href=\"https://github.com/socketio/socket.io-redis\" target=\"_blank\" rel=\"noopener\">Redis</a>, as it exposes methods to manage sockets and rooms accross your cluster.</p>\n<p><strong>Note:</strong> the adapter of the main namespace can be accessed with <code>io.of(&#39;/&#39;).adapter</code>.</p>\n<h2 id=\"namespace-to-room\"><a href=\"#namespace-to-room\" class=\"headerlink\" title=\"namespace.to(room)\"></a>namespace.to(room)</h2><ul>\n<li><code>room</code> <em>(String)</em></li>\n<li><strong>Returns</strong> <code>Namespace</code> for chaining</li>\n</ul>\n<p>Sets a modifier for a subsequent event emission that the event will only be <em>broadcasted</em> to clients that have joined the given <code>room</code>.</p>\n<p>To emit to multiple rooms, you can call <code>to</code> several times.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">const</span> adminNamespace = io.of(<span class=\"string\">'/admin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">adminNamespace.to(<span class=\"string\">'level1'</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"namespace-in-room\"><a href=\"#namespace-in-room\" class=\"headerlink\" title=\"namespace.in(room)\"></a>namespace.in(room)</h2><p>Synonym of <a href=\"#namespacetoroom\">namespace.to(room)</a>.</p>\n<h2 id=\"namespace-emit-eventName-…args\"><a href=\"#namespace-emit-eventName-…args\" class=\"headerlink\" title=\"namespace.emit(eventName[, …args])\"></a>namespace.emit(eventName[, …args])</h2><ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>args</code></li>\n</ul>\n<p>Emits an event to all connected clients. The following two are equivalent:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.emit(<span class=\"string\">'an event sent to all connected clients'</span>); <span class=\"comment\">// main namespace</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> chat = io.of(<span class=\"string\">'/chat'</span>);</span><br><span class=\"line\">chat.emit(<span class=\"string\">'an event sent to all connected clients in chat namespace'</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> acknowledgements are not supported when emitting from namespace.</p>\n<h2 id=\"namespace-clients-callback\"><a href=\"#namespace-clients-callback\" class=\"headerlink\" title=\"namespace.clients(callback)\"></a>namespace.clients(callback)</h2><ul>\n<li><code>callback</code> <em>(Function)</em></li>\n</ul>\n<p>Gets a list of client IDs connected to this namespace (across all nodes if applicable).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.of(<span class=\"string\">'/chat'</span>).clients(<span class=\"function\">(<span class=\"params\">error, clients</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clients); <span class=\"comment\">// =&gt; [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>An example to get all clients in namespace’s room:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.of(<span class=\"string\">'/chat'</span>).in(<span class=\"string\">'general'</span>).clients(<span class=\"function\">(<span class=\"params\">error, clients</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clients); <span class=\"comment\">// =&gt; [Anw2LatarvGVVXEIAAAD]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>As with broadcasting, the default is all clients from the default namespace (‘/‘):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.clients(<span class=\"function\">(<span class=\"params\">error, clients</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clients); <span class=\"comment\">// =&gt; [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"namespace-use-fn\"><a href=\"#namespace-use-fn\" class=\"headerlink\" title=\"namespace.use(fn)\"></a>namespace.use(fn)</h2><ul>\n<li><code>fn</code> <em>(Function)</em></li>\n</ul>\n<p>Registers a middleware, which is a function that gets executed for every incoming <code>Socket</code>, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.</p>\n<p>Errors passed to middleware callbacks are sent as special <code>error</code> packets to clients.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (socket.request.headers.cookie) <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">  next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Authentication error'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘connect’\"><a href=\"#Event-‘connect’\" class=\"headerlink\" title=\"Event: ‘connect’\"></a>Event: ‘connect’</h2><ul>\n<li><code>socket</code> <em>(Socket)</em> socket connection with client</li>\n</ul>\n<p>Fired upon a connection from client.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connect'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.of(<span class=\"string\">'/admin'</span>).on(<span class=\"string\">'connect'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘connection’\"><a href=\"#Event-‘connection’\" class=\"headerlink\" title=\"Event: ‘connection’\"></a>Event: ‘connection’</h2><p>Synonym of <a href=\"#event-connect\">Event: ‘connect’</a>.</p>\n<h2 id=\"Flag-‘volatile’\"><a href=\"#Flag-‘volatile’\" class=\"headerlink\" title=\"Flag: ‘volatile’\"></a>Flag: ‘volatile’</h2><p>Sets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.volatile.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;); <span class=\"comment\">// the clients may or may not receive it</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘binary’\"><a href=\"#Flag-‘binary’\" class=\"headerlink\" title=\"Flag: ‘binary’\"></a>Flag: ‘binary’</h2><p>Specifies whether there is binary data in the emitted data. Increases performance when specified. Can be <code>true</code> or <code>false</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.binary(<span class=\"literal\">false</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘local’\"><a href=\"#Flag-‘local’\" class=\"headerlink\" title=\"Flag: ‘local’\"></a>Flag: ‘local’</h2><p>Sets a modifier for a subsequent event emission that the event data will only be <em>broadcast</em> to the current node (when the <a href=\"https://github.com/socketio/socket.io-redis\" target=\"_blank\" rel=\"noopener\">Redis adapter</a> is used).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.local.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1><p>A <code>Socket</code> is the fundamental class for interacting with browser clients. A <code>Socket</code> belongs to a certain <code>Namespace</code> (by default <code>/</code>) and uses an underlying <code>Client</code> to communicate.</p>\n<p>It should be noted the <code>Socket</code> doesn’t relate directly to the actual underlying TCP/IP <code>socket</code> and it is only the name of the class.</p>\n<p>Within each <code>Namespace</code>, you can also define arbitrary channels (called <code>room</code>) that the <code>Socket</code> can join and leave. That provides a convenient way to broadcast to a group of <code>Socket</code>s (see <code>Socket#to</code> below).</p>\n<p>The <code>Socket</code> class inherits from <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\" target=\"_blank\" rel=\"noopener\">EventEmitter</a>. The <code>Socket</code> class overrides the <code>emit</code> method, and does not modify any other <code>EventEmitter</code> method. All methods documented here which also appear as <code>EventEmitter</code> methods (apart from <code>emit</code>) are implemented by <code>EventEmitter</code>, and documentation for <code>EventEmitter</code> applies.</p>\n<h2 id=\"socket-id\"><a href=\"#socket-id\" class=\"headerlink\" title=\"socket.id\"></a>socket.id</h2><ul>\n<li><em>(String)</em></li>\n</ul>\n<p>A unique identifier for the session, that comes from the underlying <code>Client</code>.</p>\n<h2 id=\"socket-rooms\"><a href=\"#socket-rooms\" class=\"headerlink\" title=\"socket.rooms\"></a>socket.rooms</h2><ul>\n<li><em>(Object)</em></li>\n</ul>\n<p>A hash of strings identifying the rooms this client is in, indexed by room name.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.join(<span class=\"string\">'room 237'</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rooms = <span class=\"built_in\">Object</span>.keys(socket.rooms);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(rooms); <span class=\"comment\">// [ &lt;socket.id&gt;, 'room 237' ]</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-client\"><a href=\"#socket-client\" class=\"headerlink\" title=\"socket.client\"></a>socket.client</h2><ul>\n<li><em>(Client)</em></li>\n</ul>\n<p>A reference to the underlying <code>Client</code> object.</p>\n<h2 id=\"socket-conn\"><a href=\"#socket-conn\" class=\"headerlink\" title=\"socket.conn\"></a>socket.conn</h2><ul>\n<li><em>(engine.Socket)</em></li>\n</ul>\n<p>A reference to the underlying <code>Client</code> transport connection (engine.io <code>Socket</code> object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.</p>\n<h2 id=\"socket-request\"><a href=\"#socket-request\" class=\"headerlink\" title=\"socket.request\"></a>socket.request</h2><ul>\n<li><em>(Request)</em></li>\n</ul>\n<p>A getter proxy that returns the reference to the <code>request</code> that originated the underlying engine.io <code>Client</code>. Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.</p>\n<h2 id=\"socket-handshake\"><a href=\"#socket-handshake\" class=\"headerlink\" title=\"socket.handshake\"></a>socket.handshake</h2><ul>\n<li><em>(Object)</em></li>\n</ul>\n<p>The handshake details:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  headers: <span class=\"comment\">/* the headers sent as part of the handshake */</span>,</span><br><span class=\"line\">  time: <span class=\"comment\">/* the date of creation (as string) */</span>,</span><br><span class=\"line\">  address: <span class=\"comment\">/* the ip of the client */</span>,</span><br><span class=\"line\">  xdomain: <span class=\"comment\">/* whether the connection is cross-domain */</span>,</span><br><span class=\"line\">  secure: <span class=\"comment\">/* whether the connection is secure */</span>,</span><br><span class=\"line\">  issued: <span class=\"comment\">/* the date of creation (as unix timestamp) */</span>,</span><br><span class=\"line\">  url: <span class=\"comment\">/* the request URL string */</span>,</span><br><span class=\"line\">  query: <span class=\"comment\">/* the query object */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Usage:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.use(<span class=\"function\">(<span class=\"params\">socket, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handshake = socket.handshake;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handshake = socket.handshake;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-use-fn\"><a href=\"#socket-use-fn\" class=\"headerlink\" title=\"socket.use(fn)\"></a>socket.use(fn)</h2><ul>\n<li><code>fn</code> <em>(Function)</em></li>\n</ul>\n<p>Registers a middleware, which is a function that gets executed for every incoming <code>Packet</code> and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.</p>\n<p>Errors passed to middleware callbacks are sent as special <code>error</code> packets to clients.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.use(<span class=\"function\">(<span class=\"params\">packet, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (packet.doge === <span class=\"literal\">true</span>) <span class=\"keyword\">return</span> next();</span><br><span class=\"line\">    next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Not a doge error'</span>));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-send-…args-ack\"><a href=\"#socket-send-…args-ack\" class=\"headerlink\" title=\"socket.send([…args][, ack])\"></a>socket.send([…args][, ack])</h2><ul>\n<li><code>args</code></li>\n<li><code>ack</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Sends a <code>message</code> event. See <a href=\"#socketemiteventname-args-ack\">socket.emit(eventName[, …args][, ack])</a>.</p>\n<h2 id=\"socket-emit-eventName-…args-ack\"><a href=\"#socket-emit-eventName-…args-ack\" class=\"headerlink\" title=\"socket.emit(eventName[, …args][, ack])\"></a>socket.emit(eventName[, …args][, ack])</h2><p><em>(overrides <code>EventEmitter.emit</code>)</em></p>\n<ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>args</code></li>\n<li><code>ack</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including <code>Buffer</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.emit(<span class=\"string\">'hello'</span>, <span class=\"string\">'world'</span>);</span><br><span class=\"line\">socket.emit(<span class=\"string\">'with-binary'</span>, <span class=\"number\">1</span>, <span class=\"string\">'2'</span>, &#123; <span class=\"number\">3</span>: <span class=\"string\">'4'</span>, <span class=\"number\">5</span>: <span class=\"keyword\">new</span> Buffer(<span class=\"number\">6</span>) &#125;);</span><br></pre></td></tr></table></figure>\n<p>The <code>ack</code> argument is optional and will be called with the client’s answer.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  socket.emit(<span class=\"string\">'ferret'</span>, <span class=\"string\">'tobi'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// data will be 'woot'</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// the client code</span></span><br><span class=\"line\">  <span class=\"comment\">// client.on('ferret', (name, fn) =&gt; &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   fn('woot');</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-on-eventName-callback\"><a href=\"#socket-on-eventName-callback\" class=\"headerlink\" title=\"socket.on(eventName, callback)\"></a>socket.on(eventName, callback)</h2><p><em>(inherited from <code>EventEmitter</code>)</em></p>\n<ul>\n<li><code>eventName</code> <em>(String)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Register a new handler for the given event.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// with several arguments</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (arg1, arg2, arg3) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// or with acknowledgement</span></span><br><span class=\"line\">socket.on(<span class=\"string\">'news'</span>, (data, callback) =&gt; &#123;</span><br><span class=\"line\">  callback(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-once-eventName-listener\"><a href=\"#socket-once-eventName-listener\" class=\"headerlink\" title=\"socket.once(eventName, listener)\"></a>socket.once(eventName, listener)</h2><h2 id=\"socket-removeListener-eventName-listener\"><a href=\"#socket-removeListener-eventName-listener\" class=\"headerlink\" title=\"socket.removeListener(eventName, listener)\"></a>socket.removeListener(eventName, listener)</h2><h2 id=\"socket-removeAllListeners-eventName\"><a href=\"#socket-removeAllListeners-eventName\" class=\"headerlink\" title=\"socket.removeAllListeners([eventName])\"></a>socket.removeAllListeners([eventName])</h2><h2 id=\"socket-eventNames\"><a href=\"#socket-eventNames\" class=\"headerlink\" title=\"socket.eventNames()\"></a>socket.eventNames()</h2><p>Inherited from <code>EventEmitter</code> (along with other methods not mentioned here). See Node.js documentation for the <code>events</code> module.</p>\n<h2 id=\"socket-join-room-callback\"><a href=\"#socket-join-room-callback\" class=\"headerlink\" title=\"socket.join(room[, callback])\"></a>socket.join(room[, callback])</h2><ul>\n<li><code>room</code> <em>(String)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Adds the client to the <code>room</code>, and fires optionally a callback with <code>err</code> signature (if any).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.join(<span class=\"string\">'room 237'</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rooms = <span class=\"built_in\">Object</span>.keys(socket.rooms);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(rooms); <span class=\"comment\">// [ &lt;socket.id&gt;, 'room 237' ]</span></span><br><span class=\"line\">    io.to(<span class=\"string\">'room 237'</span>).emit(<span class=\"string\">'a new user has joined the room'</span>); <span class=\"comment\">// broadcast to everyone in the room</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The mechanics of joining rooms are handled by the <code>Adapter</code> that has been configured (see <code>Server#adapter</code> above), defaulting to <a href=\"https://github.com/socketio/socket.io-adapter\" target=\"_blank\" rel=\"noopener\">socket.io-adapter</a>.</p>\n<p>For your convenience, each socket automatically joins a room identified by its id (see <code>Socket#id</code>). This makes it easy to broadcast messages to other sockets:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'say to someone'</span>, (id, msg) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// send a private message to the socket with the given id</span></span><br><span class=\"line\">    socket.to(id).emit(<span class=\"string\">'my message'</span>, msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-join-rooms-callback\"><a href=\"#socket-join-rooms-callback\" class=\"headerlink\" title=\"socket.join(rooms[, callback])\"></a>socket.join(rooms[, callback])</h2><ul>\n<li><code>rooms</code> <em>(Array)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Adds the client to the list of room, and fires optionally a callback with <code>err</code> signature (if any).</p>\n<h2 id=\"socket-leave-room-callback\"><a href=\"#socket-leave-room-callback\" class=\"headerlink\" title=\"socket.leave(room[, callback])\"></a>socket.leave(room[, callback])</h2><ul>\n<li><code>room</code> <em>(String)</em></li>\n<li><code>callback</code> <em>(Function)</em></li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Removes the client from <code>room</code>, and fires optionally a callback with <code>err</code> signature (if any).</p>\n<p><strong>Rooms are left automatically upon disconnection</strong>.</p>\n<h2 id=\"socket-to-room\"><a href=\"#socket-to-room\" class=\"headerlink\" title=\"socket.to(room)\"></a>socket.to(room)</h2><ul>\n<li><code>room</code> <em>(String)</em></li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Sets a modifier for a subsequent event emission that the event will only be <em>broadcasted</em> to clients that have joined the given <code>room</code> (the socket itself being excluded).</p>\n<p>To emit to multiple rooms, you can call <code>to</code> several times.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// to one room</span></span><br><span class=\"line\">  socket.to(<span class=\"string\">'others'</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// to multiple rooms</span></span><br><span class=\"line\">  socket.to(<span class=\"string\">'room1'</span>).to(<span class=\"string\">'room2'</span>).emit(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">  <span class=\"comment\">// a private message to another socket</span></span><br><span class=\"line\">  socket.to(<span class=\"comment\">/* another socket id */</span>).emit(<span class=\"string\">'hey'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>Note:</strong> acknowledgements are not supported when broadcasting.</p>\n<h2 id=\"socket-in-room\"><a href=\"#socket-in-room\" class=\"headerlink\" title=\"socket.in(room)\"></a>socket.in(room)</h2><p>Synonym of <a href=\"#sockettoroom\">socket.to(room)</a>.</p>\n<h2 id=\"socket-compress-value\"><a href=\"#socket-compress-value\" class=\"headerlink\" title=\"socket.compress(value)\"></a>socket.compress(value)</h2><ul>\n<li><code>value</code> <em>(Boolean)</em> whether to following packet will be compressed</li>\n<li><strong>Returns</strong> <code>Socket</code> for chaining</li>\n</ul>\n<p>Sets a modifier for a subsequent event emission that the event data will only be <em>compressed</em> if the value is <code>true</code>. Defaults to <code>true</code> when you don’t call the method.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.compress(<span class=\"literal\">false</span>).emit(<span class=\"string\">'uncompressed'</span>, <span class=\"string\">\"that's rough\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"socket-disconnect-close\"><a href=\"#socket-disconnect-close\" class=\"headerlink\" title=\"socket.disconnect(close)\"></a>socket.disconnect(close)</h2><ul>\n<li><code>close</code> <em>(Boolean)</em> whether to close the underlying connection</li>\n<li><strong>Returns</strong> <code>Socket</code></li>\n</ul>\n<p>Disconnects this client. If value of close is <code>true</code>, closes the underlying connection. Otherwise, it just disconnects the namespace.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> socket.disconnect(<span class=\"literal\">true</span>), <span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘broadcast’\"><a href=\"#Flag-‘broadcast’\" class=\"headerlink\" title=\"Flag: ‘broadcast’\"></a>Flag: ‘broadcast’</h2><p>Sets a modifier for a subsequent event emission that the event data will only be <em>broadcast</em> to every sockets but the sender.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.broadcast.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;); <span class=\"comment\">// everyone gets it but the sender</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘volatile’-1\"><a href=\"#Flag-‘volatile’-1\" class=\"headerlink\" title=\"Flag: ‘volatile’\"></a>Flag: ‘volatile’</h2><p>Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.volatile.emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;); <span class=\"comment\">// the client may or may not receive it</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Flag-‘binary’-1\"><a href=\"#Flag-‘binary’-1\" class=\"headerlink\" title=\"Flag: ‘binary’\"></a>Flag: ‘binary’</h2><p>Specifies whether there is binary data in the emitted data. Increases performance when specified. Can be <code>true</code> or <code>false</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)();</span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.binary(<span class=\"literal\">false</span>).emit(<span class=\"string\">'an event'</span>, &#123; <span class=\"attr\">some</span>: <span class=\"string\">'data'</span> &#125;); <span class=\"comment\">// The data to send has no binary data</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘disconnect’\"><a href=\"#Event-‘disconnect’\" class=\"headerlink\" title=\"Event: ‘disconnect’\"></a>Event: ‘disconnect’</h2><ul>\n<li><code>reason</code> <em>(String)</em> the reason of the disconnection (either client or server-side)</li>\n</ul>\n<p>Fired upon disconnection.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, (reason) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘error’\"><a href=\"#Event-‘error’\" class=\"headerlink\" title=\"Event: ‘error’\"></a>Event: ‘error’</h2><ul>\n<li><code>error</code> <em>(Object)</em> error object</li>\n</ul>\n<p>Fired when an error occurs.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'error'</span>, (error) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Event-‘disconnecting’\"><a href=\"#Event-‘disconnecting’\" class=\"headerlink\" title=\"Event: ‘disconnecting’\"></a>Event: ‘disconnecting’</h2><ul>\n<li><code>reason</code> <em>(String)</em> the reason of the disconnection (either client or server-side)</li>\n</ul>\n<p>Fired when the client is going to be disconnected (but hasn’t left its <code>rooms</code> yet).</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, (socket) =&gt; &#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnecting'</span>, (reason) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rooms = <span class=\"built_in\">Object</span>.keys(socket.rooms);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>These are reserved events (along with <code>connect</code>, <code>newListener</code> and <code>removeListener</code>) which cannot be used as event names.</p>\n<h1 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h1><p>The <code>Client</code> class represents an incoming transport (engine.io) connection. A <code>Client</code> can be associated with many multiplexed <code>Socket</code>s that belong to different <code>Namespace</code>s.</p>\n<h2 id=\"client-conn\"><a href=\"#client-conn\" class=\"headerlink\" title=\"client.conn\"></a>client.conn</h2><ul>\n<li><em>(engine.Socket)</em></li>\n</ul>\n<p>A reference to the underlying <code>engine.io</code> <code>Socket</code> connection.</p>\n<h2 id=\"client-request\"><a href=\"#client-request\" class=\"headerlink\" title=\"client.request\"></a>client.request</h2><ul>\n<li><em>(Request)</em></li>\n</ul>\n<p>A getter proxy that returns the reference to the <code>request</code> that originated the engine.io connection. Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.</p>\n"},{"title":"Socket.IO  —  Using multiple nodes","type":"docs","_content":"\n## Sticky load balancing\n\nIf you plan to distribute the load of connections among different processes or machines, you have to make sure that requests associated with a particular session id connect to the process that originated them.\n\nThis is due to certain transports like XHR Polling or JSONP Polling relying on firing several requests during the lifetime of the &#8220;socket&#8221;.\n\nTo illustrate why this is needed, consider the example of emitting an event to all connected clients:\n\n```js\nio.emit('hi', 'all sockets');\n```\n\nChances are that some of those clients might have an active bi-directional communication channel like `WebSocket` that we can write to immediately, but some of them might be using long-polling.\n\nIf they&#8217;re using long polling, they might or might not have sent a request that we can write to. They could be &#8220;in between&#8221; those requests. In those situations, it means we have to buffer messages in the process. In order for the client to successfully claim those messages when he sends his request, the easiest way is for him to connect to be routed to that same process.\n\nAn easy way to do that is by routing clients based on their originating address. An example follows using the NginX server:\n\n## NginX configuration\n\nWithin the `http { }` section of your `nginx.conf` file, you can declare a `upstream` section with a list of Socket.IO process you want to balance load between:\n\n```\nupstream io_nodes {\n  ip_hash;\n  server 127.0.0.1:6001;\n  server 127.0.0.1:6002;\n  server 127.0.0.1:6003;\n  server 127.0.0.1:6004;\n}\n```\n\nNotice the `ip_hash` instruction that indicates the connections will be sticky.\n\nIn the same `http { }` section, you can declare a `server { }` that points to this upstream. In order for NginX to support and forward the `WebSocket` protocol, we explicitly pass along the required `Upgrade` headers:\n\n```\nserver {\n  listen 3000;\n  server_name io.yourhost.com;\n  location / {\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header Host $host;\n    proxy_http_version 1.1;\n    proxy_pass http://io_nodes;\n  }\n}\n```\n\nMake sure you also configure `worker_processes` in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the `worker_connections` setting within the `events { }` block.\n\n## Using Node.JS Cluster\n\nJust like NginX, Node.JS comes with built-in clustering support through the `cluster` module.\n\nFedor Indutny has created a module called [sticky session](https://github.com/indutny/sticky-session) that ensures file descriptors (ie: connections) are routed based on the originating `remoteAddress` (ie: IP).\n\n## Passing events between nodes\n\nNow that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to everyone (or even everyone in a certain [room](/docs/rooms-and-namespaces/#Rooms)) you&#8217;ll need some way of passing messages between processes or computers.\n\nThe interface in charge of routing messages is what we call the `Adapter`. You can implement your own on top of the [socket.io-adapter](https://github.com/socketio/socket.io-adapter) (by inheriting from it) or you can use the one we provide on top of [Redis](https://redis.io/): [socket.io-redis](https://github.com/socketio/socket.io-redis):\n\n```js\nvar io = require('socket.io')(3000);\nvar redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));\n```\n\nIf you want to pass messages to it from non-socket.io processes, you should look into [&#8220;Sending messages from the outside-world&#8221;](/docs/rooms-and-namespaces/#Sending-messages-from-the-outside-world).\n","source":"docs/using-multiple-nodes.md","raw":"title: Socket.IO  —  Using multiple nodes\npermalink: /docs/using-multiple-nodes/\ntype: docs\n---\n\n## Sticky load balancing\n\nIf you plan to distribute the load of connections among different processes or machines, you have to make sure that requests associated with a particular session id connect to the process that originated them.\n\nThis is due to certain transports like XHR Polling or JSONP Polling relying on firing several requests during the lifetime of the &#8220;socket&#8221;.\n\nTo illustrate why this is needed, consider the example of emitting an event to all connected clients:\n\n```js\nio.emit('hi', 'all sockets');\n```\n\nChances are that some of those clients might have an active bi-directional communication channel like `WebSocket` that we can write to immediately, but some of them might be using long-polling.\n\nIf they&#8217;re using long polling, they might or might not have sent a request that we can write to. They could be &#8220;in between&#8221; those requests. In those situations, it means we have to buffer messages in the process. In order for the client to successfully claim those messages when he sends his request, the easiest way is for him to connect to be routed to that same process.\n\nAn easy way to do that is by routing clients based on their originating address. An example follows using the NginX server:\n\n## NginX configuration\n\nWithin the `http { }` section of your `nginx.conf` file, you can declare a `upstream` section with a list of Socket.IO process you want to balance load between:\n\n```\nupstream io_nodes {\n  ip_hash;\n  server 127.0.0.1:6001;\n  server 127.0.0.1:6002;\n  server 127.0.0.1:6003;\n  server 127.0.0.1:6004;\n}\n```\n\nNotice the `ip_hash` instruction that indicates the connections will be sticky.\n\nIn the same `http { }` section, you can declare a `server { }` that points to this upstream. In order for NginX to support and forward the `WebSocket` protocol, we explicitly pass along the required `Upgrade` headers:\n\n```\nserver {\n  listen 3000;\n  server_name io.yourhost.com;\n  location / {\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header Host $host;\n    proxy_http_version 1.1;\n    proxy_pass http://io_nodes;\n  }\n}\n```\n\nMake sure you also configure `worker_processes` in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the `worker_connections` setting within the `events { }` block.\n\n## Using Node.JS Cluster\n\nJust like NginX, Node.JS comes with built-in clustering support through the `cluster` module.\n\nFedor Indutny has created a module called [sticky session](https://github.com/indutny/sticky-session) that ensures file descriptors (ie: connections) are routed based on the originating `remoteAddress` (ie: IP).\n\n## Passing events between nodes\n\nNow that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to everyone (or even everyone in a certain [room](/docs/rooms-and-namespaces/#Rooms)) you&#8217;ll need some way of passing messages between processes or computers.\n\nThe interface in charge of routing messages is what we call the `Adapter`. You can implement your own on top of the [socket.io-adapter](https://github.com/socketio/socket.io-adapter) (by inheriting from it) or you can use the one we provide on top of [Redis](https://redis.io/): [socket.io-redis](https://github.com/socketio/socket.io-redis):\n\n```js\nvar io = require('socket.io')(3000);\nvar redis = require('socket.io-redis');\nio.adapter(redis({ host: 'localhost', port: 6379 }));\n```\n\nIf you want to pass messages to it from non-socket.io processes, you should look into [&#8220;Sending messages from the outside-world&#8221;](/docs/rooms-and-namespaces/#Sending-messages-from-the-outside-world).\n","date":"2018-07-21T06:00:57.611Z","updated":"2018-07-21T06:00:57.611Z","path":"/docs/using-multiple-nodes/index.html","comments":1,"layout":"page","_id":"cjjxdyebk000cjgcxb5kbxwqg","content":"<h2 id=\"Sticky-load-balancing\"><a href=\"#Sticky-load-balancing\" class=\"headerlink\" title=\"Sticky load balancing\"></a>Sticky load balancing</h2><p>If you plan to distribute the load of connections among different processes or machines, you have to make sure that requests associated with a particular session id connect to the process that originated them.</p>\n<p>This is due to certain transports like XHR Polling or JSONP Polling relying on firing several requests during the lifetime of the &#8220;socket&#8221;.</p>\n<p>To illustrate why this is needed, consider the example of emitting an event to all connected clients:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.emit(<span class=\"string\">'hi'</span>, <span class=\"string\">'all sockets'</span>);</span><br></pre></td></tr></table></figure>\n<p>Chances are that some of those clients might have an active bi-directional communication channel like <code>WebSocket</code> that we can write to immediately, but some of them might be using long-polling.</p>\n<p>If they&#8217;re using long polling, they might or might not have sent a request that we can write to. They could be &#8220;in between&#8221; those requests. In those situations, it means we have to buffer messages in the process. In order for the client to successfully claim those messages when he sends his request, the easiest way is for him to connect to be routed to that same process.</p>\n<p>An easy way to do that is by routing clients based on their originating address. An example follows using the NginX server:</p>\n<h2 id=\"NginX-configuration\"><a href=\"#NginX-configuration\" class=\"headerlink\" title=\"NginX configuration\"></a>NginX configuration</h2><p>Within the <code>http { }</code> section of your <code>nginx.conf</code> file, you can declare a <code>upstream</code> section with a list of Socket.IO process you want to balance load between:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">upstream io_nodes &#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server 127.0.0.1:6001;</span><br><span class=\"line\">  server 127.0.0.1:6002;</span><br><span class=\"line\">  server 127.0.0.1:6003;</span><br><span class=\"line\">  server 127.0.0.1:6004;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Notice the <code>ip_hash</code> instruction that indicates the connections will be sticky.</p>\n<p>In the same <code>http { }</code> section, you can declare a <code>server { }</code> that points to this upstream. In order for NginX to support and forward the <code>WebSocket</code> protocol, we explicitly pass along the required <code>Upgrade</code> headers:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 3000;</span><br><span class=\"line\">  server_name io.yourhost.com;</span><br><span class=\"line\">  location / &#123;</span><br><span class=\"line\">    proxy_set_header Upgrade $http_upgrade;</span><br><span class=\"line\">    proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class=\"line\">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    proxy_set_header Host $host;</span><br><span class=\"line\">    proxy_http_version 1.1;</span><br><span class=\"line\">    proxy_pass http://io_nodes;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Make sure you also configure <code>worker_processes</code> in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the <code>worker_connections</code> setting within the <code>events { }</code> block.</p>\n<h2 id=\"Using-Node-JS-Cluster\"><a href=\"#Using-Node-JS-Cluster\" class=\"headerlink\" title=\"Using Node.JS Cluster\"></a>Using Node.JS Cluster</h2><p>Just like NginX, Node.JS comes with built-in clustering support through the <code>cluster</code> module.</p>\n<p>Fedor Indutny has created a module called <a href=\"https://github.com/indutny/sticky-session\" target=\"_blank\" rel=\"noopener\">sticky session</a> that ensures file descriptors (ie: connections) are routed based on the originating <code>remoteAddress</code> (ie: IP).</p>\n<h2 id=\"Passing-events-between-nodes\"><a href=\"#Passing-events-between-nodes\" class=\"headerlink\" title=\"Passing events between nodes\"></a>Passing events between nodes</h2><p>Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to everyone (or even everyone in a certain <a href=\"/docs/rooms-and-namespaces/#Rooms\">room</a>) you&#8217;ll need some way of passing messages between processes or computers.</p>\n<p>The interface in charge of routing messages is what we call the <code>Adapter</code>. You can implement your own on top of the <a href=\"https://github.com/socketio/socket.io-adapter\" target=\"_blank\" rel=\"noopener\">socket.io-adapter</a> (by inheriting from it) or you can use the one we provide on top of <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener\">Redis</a>: <a href=\"https://github.com/socketio/socket.io-redis\" target=\"_blank\" rel=\"noopener\">socket.io-redis</a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-redis'</span>);</span><br><span class=\"line\">io.adapter(redis(&#123; <span class=\"attr\">host</span>: <span class=\"string\">'localhost'</span>, <span class=\"attr\">port</span>: <span class=\"number\">6379</span> &#125;));</span><br></pre></td></tr></table></figure>\n<p>If you want to pass messages to it from non-socket.io processes, you should look into <a href=\"/docs/rooms-and-namespaces/#Sending-messages-from-the-outside-world\">&#8220;Sending messages from the outside-world&#8221;</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Sticky-load-balancing\"><a href=\"#Sticky-load-balancing\" class=\"headerlink\" title=\"Sticky load balancing\"></a>Sticky load balancing</h2><p>If you plan to distribute the load of connections among different processes or machines, you have to make sure that requests associated with a particular session id connect to the process that originated them.</p>\n<p>This is due to certain transports like XHR Polling or JSONP Polling relying on firing several requests during the lifetime of the &#8220;socket&#8221;.</p>\n<p>To illustrate why this is needed, consider the example of emitting an event to all connected clients:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.emit(<span class=\"string\">'hi'</span>, <span class=\"string\">'all sockets'</span>);</span><br></pre></td></tr></table></figure>\n<p>Chances are that some of those clients might have an active bi-directional communication channel like <code>WebSocket</code> that we can write to immediately, but some of them might be using long-polling.</p>\n<p>If they&#8217;re using long polling, they might or might not have sent a request that we can write to. They could be &#8220;in between&#8221; those requests. In those situations, it means we have to buffer messages in the process. In order for the client to successfully claim those messages when he sends his request, the easiest way is for him to connect to be routed to that same process.</p>\n<p>An easy way to do that is by routing clients based on their originating address. An example follows using the NginX server:</p>\n<h2 id=\"NginX-configuration\"><a href=\"#NginX-configuration\" class=\"headerlink\" title=\"NginX configuration\"></a>NginX configuration</h2><p>Within the <code>http { }</code> section of your <code>nginx.conf</code> file, you can declare a <code>upstream</code> section with a list of Socket.IO process you want to balance load between:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">upstream io_nodes &#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server 127.0.0.1:6001;</span><br><span class=\"line\">  server 127.0.0.1:6002;</span><br><span class=\"line\">  server 127.0.0.1:6003;</span><br><span class=\"line\">  server 127.0.0.1:6004;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Notice the <code>ip_hash</code> instruction that indicates the connections will be sticky.</p>\n<p>In the same <code>http { }</code> section, you can declare a <code>server { }</code> that points to this upstream. In order for NginX to support and forward the <code>WebSocket</code> protocol, we explicitly pass along the required <code>Upgrade</code> headers:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 3000;</span><br><span class=\"line\">  server_name io.yourhost.com;</span><br><span class=\"line\">  location / &#123;</span><br><span class=\"line\">    proxy_set_header Upgrade $http_upgrade;</span><br><span class=\"line\">    proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class=\"line\">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    proxy_set_header Host $host;</span><br><span class=\"line\">    proxy_http_version 1.1;</span><br><span class=\"line\">    proxy_pass http://io_nodes;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Make sure you also configure <code>worker_processes</code> in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the <code>worker_connections</code> setting within the <code>events { }</code> block.</p>\n<h2 id=\"Using-Node-JS-Cluster\"><a href=\"#Using-Node-JS-Cluster\" class=\"headerlink\" title=\"Using Node.JS Cluster\"></a>Using Node.JS Cluster</h2><p>Just like NginX, Node.JS comes with built-in clustering support through the <code>cluster</code> module.</p>\n<p>Fedor Indutny has created a module called <a href=\"https://github.com/indutny/sticky-session\" target=\"_blank\" rel=\"noopener\">sticky session</a> that ensures file descriptors (ie: connections) are routed based on the originating <code>remoteAddress</code> (ie: IP).</p>\n<h2 id=\"Passing-events-between-nodes\"><a href=\"#Passing-events-between-nodes\" class=\"headerlink\" title=\"Passing events between nodes\"></a>Passing events between nodes</h2><p>Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to everyone (or even everyone in a certain <a href=\"/docs/rooms-and-namespaces/#Rooms\">room</a>) you&#8217;ll need some way of passing messages between processes or computers.</p>\n<p>The interface in charge of routing messages is what we call the <code>Adapter</code>. You can implement your own on top of the <a href=\"https://github.com/socketio/socket.io-adapter\" target=\"_blank\" rel=\"noopener\">socket.io-adapter</a> (by inheriting from it) or you can use the one we provide on top of <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener\">Redis</a>: <a href=\"https://github.com/socketio/socket.io-redis\" target=\"_blank\" rel=\"noopener\">socket.io-redis</a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io-redis'</span>);</span><br><span class=\"line\">io.adapter(redis(&#123; <span class=\"attr\">host</span>: <span class=\"string\">'localhost'</span>, <span class=\"attr\">port</span>: <span class=\"number\">6379</span> &#125;));</span><br></pre></td></tr></table></figure>\n<p>If you want to pass messages to it from non-socket.io processes, you should look into <a href=\"/docs/rooms-and-namespaces/#Sending-messages-from-the-outside-world\">&#8220;Sending messages from the outside-world&#8221;</a>.</p>\n"},{"title":"Socket.IO  —  Chat","type":"misc","_content":"\nIn this guide we’ll create a basic chat application. It requires almost no basic prior knowledge of Node.JS or Socket.IO, so it’s ideal for users of all knowledge levels.\n\n## Introduction\n\nWriting a chat application with popular web applications stacks like LAMP (PHP) has traditionally been very hard. It involves polling the server for changes, keeping track of timestamps, and it’s a lot slower than it should be.\n\nSockets have traditionally been the solution around which most realtime chat systems are architected, providing a bi-directional communication channel between a client and a server.\n\nThis means that the server can *push* messages to clients. Whenever you write a chat message, the idea is that the server will get it and push it to all other connected clients.\n\n## The web framework\n\nThe first goal is to setup a simple HTML webpage that serves out a form and a list of messages. We’re going to use the Node.JS web framework `express` to this end. Make sure [Node.JS](https://nodejs.org) is installed.\n\nFirst let’s create a `package.json` manifest file that describes our project. I recommend you place it in a dedicated empty directory (I’ll call mine `chat-example`).\n\n```json\n{\n  \"name\": \"socket-chat-example\",\n  \"version\": \"0.0.1\",\n  \"description\": \"my first socket.io app\",\n  \"dependencies\": {}\n}\n```\n\nNow, in order to easily populate the `dependencies` with the things we need, we’ll use `npm install --save`:\n\n```\nnpm install --save express@4.15.2\n```\n\nNow that express is installed we can create an `index.js` file that will setup our application.\n\n```js\nvar app = require('express')();\nvar http = require('http').Server(app);\n\napp.get('/', function(req, res){\n  res.send('<h1>Hello world</h1>');\n});\n\nhttp.listen(3000, function(){\n  console.log('listening on *:3000');\n});\n```\n\nThis translates into the following:\n\n- Express initializes `app` to be a function handler that you can supply to an HTTP server (as seen in line 2). </li>\n- We define a route handler `/` that gets called when we hit our website home.</li>\n- We make the http server listen on port 3000.</li>\n\nIf you run `node index.js` you should see the following:\n\n<img src=\"/images/chat-1.png\" alt=\"A console saying that the server has started listening on port 3000\">\n\nAnd if you point your browser to `http://localhost:3000`:\n\n<img src=\"/images/chat-2.png\" alt=\"A browser displaying a big 'Hello World'\">\n\n## Serving HTML\n\nSo far in `index.js` we’re calling `res.send` and pass it a HTML string. Our code would look very confusing if we just placed our entire application’s HTML there. Instead, we’re going to create a `index.html` file and serve it.\n\nLet’s refactor our route handler to use `sendFile` instead:\n\n```js\napp.get('/', function(req, res){\n  res.sendFile(__dirname + '/index.html');\n});\n```\n\nAnd populate `index.html` with the following:\n\n```html\n<!doctype html>\n<html>\n  <head>\n    <title>Socket.IO chat</title>\n    <style>\n      * { margin: 0; padding: 0; box-sizing: border-box; }\n      body { font: 13px Helvetica, Arial; }\n      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }\n      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }\n      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }\n      #messages { list-style-type: none; margin: 0; padding: 0; }\n      #messages li { padding: 5px 10px; }\n      #messages li:nth-child(odd) { background: #eee; }\n    </style>\n  </head>\n  <body>\n    <ul id=\"messages\"></ul>\n    <form action=\"\">\n      <input id=\"m\" autocomplete=\"off\" /><button>Send</button>\n    </form>\n  </body>\n</html>\n```\n\nIf you restart the process (by hitting Control+C and running `node index` again) and refresh the page it should look like this:\n\n<img src=\"/images/chat-3.png\" alt=\"A browser displaying an input and a 'Send' button\">\n\n## Integrating Socket.IO\n\nSocket.IO is composed of two parts:\n\n- A server that integrates with (or mounts on) the Node.JS HTTP Server: [socket.io](https://github.com/socketio/socket.io)\n- A client library that loads on the browser side: [socket.io-client](https://github.com/socketio/socket.io-client)\n\nDuring development, `socket.io` serves the client automatically for us, as we’ll see, so for now we only have to install one module:\n\n```\nnpm install --save socket.io\n```\n\nThat will install the module and add the dependency to `package.json`. Now let’s edit `index.js` to add it:\n\n```js\nvar app = require('express')();\nvar http = require('http').Server(app);\nvar io = require('socket.io')(http);\n\napp.get('/', function(req, res){\n  res.sendFile(__dirname + '/index.html');\n});\n\nio.on('connection', function(socket){\n  console.log('a user connected');\n});\n\nhttp.listen(3000, function(){\n  console.log('listening on *:3000');\n});\n```\n\nNotice that I initialize a new instance of `socket.io` by passing the `http` (the HTTP server) object. Then I listen on the `connection` event for incoming sockets, and I log it to the console.\n\nNow in index.html I add the following snippet before the `</body>`:\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io();\n</script>\n```\n\nThat’s all it takes to load the `socket.io-client`, which exposes a `io` global, and then connect.\n\nNotice that I’m not specifying any URL when I call `io()`, since it defaults to trying to connect to the host that serves the page.\n\nIf you now reload the server and the website you should see the console print “a user connected”.\n\nTry opening several tabs, and you’ll see several messages:\n\n<img src=\"/images/chat-4.png\" alt=\"A console displaying several messages, indicating that some users have connected\">\n\nEach socket also fires a special `disconnect` event:\n\n```js\nio.on('connection', function(socket){\n  console.log('a user connected');\n  socket.on('disconnect', function(){\n    console.log('user disconnected');\n  });\n});\n```\n\nThen if you refresh a tab several times you can see it in action:\n\n<img src=\"/images/chat-5.png\" alt=\"A console displaying several messages, indicating that some users have connected and disconnected\">\n\n## Emitting events\n\nThe main idea behind Socket.IO is that you can send and receive any events you want, with any data you want. Any objects that can be encoded as JSON will do, and [binary data](/blog/introducing-socket-io-1-0/#binary) is supported too.\n\nLet’s make it so that when the user types in a message, the server gets it as a `chat message` event. The `script`s section in `index.html` should now look as follows:\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script src=\"https://code.jquery.com/jquery-1.11.1.js\"></script>\n<script>\n  $(function () {\n    var socket = io();\n    $('form').submit(function(){\n      socket.emit('chat message', $('#m').val());\n      $('#m').val('');\n      return false;\n    });\n  });\n</script>\n```\n\nAnd in `index.js` we print out the `chat message` event:\n\n```js\nio.on('connection', function(socket){\n  socket.on('chat message', function(msg){\n    console.log('message: ' + msg);\n  });\n});\n```\n\nThe result should be like the following video:\n\n<video autoplay=\"\" loop=\"\" width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/zboNrGSsai.mp4\"></video>\n\n## Broadcasting\n\nThe next goal is for us to emit the event from the server to the rest of the users.\n\nIn order to send an event to everyone, Socket.IO gives us the `io.emit`:\n\n```js\nio.emit('some event', { for: 'everyone' });\n```\n\nIf you want to send a message to everyone except for a certain socket, we have the `broadcast` flag:\n\n```js\nio.on('connection', function(socket){\n  socket.broadcast.emit('hi');\n});\n```\n\nIn this case, for the sake of simplicity we’ll send the message to everyone, including the sender.\n\n```js\nio.on('connection', function(socket){\n  socket.on('chat message', function(msg){\n    io.emit('chat message', msg);\n  });\n});\n```\n\nAnd on the client side when we capture a `chat message` event we’ll include it in the page. The total client-side JavaScript code now amounts to:\n\n```html\n<script>\n  $(function () {\n    var socket = io();\n    $('form').submit(function(){\n      socket.emit('chat message', $('#m').val());\n      $('#m').val('');\n      return false;\n    });\n    socket.on('chat message', function(msg){\n      $('#messages').append($('<li>').text(msg));\n    });\n  });\n</script>\n```\n\nAnd that completes our chat application, in about 20 lines of code! This is what it looks like:\n\n<video autoplay=\"\" loop=\"\" width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/J4xwRU9DRn.mp4\"></video>\n\n## Homework\n\nHere are some ideas to improve the application:\n\n- Broadcast a message to connected users when someone connects or disconnects\n- Add support for nicknames\n- Don’t send the same message to the user that sent it himself. Instead, append the message directly as soon as he presses enter.\n- Add “{user} is typing” functionality\n- Show who’s online\n- Add private messaging\n- Share your improvements!\n\n## Getting this example\n\nYou can find it on GitHub [here](https://github.com/socketio/chat-example).\n\n```\ngit clone https://github.com/socketio/chat-example.git\n```\n","source":"get-started/chat.md","raw":"title: Socket.IO  —  Chat\npermalink: /get-started/chat/\ntype: misc\n---\n\nIn this guide we’ll create a basic chat application. It requires almost no basic prior knowledge of Node.JS or Socket.IO, so it’s ideal for users of all knowledge levels.\n\n## Introduction\n\nWriting a chat application with popular web applications stacks like LAMP (PHP) has traditionally been very hard. It involves polling the server for changes, keeping track of timestamps, and it’s a lot slower than it should be.\n\nSockets have traditionally been the solution around which most realtime chat systems are architected, providing a bi-directional communication channel between a client and a server.\n\nThis means that the server can *push* messages to clients. Whenever you write a chat message, the idea is that the server will get it and push it to all other connected clients.\n\n## The web framework\n\nThe first goal is to setup a simple HTML webpage that serves out a form and a list of messages. We’re going to use the Node.JS web framework `express` to this end. Make sure [Node.JS](https://nodejs.org) is installed.\n\nFirst let’s create a `package.json` manifest file that describes our project. I recommend you place it in a dedicated empty directory (I’ll call mine `chat-example`).\n\n```json\n{\n  \"name\": \"socket-chat-example\",\n  \"version\": \"0.0.1\",\n  \"description\": \"my first socket.io app\",\n  \"dependencies\": {}\n}\n```\n\nNow, in order to easily populate the `dependencies` with the things we need, we’ll use `npm install --save`:\n\n```\nnpm install --save express@4.15.2\n```\n\nNow that express is installed we can create an `index.js` file that will setup our application.\n\n```js\nvar app = require('express')();\nvar http = require('http').Server(app);\n\napp.get('/', function(req, res){\n  res.send('<h1>Hello world</h1>');\n});\n\nhttp.listen(3000, function(){\n  console.log('listening on *:3000');\n});\n```\n\nThis translates into the following:\n\n- Express initializes `app` to be a function handler that you can supply to an HTTP server (as seen in line 2). </li>\n- We define a route handler `/` that gets called when we hit our website home.</li>\n- We make the http server listen on port 3000.</li>\n\nIf you run `node index.js` you should see the following:\n\n<img src=\"/images/chat-1.png\" alt=\"A console saying that the server has started listening on port 3000\">\n\nAnd if you point your browser to `http://localhost:3000`:\n\n<img src=\"/images/chat-2.png\" alt=\"A browser displaying a big 'Hello World'\">\n\n## Serving HTML\n\nSo far in `index.js` we’re calling `res.send` and pass it a HTML string. Our code would look very confusing if we just placed our entire application’s HTML there. Instead, we’re going to create a `index.html` file and serve it.\n\nLet’s refactor our route handler to use `sendFile` instead:\n\n```js\napp.get('/', function(req, res){\n  res.sendFile(__dirname + '/index.html');\n});\n```\n\nAnd populate `index.html` with the following:\n\n```html\n<!doctype html>\n<html>\n  <head>\n    <title>Socket.IO chat</title>\n    <style>\n      * { margin: 0; padding: 0; box-sizing: border-box; }\n      body { font: 13px Helvetica, Arial; }\n      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }\n      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }\n      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }\n      #messages { list-style-type: none; margin: 0; padding: 0; }\n      #messages li { padding: 5px 10px; }\n      #messages li:nth-child(odd) { background: #eee; }\n    </style>\n  </head>\n  <body>\n    <ul id=\"messages\"></ul>\n    <form action=\"\">\n      <input id=\"m\" autocomplete=\"off\" /><button>Send</button>\n    </form>\n  </body>\n</html>\n```\n\nIf you restart the process (by hitting Control+C and running `node index` again) and refresh the page it should look like this:\n\n<img src=\"/images/chat-3.png\" alt=\"A browser displaying an input and a 'Send' button\">\n\n## Integrating Socket.IO\n\nSocket.IO is composed of two parts:\n\n- A server that integrates with (or mounts on) the Node.JS HTTP Server: [socket.io](https://github.com/socketio/socket.io)\n- A client library that loads on the browser side: [socket.io-client](https://github.com/socketio/socket.io-client)\n\nDuring development, `socket.io` serves the client automatically for us, as we’ll see, so for now we only have to install one module:\n\n```\nnpm install --save socket.io\n```\n\nThat will install the module and add the dependency to `package.json`. Now let’s edit `index.js` to add it:\n\n```js\nvar app = require('express')();\nvar http = require('http').Server(app);\nvar io = require('socket.io')(http);\n\napp.get('/', function(req, res){\n  res.sendFile(__dirname + '/index.html');\n});\n\nio.on('connection', function(socket){\n  console.log('a user connected');\n});\n\nhttp.listen(3000, function(){\n  console.log('listening on *:3000');\n});\n```\n\nNotice that I initialize a new instance of `socket.io` by passing the `http` (the HTTP server) object. Then I listen on the `connection` event for incoming sockets, and I log it to the console.\n\nNow in index.html I add the following snippet before the `</body>`:\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io();\n</script>\n```\n\nThat’s all it takes to load the `socket.io-client`, which exposes a `io` global, and then connect.\n\nNotice that I’m not specifying any URL when I call `io()`, since it defaults to trying to connect to the host that serves the page.\n\nIf you now reload the server and the website you should see the console print “a user connected”.\n\nTry opening several tabs, and you’ll see several messages:\n\n<img src=\"/images/chat-4.png\" alt=\"A console displaying several messages, indicating that some users have connected\">\n\nEach socket also fires a special `disconnect` event:\n\n```js\nio.on('connection', function(socket){\n  console.log('a user connected');\n  socket.on('disconnect', function(){\n    console.log('user disconnected');\n  });\n});\n```\n\nThen if you refresh a tab several times you can see it in action:\n\n<img src=\"/images/chat-5.png\" alt=\"A console displaying several messages, indicating that some users have connected and disconnected\">\n\n## Emitting events\n\nThe main idea behind Socket.IO is that you can send and receive any events you want, with any data you want. Any objects that can be encoded as JSON will do, and [binary data](/blog/introducing-socket-io-1-0/#binary) is supported too.\n\nLet’s make it so that when the user types in a message, the server gets it as a `chat message` event. The `script`s section in `index.html` should now look as follows:\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script src=\"https://code.jquery.com/jquery-1.11.1.js\"></script>\n<script>\n  $(function () {\n    var socket = io();\n    $('form').submit(function(){\n      socket.emit('chat message', $('#m').val());\n      $('#m').val('');\n      return false;\n    });\n  });\n</script>\n```\n\nAnd in `index.js` we print out the `chat message` event:\n\n```js\nio.on('connection', function(socket){\n  socket.on('chat message', function(msg){\n    console.log('message: ' + msg);\n  });\n});\n```\n\nThe result should be like the following video:\n\n<video autoplay=\"\" loop=\"\" width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/zboNrGSsai.mp4\"></video>\n\n## Broadcasting\n\nThe next goal is for us to emit the event from the server to the rest of the users.\n\nIn order to send an event to everyone, Socket.IO gives us the `io.emit`:\n\n```js\nio.emit('some event', { for: 'everyone' });\n```\n\nIf you want to send a message to everyone except for a certain socket, we have the `broadcast` flag:\n\n```js\nio.on('connection', function(socket){\n  socket.broadcast.emit('hi');\n});\n```\n\nIn this case, for the sake of simplicity we’ll send the message to everyone, including the sender.\n\n```js\nio.on('connection', function(socket){\n  socket.on('chat message', function(msg){\n    io.emit('chat message', msg);\n  });\n});\n```\n\nAnd on the client side when we capture a `chat message` event we’ll include it in the page. The total client-side JavaScript code now amounts to:\n\n```html\n<script>\n  $(function () {\n    var socket = io();\n    $('form').submit(function(){\n      socket.emit('chat message', $('#m').val());\n      $('#m').val('');\n      return false;\n    });\n    socket.on('chat message', function(msg){\n      $('#messages').append($('<li>').text(msg));\n    });\n  });\n</script>\n```\n\nAnd that completes our chat application, in about 20 lines of code! This is what it looks like:\n\n<video autoplay=\"\" loop=\"\" width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/J4xwRU9DRn.mp4\"></video>\n\n## Homework\n\nHere are some ideas to improve the application:\n\n- Broadcast a message to connected users when someone connects or disconnects\n- Add support for nicknames\n- Don’t send the same message to the user that sent it himself. Instead, append the message directly as soon as he presses enter.\n- Add “{user} is typing” functionality\n- Show who’s online\n- Add private messaging\n- Share your improvements!\n\n## Getting this example\n\nYou can find it on GitHub [here](https://github.com/socketio/chat-example).\n\n```\ngit clone https://github.com/socketio/chat-example.git\n```\n","date":"2018-07-21T06:54:24.643Z","updated":"2018-07-21T06:54:24.643Z","path":"/get-started/chat/index.html","comments":1,"layout":"page","_id":"cjjxdyebm000djgcxrs4fu15l","content":"<p>In this guide we’ll create a basic chat application. It requires almost no basic prior knowledge of Node.JS or Socket.IO, so it’s ideal for users of all knowledge levels.</p>\n<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>Writing a chat application with popular web applications stacks like LAMP (PHP) has traditionally been very hard. It involves polling the server for changes, keeping track of timestamps, and it’s a lot slower than it should be.</p>\n<p>Sockets have traditionally been the solution around which most realtime chat systems are architected, providing a bi-directional communication channel between a client and a server.</p>\n<p>This means that the server can <em>push</em> messages to clients. Whenever you write a chat message, the idea is that the server will get it and push it to all other connected clients.</p>\n<h2 id=\"The-web-framework\"><a href=\"#The-web-framework\" class=\"headerlink\" title=\"The web framework\"></a>The web framework</h2><p>The first goal is to setup a simple HTML webpage that serves out a form and a list of messages. We’re going to use the Node.JS web framework <code>express</code> to this end. Make sure <a href=\"https://nodejs.org\" target=\"_blank\" rel=\"noopener\">Node.JS</a> is installed.</p>\n<p>First let’s create a <code>package.json</code> manifest file that describes our project. I recommend you place it in a dedicated empty directory (I’ll call mine <code>chat-example</code>).</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"socket-chat-example\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.0.1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"my first socket.io app\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"dependencies\"</span>: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Now, in order to easily populate the <code>dependencies</code> with the things we need, we’ll use <code>npm install --save</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save express@4.15.2</span><br></pre></td></tr></table></figure>\n<p>Now that express is installed we can create an <code>index.js</code> file that will setup our application.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).Server(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">'&lt;h1&gt;Hello world&lt;/h1&gt;'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening on *:3000'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>This translates into the following:</p>\n<ul>\n<li>Express initializes <code>app</code> to be a function handler that you can supply to an HTTP server (as seen in line 2). </li>\n<li>We define a route handler <code>/</code> that gets called when we hit our website home.</li>\n<li>We make the http server listen on port 3000.</li>\n</ul>\n<p>If you run <code>node index.js</code> you should see the following:</p>\n<p><img src=\"/images/chat-1.png\" alt=\"A console saying that the server has started listening on port 3000\"></p>\n<p>And if you point your browser to <code>http://localhost:3000</code>:</p>\n<p><img src=\"/images/chat-2.png\" alt=\"A browser displaying a big 'Hello World'\"></p>\n<h2 id=\"Serving-HTML\"><a href=\"#Serving-HTML\" class=\"headerlink\" title=\"Serving HTML\"></a>Serving HTML</h2><p>So far in <code>index.js</code> we’re calling <code>res.send</code> and pass it a HTML string. Our code would look very confusing if we just placed our entire application’s HTML there. Instead, we’re going to create a <code>index.html</code> file and serve it.</p>\n<p>Let’s refactor our route handler to use <code>sendFile</code> instead:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>And populate <code>index.html</code> with the following:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Socket.IO chat<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">      * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      body &#123; font: 13px Helvetica, Arial; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      #messages li &#123; padding: 5px 10px; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      #messages li:nth-child(odd) &#123; background: #eee; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"messages\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"m\"</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">\"off\"</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>Send<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>If you restart the process (by hitting Control+C and running <code>node index</code> again) and refresh the page it should look like this:</p>\n<p><img src=\"/images/chat-3.png\" alt=\"A browser displaying an input and a 'Send' button\"></p>\n<h2 id=\"Integrating-Socket-IO\"><a href=\"#Integrating-Socket-IO\" class=\"headerlink\" title=\"Integrating Socket.IO\"></a>Integrating Socket.IO</h2><p>Socket.IO is composed of two parts:</p>\n<ul>\n<li>A server that integrates with (or mounts on) the Node.JS HTTP Server: <a href=\"https://github.com/socketio/socket.io\" target=\"_blank\" rel=\"noopener\">socket.io</a></li>\n<li>A client library that loads on the browser side: <a href=\"https://github.com/socketio/socket.io-client\" target=\"_blank\" rel=\"noopener\">socket.io-client</a></li>\n</ul>\n<p>During development, <code>socket.io</code> serves the client automatically for us, as we’ll see, so for now we only have to install one module:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save socket.io</span><br></pre></td></tr></table></figure>\n<p>That will install the module and add the dependency to <code>package.json</code>. Now let’s edit <code>index.js</code> to add it:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).Server(app);</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(http);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a user connected'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening on *:3000'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Notice that I initialize a new instance of <code>socket.io</code> by passing the <code>http</code> (the HTTP server) object. Then I listen on the <code>connection</code> event for incoming sockets, and I log it to the console.</p>\n<p>Now in index.html I add the following snippet before the <code>&lt;/body&gt;</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io();</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>That’s all it takes to load the <code>socket.io-client</code>, which exposes a <code>io</code> global, and then connect.</p>\n<p>Notice that I’m not specifying any URL when I call <code>io()</code>, since it defaults to trying to connect to the host that serves the page.</p>\n<p>If you now reload the server and the website you should see the console print “a user connected”.</p>\n<p>Try opening several tabs, and you’ll see several messages:</p>\n<p><img src=\"/images/chat-4.png\" alt=\"A console displaying several messages, indicating that some users have connected\"></p>\n<p>Each socket also fires a special <code>disconnect</code> event:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a user connected'</span>);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'user disconnected'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Then if you refresh a tab several times you can see it in action:</p>\n<p><img src=\"/images/chat-5.png\" alt=\"A console displaying several messages, indicating that some users have connected and disconnected\"></p>\n<h2 id=\"Emitting-events\"><a href=\"#Emitting-events\" class=\"headerlink\" title=\"Emitting events\"></a>Emitting events</h2><p>The main idea behind Socket.IO is that you can send and receive any events you want, with any data you want. Any objects that can be encoded as JSON will do, and <a href=\"/blog/introducing-socket-io-1-0/#binary\">binary data</a> is supported too.</p>\n<p>Let’s make it so that when the user types in a message, the server gets it as a <code>chat message</code> event. The <code>script</code>s section in <code>index.html</code> should now look as follows:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://code.jquery.com/jquery-1.11.1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> socket = io();</span></span><br><span class=\"line\"><span class=\"javascript\">    $(<span class=\"string\">'form'</span>).submit(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      socket.emit(<span class=\"string\">'chat message'</span>, $(<span class=\"string\">'#m'</span>).val());</span></span><br><span class=\"line\"><span class=\"javascript\">      $(<span class=\"string\">'#m'</span>).val(<span class=\"string\">''</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>And in <code>index.js</code> we print out the <code>chat message</code> event:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'chat message'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'message: '</span> + msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The result should be like the following video:</p>\n<video autoplay loop width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/zboNrGSsai.mp4\"></video>\n\n<h2 id=\"Broadcasting\"><a href=\"#Broadcasting\" class=\"headerlink\" title=\"Broadcasting\"></a>Broadcasting</h2><p>The next goal is for us to emit the event from the server to the rest of the users.</p>\n<p>In order to send an event to everyone, Socket.IO gives us the <code>io.emit</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.emit(<span class=\"string\">'some event'</span>, &#123; <span class=\"attr\">for</span>: <span class=\"string\">'everyone'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>If you want to send a message to everyone except for a certain socket, we have the <code>broadcast</code> flag:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.broadcast.emit(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>In this case, for the sake of simplicity we’ll send the message to everyone, including the sender.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'chat message'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">    io.emit(<span class=\"string\">'chat message'</span>, msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>And on the client side when we capture a <code>chat message</code> event we’ll include it in the page. The total client-side JavaScript code now amounts to:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> socket = io();</span></span><br><span class=\"line\"><span class=\"javascript\">    $(<span class=\"string\">'form'</span>).submit(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      socket.emit(<span class=\"string\">'chat message'</span>, $(<span class=\"string\">'#m'</span>).val());</span></span><br><span class=\"line\"><span class=\"javascript\">      $(<span class=\"string\">'#m'</span>).val(<span class=\"string\">''</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.on(<span class=\"string\">'chat message'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      $(<span class=\"string\">'#messages'</span>).append($(<span class=\"string\">'&lt;li&gt;'</span>).text(msg));</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>And that completes our chat application, in about 20 lines of code! This is what it looks like:</p>\n<video autoplay loop width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/J4xwRU9DRn.mp4\"></video>\n\n<h2 id=\"Homework\"><a href=\"#Homework\" class=\"headerlink\" title=\"Homework\"></a>Homework</h2><p>Here are some ideas to improve the application:</p>\n<ul>\n<li>Broadcast a message to connected users when someone connects or disconnects</li>\n<li>Add support for nicknames</li>\n<li>Don’t send the same message to the user that sent it himself. Instead, append the message directly as soon as he presses enter.</li>\n<li>Add “{user} is typing” functionality</li>\n<li>Show who’s online</li>\n<li>Add private messaging</li>\n<li>Share your improvements!</li>\n</ul>\n<h2 id=\"Getting-this-example\"><a href=\"#Getting-this-example\" class=\"headerlink\" title=\"Getting this example\"></a>Getting this example</h2><p>You can find it on GitHub <a href=\"https://github.com/socketio/chat-example\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/socketio/chat-example.git</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>In this guide we’ll create a basic chat application. It requires almost no basic prior knowledge of Node.JS or Socket.IO, so it’s ideal for users of all knowledge levels.</p>\n<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>Writing a chat application with popular web applications stacks like LAMP (PHP) has traditionally been very hard. It involves polling the server for changes, keeping track of timestamps, and it’s a lot slower than it should be.</p>\n<p>Sockets have traditionally been the solution around which most realtime chat systems are architected, providing a bi-directional communication channel between a client and a server.</p>\n<p>This means that the server can <em>push</em> messages to clients. Whenever you write a chat message, the idea is that the server will get it and push it to all other connected clients.</p>\n<h2 id=\"The-web-framework\"><a href=\"#The-web-framework\" class=\"headerlink\" title=\"The web framework\"></a>The web framework</h2><p>The first goal is to setup a simple HTML webpage that serves out a form and a list of messages. We’re going to use the Node.JS web framework <code>express</code> to this end. Make sure <a href=\"https://nodejs.org\" target=\"_blank\" rel=\"noopener\">Node.JS</a> is installed.</p>\n<p>First let’s create a <code>package.json</code> manifest file that describes our project. I recommend you place it in a dedicated empty directory (I’ll call mine <code>chat-example</code>).</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"socket-chat-example\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.0.1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"my first socket.io app\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"dependencies\"</span>: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Now, in order to easily populate the <code>dependencies</code> with the things we need, we’ll use <code>npm install --save</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save express@4.15.2</span><br></pre></td></tr></table></figure>\n<p>Now that express is installed we can create an <code>index.js</code> file that will setup our application.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).Server(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">'&lt;h1&gt;Hello world&lt;/h1&gt;'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening on *:3000'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>This translates into the following:</p>\n<ul>\n<li>Express initializes <code>app</code> to be a function handler that you can supply to an HTTP server (as seen in line 2). </li>\n<li>We define a route handler <code>/</code> that gets called when we hit our website home.</li>\n<li>We make the http server listen on port 3000.</li>\n</ul>\n<p>If you run <code>node index.js</code> you should see the following:</p>\n<p><img src=\"/images/chat-1.png\" alt=\"A console saying that the server has started listening on port 3000\"></p>\n<p>And if you point your browser to <code>http://localhost:3000</code>:</p>\n<p><img src=\"/images/chat-2.png\" alt=\"A browser displaying a big 'Hello World'\"></p>\n<h2 id=\"Serving-HTML\"><a href=\"#Serving-HTML\" class=\"headerlink\" title=\"Serving HTML\"></a>Serving HTML</h2><p>So far in <code>index.js</code> we’re calling <code>res.send</code> and pass it a HTML string. Our code would look very confusing if we just placed our entire application’s HTML there. Instead, we’re going to create a <code>index.html</code> file and serve it.</p>\n<p>Let’s refactor our route handler to use <code>sendFile</code> instead:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>And populate <code>index.html</code> with the following:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Socket.IO chat<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">      * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      body &#123; font: 13px Helvetica, Arial; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      #messages li &#123; padding: 5px 10px; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">      #messages li:nth-child(odd) &#123; background: #eee; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"messages\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"m\"</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">\"off\"</span> /&gt;</span><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>Send<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>If you restart the process (by hitting Control+C and running <code>node index</code> again) and refresh the page it should look like this:</p>\n<p><img src=\"/images/chat-3.png\" alt=\"A browser displaying an input and a 'Send' button\"></p>\n<h2 id=\"Integrating-Socket-IO\"><a href=\"#Integrating-Socket-IO\" class=\"headerlink\" title=\"Integrating Socket.IO\"></a>Integrating Socket.IO</h2><p>Socket.IO is composed of two parts:</p>\n<ul>\n<li>A server that integrates with (or mounts on) the Node.JS HTTP Server: <a href=\"https://github.com/socketio/socket.io\" target=\"_blank\" rel=\"noopener\">socket.io</a></li>\n<li>A client library that loads on the browser side: <a href=\"https://github.com/socketio/socket.io-client\" target=\"_blank\" rel=\"noopener\">socket.io-client</a></li>\n</ul>\n<p>During development, <code>socket.io</code> serves the client automatically for us, as we’ll see, so for now we only have to install one module:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save socket.io</span><br></pre></td></tr></table></figure>\n<p>That will install the module and add the dependency to <code>package.json</code>. Now let’s edit <code>index.js</code> to add it:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>).Server(app);</span><br><span class=\"line\"><span class=\"keyword\">var</span> io = <span class=\"built_in\">require</span>(<span class=\"string\">'socket.io'</span>)(http);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a user connected'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening on *:3000'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Notice that I initialize a new instance of <code>socket.io</code> by passing the <code>http</code> (the HTTP server) object. Then I listen on the <code>connection</code> event for incoming sockets, and I log it to the console.</p>\n<p>Now in index.html I add the following snippet before the <code>&lt;/body&gt;</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> socket = io();</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>That’s all it takes to load the <code>socket.io-client</code>, which exposes a <code>io</code> global, and then connect.</p>\n<p>Notice that I’m not specifying any URL when I call <code>io()</code>, since it defaults to trying to connect to the host that serves the page.</p>\n<p>If you now reload the server and the website you should see the console print “a user connected”.</p>\n<p>Try opening several tabs, and you’ll see several messages:</p>\n<p><img src=\"/images/chat-4.png\" alt=\"A console displaying several messages, indicating that some users have connected\"></p>\n<p>Each socket also fires a special <code>disconnect</code> event:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a user connected'</span>);</span><br><span class=\"line\">  socket.on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'user disconnected'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Then if you refresh a tab several times you can see it in action:</p>\n<p><img src=\"/images/chat-5.png\" alt=\"A console displaying several messages, indicating that some users have connected and disconnected\"></p>\n<h2 id=\"Emitting-events\"><a href=\"#Emitting-events\" class=\"headerlink\" title=\"Emitting events\"></a>Emitting events</h2><p>The main idea behind Socket.IO is that you can send and receive any events you want, with any data you want. Any objects that can be encoded as JSON will do, and <a href=\"/blog/introducing-socket-io-1-0/#binary\">binary data</a> is supported too.</p>\n<p>Let’s make it so that when the user types in a message, the server gets it as a <code>chat message</code> event. The <code>script</code>s section in <code>index.html</code> should now look as follows:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/socket.io/socket.io.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://code.jquery.com/jquery-1.11.1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> socket = io();</span></span><br><span class=\"line\"><span class=\"javascript\">    $(<span class=\"string\">'form'</span>).submit(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      socket.emit(<span class=\"string\">'chat message'</span>, $(<span class=\"string\">'#m'</span>).val());</span></span><br><span class=\"line\"><span class=\"javascript\">      $(<span class=\"string\">'#m'</span>).val(<span class=\"string\">''</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>And in <code>index.js</code> we print out the <code>chat message</code> event:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'chat message'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'message: '</span> + msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>The result should be like the following video:</p>\n<video autoplay loop width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/zboNrGSsai.mp4\"></video>\n\n<h2 id=\"Broadcasting\"><a href=\"#Broadcasting\" class=\"headerlink\" title=\"Broadcasting\"></a>Broadcasting</h2><p>The next goal is for us to emit the event from the server to the rest of the users.</p>\n<p>In order to send an event to everyone, Socket.IO gives us the <code>io.emit</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.emit(<span class=\"string\">'some event'</span>, &#123; <span class=\"attr\">for</span>: <span class=\"string\">'everyone'</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>If you want to send a message to everyone except for a certain socket, we have the <code>broadcast</code> flag:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.broadcast.emit(<span class=\"string\">'hi'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>In this case, for the sake of simplicity we’ll send the message to everyone, including the sender.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">io.on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">socket</span>)</span>&#123;</span><br><span class=\"line\">  socket.on(<span class=\"string\">'chat message'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">    io.emit(<span class=\"string\">'chat message'</span>, msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>And on the client side when we capture a <code>chat message</code> event we’ll include it in the page. The total client-side JavaScript code now amounts to:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  $(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> socket = io();</span></span><br><span class=\"line\"><span class=\"javascript\">    $(<span class=\"string\">'form'</span>).submit(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      socket.emit(<span class=\"string\">'chat message'</span>, $(<span class=\"string\">'#m'</span>).val());</span></span><br><span class=\"line\"><span class=\"javascript\">      $(<span class=\"string\">'#m'</span>).val(<span class=\"string\">''</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\">    socket.on(<span class=\"string\">'chat message'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      $(<span class=\"string\">'#messages'</span>).append($(<span class=\"string\">'&lt;li&gt;'</span>).text(msg));</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>And that completes our chat application, in about 20 lines of code! This is what it looks like:</p>\n<video autoplay loop width=\"100%\"><source src=\"https://i.cloudup.com/transcoded/J4xwRU9DRn.mp4\"></video>\n\n<h2 id=\"Homework\"><a href=\"#Homework\" class=\"headerlink\" title=\"Homework\"></a>Homework</h2><p>Here are some ideas to improve the application:</p>\n<ul>\n<li>Broadcast a message to connected users when someone connects or disconnects</li>\n<li>Add support for nicknames</li>\n<li>Don’t send the same message to the user that sent it himself. Instead, append the message directly as soon as he presses enter.</li>\n<li>Add “{user} is typing” functionality</li>\n<li>Show who’s online</li>\n<li>Add private messaging</li>\n<li>Share your improvements!</li>\n</ul>\n<h2 id=\"Getting-this-example\"><a href=\"#Getting-this-example\" class=\"headerlink\" title=\"Getting this example\"></a>Getting this example</h2><p>You can find it on GitHub <a href=\"https://github.com/socketio/chat-example\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/socketio/chat-example.git</span><br></pre></td></tr></table></figure>\n"},{"title":"Socket.IO  —  Get started","_content":"\n## CHOOSE YOUR OWN ADVENTURE!\n\n- [Write a chat application](/get-started/chat)\n\nRecommended for beginners to Socket.IO or Node.js. The “Hello world!” of the framework is here.\n","source":"get-started/index.md","raw":"title: Socket.IO  —  Get started\npermalink: /get-started/\n---\n\n## CHOOSE YOUR OWN ADVENTURE!\n\n- [Write a chat application](/get-started/chat)\n\nRecommended for beginners to Socket.IO or Node.js. The “Hello world!” of the framework is here.\n","date":"2018-07-21T06:58:53.600Z","updated":"2018-07-21T06:58:53.600Z","path":"/get-started/index.html","comments":1,"layout":"page","_id":"cjjxdyebn000ejgcxnra0mh1z","content":"<h2 id=\"CHOOSE-YOUR-OWN-ADVENTURE\"><a href=\"#CHOOSE-YOUR-OWN-ADVENTURE\" class=\"headerlink\" title=\"CHOOSE YOUR OWN ADVENTURE!\"></a>CHOOSE YOUR OWN ADVENTURE!</h2><ul>\n<li><a href=\"/get-started/chat\">Write a chat application</a></li>\n</ul>\n<p>Recommended for beginners to Socket.IO or Node.js. The “Hello world!” of the framework is here.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CHOOSE-YOUR-OWN-ADVENTURE\"><a href=\"#CHOOSE-YOUR-OWN-ADVENTURE\" class=\"headerlink\" title=\"CHOOSE YOUR OWN ADVENTURE!\"></a>CHOOSE YOUR OWN ADVENTURE!</h2><ul>\n<li><a href=\"/get-started/chat\">Write a chat application</a></li>\n</ul>\n<p>Recommended for beginners to Socket.IO or Node.js. The “Hello world!” of the framework is here.</p>\n"}],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}